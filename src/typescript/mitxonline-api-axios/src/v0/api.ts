/* tslint:disable */
/* eslint-disable */
/**
 * MITx Online API
 * MIT public API
 *
 * The version of the OpenAPI document: 0.0.1 (v0)
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * * `anytime` - anytime * `dated` - dated
 * @export
 * @enum {string}
 */

export const AvailabilityEnum = {
    /**
    * anytime
    */
    Anytime: 'anytime',
    /**
    * dated
    */
    Dated: 'dated'
} as const;

export type AvailabilityEnum = typeof AvailabilityEnum[keyof typeof AvailabilityEnum];


/**
 * Basic course model serializer
 * @export
 * @interface BaseCourse
 */
export interface BaseCourse {
    /**
     * 
     * @type {number}
     * @memberof BaseCourse
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof BaseCourse
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof BaseCourse
     */
    'readable_id': string;
    /**
     * Returns the type of object this is serializing.
     * @type {string}
     * @memberof BaseCourse
     */
    'type': string;
}
/**
 * Basic program model serializer
 * @export
 * @interface BaseProgram
 */
export interface BaseProgram {
    /**
     * 
     * @type {string}
     * @memberof BaseProgram
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof BaseProgram
     */
    'readable_id': string;
    /**
     * 
     * @type {number}
     * @memberof BaseProgram
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof BaseProgram
     */
    'type': string;
}
/**
 * Basket model serializer
 * @export
 * @interface Basket
 */
export interface Basket {
    /**
     * 
     * @type {number}
     * @memberof Basket
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof Basket
     */
    'user': number;
    /**
     * 
     * @type {Array<BasketItem>}
     * @memberof Basket
     */
    'basket_items': Array<BasketItem>;
}
/**
 * BasketDiscount model serializer
 * @export
 * @interface BasketDiscountDetail
 */
export interface BasketDiscountDetail {
    /**
     * 
     * @type {V0Discount}
     * @memberof BasketDiscountDetail
     */
    'redeemed_discount': V0Discount;
    /**
     * 
     * @type {Basket}
     * @memberof BasketDiscountDetail
     */
    'redeemed_basket': Basket;
}
/**
 * BasketItem model serializer
 * @export
 * @interface BasketItem
 */
export interface BasketItem {
    /**
     * 
     * @type {number}
     * @memberof BasketItem
     */
    'basket': number;
    /**
     * 
     * @type {number}
     * @memberof BasketItem
     */
    'product': number;
    /**
     * 
     * @type {number}
     * @memberof BasketItem
     */
    'id': number;
}
/**
 * Serializer for Basket model with product details
 * @export
 * @interface BasketWithProduct
 */
export interface BasketWithProduct {
    /**
     * 
     * @type {number}
     * @memberof BasketWithProduct
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof BasketWithProduct
     */
    'user': number;
    /**
     * 
     * @type {Array<BasketWithProductBasketItemsInner>}
     * @memberof BasketWithProduct
     */
    'basket_items': Array<BasketWithProductBasketItemsInner>;
    /**
     * Get total price of all items in basket before discounts
     * @type {number}
     * @memberof BasketWithProduct
     */
    'total_price': number;
    /**
     * Get total price after any discounts are applied
     * @type {number}
     * @memberof BasketWithProduct
     */
    'discounted_price': number;
    /**
     * 
     * @type {Array<BasketDiscountDetail>}
     * @memberof BasketWithProduct
     */
    'discounts': Array<BasketDiscountDetail>;
}
/**
 * 
 * @export
 * @interface BasketWithProductBasketItemsInner
 */
export interface BasketWithProductBasketItemsInner {
    /**
     * 
     * @type {number}
     * @memberof BasketWithProductBasketItemsInner
     */
    'basket'?: number;
    /**
     * 
     * @type {BasketWithProductBasketItemsInnerProduct}
     * @memberof BasketWithProductBasketItemsInner
     */
    'product'?: BasketWithProductBasketItemsInnerProduct;
    /**
     * 
     * @type {number}
     * @memberof BasketWithProductBasketItemsInner
     */
    'id'?: number;
}
/**
 * 
 * @export
 * @interface BasketWithProductBasketItemsInnerProduct
 */
export interface BasketWithProductBasketItemsInnerProduct {
    /**
     * 
     * @type {number}
     * @memberof BasketWithProductBasketItemsInnerProduct
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof BasketWithProductBasketItemsInnerProduct
     */
    'price'?: number;
    /**
     * 
     * @type {string}
     * @memberof BasketWithProductBasketItemsInnerProduct
     */
    'description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof BasketWithProductBasketItemsInnerProduct
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof BasketWithProductBasketItemsInnerProduct
     */
    'purchasable_object'?: object;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const BlankEnum = {
    Empty: ''
} as const;

export type BlankEnum = typeof BlankEnum[keyof typeof BlankEnum];


/**
 * Serializer for certificate pages, including overrides and signatory items.
 * @export
 * @interface CertificatePage
 */
export interface CertificatePage {
    /**
     * 
     * @type {number}
     * @memberof CertificatePage
     */
    'id': number;
    /**
     * 
     * @type {PageMeta}
     * @memberof CertificatePage
     */
    'meta': PageMeta;
    /**
     * 
     * @type {string}
     * @memberof CertificatePage
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof CertificatePage
     */
    'product_name': string;
    /**
     * 
     * @type {string}
     * @memberof CertificatePage
     */
    'CEUs': string;
    /**
     * 
     * @type {Array<Override>}
     * @memberof CertificatePage
     */
    'overrides': Array<Override>;
    /**
     * 
     * @type {Array<SignatoryItem>}
     * @memberof CertificatePage
     */
    'signatory_items': Array<SignatoryItem>;
}
/**
 * Serializer for a list of certificate pages.
 * @export
 * @interface CertificatePageList
 */
export interface CertificatePageList {
    /**
     * 
     * @type {PageListMeta}
     * @memberof CertificatePageList
     */
    'meta': PageListMeta;
    /**
     * 
     * @type {Array<CertificatePage>}
     * @memberof CertificatePageList
     */
    'items': Array<CertificatePage>;
}
/**
 * Extends the CertificatePageSerializer to work with a model object.
 * @export
 * @interface CertificatePageModel
 */
export interface CertificatePageModel {
    /**
     * 
     * @type {number}
     * @memberof CertificatePageModel
     */
    'id': number;
    /**
     * 
     * @type {PageMetaModel}
     * @memberof CertificatePageModel
     */
    'meta': PageMetaModel;
    /**
     * 
     * @type {string}
     * @memberof CertificatePageModel
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof CertificatePageModel
     */
    'product_name': string;
    /**
     * 
     * @type {string}
     * @memberof CertificatePageModel
     */
    'CEUs': string;
    /**
     * 
     * @type {Array<Override>}
     * @memberof CertificatePageModel
     */
    'overrides': Array<Override>;
    /**
     * 
     * @type {Array<SignatoryItem>}
     * @memberof CertificatePageModel
     */
    'signatory_items': Array<SignatoryItem>;
}
/**
 * Serializer for starting a user email change
 * @export
 * @interface ChangeEmailRequestCreate
 */
export interface ChangeEmailRequestCreate {
    /**
     * 
     * @type {string}
     * @memberof ChangeEmailRequestCreate
     */
    'new_email': string;
}
/**
 * Serializer for starting a user email change
 * @export
 * @interface ChangeEmailRequestCreateRequest
 */
export interface ChangeEmailRequestCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof ChangeEmailRequestCreateRequest
     */
    'new_email': string;
    /**
     * 
     * @type {string}
     * @memberof ChangeEmailRequestCreateRequest
     */
    'password': string;
}
/**
 * Serializer for confirming a user email change
 * @export
 * @interface ChangeEmailRequestUpdate
 */
export interface ChangeEmailRequestUpdate {
    /**
     * 
     * @type {boolean}
     * @memberof ChangeEmailRequestUpdate
     */
    'confirmed': boolean;
}
/**
 * Serializer for confirming a user email change
 * @export
 * @interface ChangeEmailRequestUpdateRequest
 */
export interface ChangeEmailRequestUpdateRequest {
    /**
     * 
     * @type {boolean}
     * @memberof ChangeEmailRequestUpdateRequest
     */
    'confirmed': boolean;
}
/**
 * Serializes the payload for the checkout data.
 * @export
 * @interface CheckoutPayload
 */
export interface CheckoutPayload {
    /**
     * Set if the order was automatically completed and no checkout process is required.
     * @type {boolean}
     * @memberof CheckoutPayload
     */
    'no_checkout': boolean;
    /**
     * The URL to POST the form to.
     * @type {string}
     * @memberof CheckoutPayload
     */
    'url': string;
    /**
     * The method to use for the checkout form (always POST).
     * @type {string}
     * @memberof CheckoutPayload
     */
    'method': string;
    /**
     * The data for the form.
     * @type {any}
     * @memberof CheckoutPayload
     */
    'payload': any;
    /**
     * If the order was automatically completed, the ID of the new order.
     * @type {number}
     * @memberof CheckoutPayload
     */
    'order_id': number;
    /**
     * 
     * @type {ErrorEnum}
     * @memberof CheckoutPayload
     */
    'error': ErrorEnum;
}


/**
 * * `None` - ---- * `1` - Small/Start-up (1+ employees) * `9` - Small/Home office (1-9 employees) * `99` - Small (10-99 employees) * `999` - Small to medium-sized (100-999 employees) * `9999` - Medium-sized (1000-9999 employees) * `10000` - Large Enterprise (10,000+ employees) * `0` - Other (N/A or Don\'t know)
 * @export
 * @enum {string}
 */

export const CompanySizeEnum = {
    /**
    * Small/Start-up (1+ employees)
    */
    NUMBER_1: 1,
    /**
    * Small/Home office (1-9 employees)
    */
    NUMBER_9: 9,
    /**
    * Small (10-99 employees)
    */
    NUMBER_99: 99,
    /**
    * Small to medium-sized (100-999 employees)
    */
    NUMBER_999: 999,
    /**
    * Medium-sized (1000-9999 employees)
    */
    NUMBER_9999: 9999,
    /**
    * Large Enterprise (10,000+ employees)
    */
    NUMBER_10000: 10000,
    /**
    * Other (N/A or Don&#39;t know)
    */
    NUMBER_0: 0
} as const;

export type CompanySizeEnum = typeof CompanySizeEnum[keyof typeof CompanySizeEnum];


/**
 * Serializer for the ContractPage model.
 * @export
 * @interface ContractPage
 */
export interface ContractPage {
    /**
     * 
     * @type {number}
     * @memberof ContractPage
     */
    'id': number;
    /**
     * The name of the contract.
     * @type {string}
     * @memberof ContractPage
     */
    'name': string;
    /**
     * Any useful extra information about the contract.
     * @type {string}
     * @memberof ContractPage
     */
    'description': string;
    /**
     * A welcome message for learners.
     * @type {string}
     * @memberof ContractPage
     */
    'welcome_message': string;
    /**
     * Additional welcome message content for learners.
     * @type {string}
     * @memberof ContractPage
     */
    'welcome_message_extra': string;
    /**
     * 
     * @type {IntegrationTypeEnum}
     * @memberof ContractPage
     */
    'integration_type': IntegrationTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ContractPage
     */
    'membership_type': string;
    /**
     * The organization that owns this contract.
     * @type {number}
     * @memberof ContractPage
     */
    'organization': number;
    /**
     * The start date of the contract.
     * @type {string}
     * @memberof ContractPage
     */
    'contract_start': string | null;
    /**
     * The end date of the contract.
     * @type {string}
     * @memberof ContractPage
     */
    'contract_end': string | null;
    /**
     * Whether this contract is active or not. Date rules still apply.
     * @type {boolean}
     * @memberof ContractPage
     */
    'active': boolean;
    /**
     * The name of the page as it will appear in URLs e.g http://domain.com/blog/[my-slug]/
     * @type {string}
     * @memberof ContractPage
     */
    'slug': string;
    /**
     * 
     * @type {Array<number>}
     * @memberof ContractPage
     */
    'programs': Array<number>;
}


/**
 * Serializer for pycountry countries, with states for US/CA
 * @export
 * @interface Country
 */
export interface Country {
    /**
     * Get the country alpha_2 code
     * @type {string}
     * @memberof Country
     */
    'code': string;
    /**
     * Get the country name (common name preferred if available)
     * @type {string}
     * @memberof Country
     */
    'name': string;
    /**
     * Get a list of states/provinces if USA or Canada
     * @type {Array<{ [key: string]: any; }>}
     * @memberof Country
     */
    'states': Array<{ [key: string]: any; }>;
}
/**
 * Course model serializer
 * @export
 * @interface Course
 */
export interface Course {
    /**
     * 
     * @type {number}
     * @memberof Course
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Course
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof Course
     */
    'readable_id': string;
    /**
     * Get next run id
     * @type {number}
     * @memberof Course
     */
    'next_run_id': number | null;
    /**
     * 
     * @type {Array<Department>}
     * @memberof Course
     */
    'departments': Array<Department>;
    /**
     * 
     * @type {CoursePage}
     * @memberof Course
     */
    'page': CoursePage;
    /**
     * 
     * @type {Program}
     * @memberof Course
     */
    'programs': Program | null;
}
/**
 * Course page model serializer
 * @export
 * @interface CoursePage
 */
export interface CoursePage {
    /**
     * Serializes the source of the feature_image
     * @type {string}
     * @memberof CoursePage
     */
    'feature_image_src': string;
    /**
     * 
     * @type {string}
     * @memberof CoursePage
     */
    'page_url': string;
    /**
     * Get cleaned description text.
     * @type {string}
     * @memberof CoursePage
     */
    'description': string;
    /**
     * 
     * @type {boolean}
     * @memberof CoursePage
     */
    'live': boolean;
    /**
     * Get cleaned length text.
     * @type {string}
     * @memberof CoursePage
     */
    'length': string;
    /**
     * Get cleaned effort text.
     * @type {string}
     * @memberof CoursePage
     */
    'effort': string | null;
    /**
     * 
     * @type {string}
     * @memberof CoursePage
     */
    'financial_assistance_form_url': string;
    /**
     * Get the current price of the course product.
     * @type {number}
     * @memberof CoursePage
     */
    'current_price': number | null;
    /**
     * Get instructor information
     * @type {Array<any>}
     * @memberof CoursePage
     */
    'instructors': Array<any>;
}
/**
 * Serializer for individual course page items, including all relevant fields.
 * @export
 * @interface CoursePageItem
 */
export interface CoursePageItem {
    /**
     * 
     * @type {number}
     * @memberof CoursePageItem
     */
    'id': number;
    /**
     * 
     * @type {PageMeta}
     * @memberof CoursePageItem
     */
    'meta': PageMeta;
    /**
     * The page title as you\'d like it to be seen by the public
     * @type {string}
     * @memberof CoursePageItem
     */
    'title': string;
    /**
     * The description shown on the home page and product page.
     * @type {string}
     * @memberof CoursePageItem
     */
    'description': string;
    /**
     * A short description indicating how long it takes to complete (e.g. \'4 weeks\').
     * @type {string}
     * @memberof CoursePageItem
     */
    'length': string;
    /**
     * A short description indicating how much effort is required (e.g. 1-3 hours per week).
     * @type {string}
     * @memberof CoursePageItem
     */
    'effort': string | null;
    /**
     * The minimum number of hours per week required to complete the course.
     * @type {string}
     * @memberof CoursePageItem
     */
    'min_weekly_hours': string;
    /**
     * The maximum number of hours per week required to complete the course.
     * @type {string}
     * @memberof CoursePageItem
     */
    'max_weekly_hours': string;
    /**
     * The minimum number of weeks required to complete the course/program.
     * @type {number}
     * @memberof CoursePageItem
     */
    'min_weeks': number | null;
    /**
     * The maximum number of weeks required to complete the course/program.
     * @type {number}
     * @memberof CoursePageItem
     */
    'max_weeks': number | null;
    /**
     * 
     * @type {Array<PriceItem>}
     * @memberof CoursePageItem
     */
    'price': Array<PriceItem>;
    /**
     * Specify the minimum product price. This is used by MIT Learn.
     * @type {number}
     * @memberof CoursePageItem
     */
    'min_price': number;
    /**
     * Specify the maximum product price. This is used by MIT Learn.
     * @type {number}
     * @memberof CoursePageItem
     */
    'max_price': number;
    /**
     * A short description indicating prerequisites of this course/program.
     * @type {string}
     * @memberof CoursePageItem
     */
    'prerequisites': string | null;
    /**
     * URL a relevant FAQ page or entry for the course/program.
     * @type {string}
     * @memberof CoursePageItem
     */
    'faq_url': string | null;
    /**
     * Details about this course/program.
     * @type {string}
     * @memberof CoursePageItem
     */
    'about': string | null;
    /**
     * *Required for Verifiable Credential generation. What you will learn from this course.
     * @type {string}
     * @memberof CoursePageItem
     */
    'what_you_learn': string | null;
    /**
     * 
     * @type {FeatureImage}
     * @memberof CoursePageItem
     */
    'feature_image': FeatureImage;
    /**
     * URL to the video to be displayed for this course/program. It can be an HLS or Youtube video URL.
     * @type {string}
     * @memberof CoursePageItem
     */
    'video_url': string | null;
    /**
     * The title text to display in the faculty cards section of the product page.
     * @type {string}
     * @memberof CoursePageItem
     */
    'faculty_section_title': string | null;
    /**
     * 
     * @type {Array<Faculty>}
     * @memberof CoursePageItem
     */
    'faculty': Array<Faculty>;
    /**
     * 
     * @type {CertificatePage}
     * @memberof CoursePageItem
     */
    'certificate_page': CertificatePage | null;
    /**
     * 
     * @type {V2Course}
     * @memberof CoursePageItem
     */
    'course_details': V2Course;
    /**
     * 
     * @type {Array<Topic>}
     * @memberof CoursePageItem
     */
    'topic_list': Array<Topic>;
    /**
     * If true, Learn should include this in its catalog.
     * @type {boolean}
     * @memberof CoursePageItem
     */
    'include_in_learn_catalog': boolean | null;
    /**
     * If true, allow the AI chatbots to ingest the course\'s content files.
     * @type {boolean}
     * @memberof CoursePageItem
     */
    'ingest_content_files_for_ai': boolean | null;
}
/**
 * Serializer for a list of course pages, including metadata and items.
 * @export
 * @interface CoursePageList
 */
export interface CoursePageList {
    /**
     * 
     * @type {PageListMeta}
     * @memberof CoursePageList
     */
    'meta': PageListMeta;
    /**
     * 
     * @type {Array<CoursePageItem>}
     * @memberof CoursePageList
     */
    'items': Array<CoursePageItem>;
}
/**
 * Course model serializer
 * @export
 * @interface CourseRequest
 */
export interface CourseRequest {
    /**
     * 
     * @type {string}
     * @memberof CourseRequest
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof CourseRequest
     */
    'readable_id': string;
}
/**
 * CourseRunCertificate model serializer
 * @export
 * @interface CourseRunCertificate
 */
export interface CourseRunCertificate {
    /**
     * 
     * @type {string}
     * @memberof CourseRunCertificate
     */
    'uuid': string;
    /**
     * Get the link at which this certificate will be served Format: /certificate/<uuid>/ Example: /certificate/93ebd74e-5f88-4b47-bb09-30a6d575328f/
     * @type {string}
     * @memberof CourseRunCertificate
     */
    'link': string;
}
/**
 * CourseRunEnrollment model serializer
 * @export
 * @interface CourseRunEnrollment
 */
export interface CourseRunEnrollment {
    /**
     * 
     * @type {V1CourseRunWithCourse}
     * @memberof CourseRunEnrollment
     */
    'run': V1CourseRunWithCourse;
    /**
     * 
     * @type {number}
     * @memberof CourseRunEnrollment
     */
    'id': number;
    /**
     * 
     * @type {boolean}
     * @memberof CourseRunEnrollment
     */
    'edx_emails_subscription'?: boolean;
    /**
     * 
     * @type {CourseRunCertificate}
     * @memberof CourseRunEnrollment
     */
    'certificate': CourseRunCertificate | null;
    /**
     * 
     * @type {EnrollmentModeEnum}
     * @memberof CourseRunEnrollment
     */
    'enrollment_mode': EnrollmentModeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof CourseRunEnrollment
     */
    'approved_flexible_price_exists': boolean;
    /**
     * 
     * @type {Array<CourseRunGrade>}
     * @memberof CourseRunEnrollment
     */
    'grades': Array<CourseRunGrade>;
}


/**
 * CourseRunEnrollment model serializer
 * @export
 * @interface CourseRunEnrollmentRequest
 */
export interface CourseRunEnrollmentRequest {
    /**
     * 
     * @type {boolean}
     * @memberof CourseRunEnrollmentRequest
     */
    'edx_emails_subscription'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof CourseRunEnrollmentRequest
     */
    'run_id': number;
}
/**
 * CourseRunEnrollment model serializer
 * @export
 * @interface CourseRunEnrollmentRequestV2
 */
export interface CourseRunEnrollmentRequestV2 {
    /**
     * 
     * @type {V2CourseRunWithCourse}
     * @memberof CourseRunEnrollmentRequestV2
     */
    'run': V2CourseRunWithCourse;
    /**
     * 
     * @type {number}
     * @memberof CourseRunEnrollmentRequestV2
     */
    'id': number;
    /**
     * 
     * @type {boolean}
     * @memberof CourseRunEnrollmentRequestV2
     */
    'edx_emails_subscription'?: boolean;
    /**
     * 
     * @type {CourseRunCertificate}
     * @memberof CourseRunEnrollmentRequestV2
     */
    'certificate': CourseRunCertificate | null;
    /**
     * 
     * @type {EnrollmentModeEnum}
     * @memberof CourseRunEnrollmentRequestV2
     */
    'enrollment_mode': EnrollmentModeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof CourseRunEnrollmentRequestV2
     */
    'approved_flexible_price_exists': boolean;
    /**
     * 
     * @type {Array<CourseRunGrade>}
     * @memberof CourseRunEnrollmentRequestV2
     */
    'grades': Array<CourseRunGrade>;
    /**
     * 
     * @type {number}
     * @memberof CourseRunEnrollmentRequestV2
     */
    'b2b_organization_id': number | null;
    /**
     * 
     * @type {number}
     * @memberof CourseRunEnrollmentRequestV2
     */
    'b2b_contract_id': number | null;
}


/**
 * CourseRunEnrollment model serializer
 * @export
 * @interface CourseRunEnrollmentRequestV2Request
 */
export interface CourseRunEnrollmentRequestV2Request {
    /**
     * 
     * @type {boolean}
     * @memberof CourseRunEnrollmentRequestV2Request
     */
    'edx_emails_subscription'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof CourseRunEnrollmentRequestV2Request
     */
    'run_id': number;
}
/**
 * CourseRunGrade serializer
 * @export
 * @interface CourseRunGrade
 */
export interface CourseRunGrade {
    /**
     * 
     * @type {number}
     * @memberof CourseRunGrade
     */
    'grade': number;
    /**
     * 
     * @type {string}
     * @memberof CourseRunGrade
     */
    'letter_grade': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof CourseRunGrade
     */
    'passed': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CourseRunGrade
     */
    'set_by_admin': boolean;
    /**
     * Returns the grade field value as a number out of 100 (or Decimal(0) if the value is None)
     * @type {number}
     * @memberof CourseRunGrade
     */
    'grade_percent': number;
}
/**
 * CourseRun model serializer
 * @export
 * @interface CourseRunV2
 */
export interface CourseRunV2 {
    /**
     * The title of the course. This value is synced automatically with edX studio.
     * @type {string}
     * @memberof CourseRunV2
     */
    'title': string;
    /**
     * The day the course begins. This value is synced automatically with edX studio.
     * @type {string}
     * @memberof CourseRunV2
     */
    'start_date'?: string | null;
    /**
     * The last day the course is active. This value is synced automatically with edX studio.
     * @type {string}
     * @memberof CourseRunV2
     */
    'end_date'?: string | null;
    /**
     * The first day students can enroll. This value is synced automatically with edX studio.
     * @type {string}
     * @memberof CourseRunV2
     */
    'enrollment_start'?: string | null;
    /**
     * The last day students can enroll. This value is synced automatically with edX studio.
     * @type {string}
     * @memberof CourseRunV2
     */
    'enrollment_end'?: string | null;
    /**
     * The date beyond which the learner should not see link to this course run on their dashboard.
     * @type {string}
     * @memberof CourseRunV2
     */
    'expiration_date'?: string | null;
    /**
     * Get the courseware URL
     * @type {string}
     * @memberof CourseRunV2
     */
    'courseware_url': string | null;
    /**
     * 
     * @type {string}
     * @memberof CourseRunV2
     */
    'courseware_id': string;
    /**
     * The day certificates should be available to users. This value is synced automatically with edX studio.
     * @type {string}
     * @memberof CourseRunV2
     */
    'certificate_available_date'?: string | null;
    /**
     * The date beyond which the learner can not enroll in paid course mode.
     * @type {string}
     * @memberof CourseRunV2
     */
    'upgrade_deadline'?: string | null;
    /**
     * Check if the course run is upgradable
     * @type {boolean}
     * @memberof CourseRunV2
     */
    'is_upgradable': boolean;
    /**
     * Check if the course run is enrollable
     * @type {boolean}
     * @memberof CourseRunV2
     */
    'is_enrollable': boolean;
    /**
     * Check if the course run is archived
     * @type {boolean}
     * @memberof CourseRunV2
     */
    'is_archived': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CourseRunV2
     */
    'is_self_paced'?: boolean;
    /**
     * A string that identifies the set of runs that this run belongs to (example: \'R2\')
     * @type {string}
     * @memberof CourseRunV2
     */
    'run_tag': string;
    /**
     * 
     * @type {number}
     * @memberof CourseRunV2
     */
    'id': number;
    /**
     * 
     * @type {boolean}
     * @memberof CourseRunV2
     */
    'live'?: boolean;
    /**
     * Get the course number
     * @type {string}
     * @memberof CourseRunV2
     */
    'course_number': string;
    /**
     * 
     * @type {Array<ProductFlexibilePrice>}
     * @memberof CourseRunV2
     */
    'products': Array<ProductFlexibilePrice>;
    /**
     * 
     * @type {boolean}
     * @memberof CourseRunV2
     */
    'approved_flexible_price_exists': boolean;
    /**
     * 
     * @type {number}
     * @memberof CourseRunV2
     */
    'b2b_contract'?: number | null;
}
/**
 * Course model serializer - also serializes child course runs
 * @export
 * @interface CourseWithCourseRunsSerializerV2
 */
export interface CourseWithCourseRunsSerializerV2 {
    /**
     * 
     * @type {number}
     * @memberof CourseWithCourseRunsSerializerV2
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof CourseWithCourseRunsSerializerV2
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof CourseWithCourseRunsSerializerV2
     */
    'readable_id': string;
    /**
     * Get next run id
     * @type {number}
     * @memberof CourseWithCourseRunsSerializerV2
     */
    'next_run_id': number | null;
    /**
     * 
     * @type {Array<Department>}
     * @memberof CourseWithCourseRunsSerializerV2
     */
    'departments': Array<Department>;
    /**
     * 
     * @type {CoursePage}
     * @memberof CourseWithCourseRunsSerializerV2
     */
    'page': CoursePage;
    /**
     * 
     * @type {Array<BaseProgram>}
     * @memberof CourseWithCourseRunsSerializerV2
     */
    'programs': Array<BaseProgram> | null;
    /**
     * List topics of a course
     * @type {Array<{ [key: string]: any; }>}
     * @memberof CourseWithCourseRunsSerializerV2
     */
    'topics': Array<{ [key: string]: any; }>;
    /**
     * 
     * @type {string}
     * @memberof CourseWithCourseRunsSerializerV2
     */
    'certificate_type': string;
    /**
     * Check if the prerequisites field is populated in the course page CMS. Returns:     bool: True when the prerequisites field is populated in the course page CMS.  False otherwise.
     * @type {boolean}
     * @memberof CourseWithCourseRunsSerializerV2
     */
    'required_prerequisites': boolean;
    /**
     * Get the duration of the course from the course page CMS.
     * @type {string}
     * @memberof CourseWithCourseRunsSerializerV2
     */
    'duration': string;
    /**
     * Get the min weeks of the course from the CMS page.
     * @type {number}
     * @memberof CourseWithCourseRunsSerializerV2
     */
    'min_weeks': number | null;
    /**
     * Get the max weeks of the course from the CMS page.
     * @type {number}
     * @memberof CourseWithCourseRunsSerializerV2
     */
    'max_weeks': number | null;
    /**
     * Get the min price of the product from the CMS page.
     * @type {number}
     * @memberof CourseWithCourseRunsSerializerV2
     */
    'min_price': number | null;
    /**
     * Get the max price of the product from the CMS page.
     * @type {number}
     * @memberof CourseWithCourseRunsSerializerV2
     */
    'max_price': number | null;
    /**
     * Get the time commitment of the course from the course page CMS.
     * @type {string}
     * @memberof CourseWithCourseRunsSerializerV2
     */
    'time_commitment': string | null;
    /**
     * Get course availability
     * @type {string}
     * @memberof CourseWithCourseRunsSerializerV2
     */
    'availability': string;
    /**
     * Get the min weekly hours of the course from the course page CMS.
     * @type {string}
     * @memberof CourseWithCourseRunsSerializerV2
     */
    'min_weekly_hours': string | null;
    /**
     * Get the max weekly hours of the course from the course page CMS.
     * @type {string}
     * @memberof CourseWithCourseRunsSerializerV2
     */
    'max_weekly_hours': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof CourseWithCourseRunsSerializerV2
     */
    'include_in_learn_catalog': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CourseWithCourseRunsSerializerV2
     */
    'ingest_content_files_for_ai': boolean;
    /**
     * 
     * @type {Array<CourseRunV2>}
     * @memberof CourseWithCourseRunsSerializerV2
     */
    'courseruns': Array<CourseRunV2>;
}
/**
 * Serializer for the result from create_b2b_enrollment.  There\'s always a result, and it should be one of the B2B messages that are defined in main.constants. The other fields appear or not depending on the result type.
 * @export
 * @interface CreateB2BEnrollment
 */
export interface CreateB2BEnrollment {
    /**
     * 
     * @type {ResultEnum}
     * @memberof CreateB2BEnrollment
     */
    'result': ResultEnum;
    /**
     * 
     * @type {number}
     * @memberof CreateB2BEnrollment
     */
    'order': number;
    /**
     * 
     * @type {string}
     * @memberof CreateB2BEnrollment
     */
    'price': string;
    /**
     * 
     * @type {GenerateCheckoutPayload}
     * @memberof CreateB2BEnrollment
     */
    'checkout_result'?: GenerateCheckoutPayload;
}


/**
 * Defines the schema for a product ID and quantity in the CreateBasketWithProductsSerializer.
 * @export
 * @interface CreateBasketWithProductIDRequest
 */
export interface CreateBasketWithProductIDRequest {
    /**
     * 
     * @type {number}
     * @memberof CreateBasketWithProductIDRequest
     */
    'product_id': number;
    /**
     * 
     * @type {number}
     * @memberof CreateBasketWithProductIDRequest
     */
    'quantity': number;
}
/**
 * Serializer for creating a basket with products. (For OpenAPI spec.)
 * @export
 * @interface CreateBasketWithProductsRequest
 */
export interface CreateBasketWithProductsRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateBasketWithProductsRequest
     */
    'system_slug': string;
    /**
     * 
     * @type {Array<CreateBasketWithProductIDRequest>}
     * @memberof CreateBasketWithProductsRequest
     */
    'product_ids': Array<CreateBasketWithProductIDRequest>;
    /**
     * 
     * @type {boolean}
     * @memberof CreateBasketWithProductsRequest
     */
    'checkout': boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateBasketWithProductsRequest
     */
    'discount_code': string;
}
/**
 * Department model serializer
 * @export
 * @interface Department
 */
export interface Department {
    /**
     * 
     * @type {string}
     * @memberof Department
     */
    'name': string;
}
/**
 * Department model serializer
 * @export
 * @interface DepartmentRequest
 */
export interface DepartmentRequest {
    /**
     * 
     * @type {string}
     * @memberof DepartmentRequest
     */
    'name': string;
}
/**
 * CourseRun model serializer that includes the number of courses and programs associated with each departments
 * @export
 * @interface DepartmentWithCount
 */
export interface DepartmentWithCount {
    /**
     * 
     * @type {string}
     * @memberof DepartmentWithCount
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof DepartmentWithCount
     */
    'courses': number;
    /**
     * 
     * @type {number}
     * @memberof DepartmentWithCount
     */
    'programs': number;
}
/**
 * Department model serializer that includes the number of courses and programs associated with each
 * @export
 * @interface DepartmentWithCoursesAndPrograms
 */
export interface DepartmentWithCoursesAndPrograms {
    /**
     * 
     * @type {number}
     * @memberof DepartmentWithCoursesAndPrograms
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof DepartmentWithCoursesAndPrograms
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof DepartmentWithCoursesAndPrograms
     */
    'slug': string;
    /**
     * 
     * @type {Array<number>}
     * @memberof DepartmentWithCoursesAndPrograms
     */
    'course_ids': Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof DepartmentWithCoursesAndPrograms
     */
    'program_ids': Array<number>;
}
/**
 * 
 * @export
 * @interface Discount
 */
export interface Discount {
    /**
     * 
     * @type {number}
     * @memberof Discount
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Discount
     */
    'amount': string;
    /**
     * 
     * @type {boolean}
     * @memberof Discount
     */
    'automatic'?: boolean;
    /**
     * 
     * @type {DiscountTypeEnum}
     * @memberof Discount
     */
    'discount_type': DiscountTypeEnum;
    /**
     * 
     * @type {RedemptionTypeEnum}
     * @memberof Discount
     */
    'redemption_type': RedemptionTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof Discount
     */
    'max_redemptions'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof Discount
     */
    'discount_code': string;
    /**
     * 
     * @type {PaymentTypeEnum}
     * @memberof Discount
     */
    'payment_type'?: PaymentTypeEnum | null;
    /**
     * Returns True if the discount has been redeemed
     * @type {boolean}
     * @memberof Discount
     */
    'is_redeemed': boolean;
    /**
     * If set, this discount code will not be redeemable before this date.
     * @type {string}
     * @memberof Discount
     */
    'activation_date'?: string | null;
    /**
     * If set, this discount code will not be redeemable after this date.
     * @type {string}
     * @memberof Discount
     */
    'expiration_date'?: string | null;
}


/**
 * 
 * @export
 * @interface DiscountProduct
 */
export interface DiscountProduct {
    /**
     * 
     * @type {number}
     * @memberof DiscountProduct
     */
    'id': number;
    /**
     * 
     * @type {V0Discount}
     * @memberof DiscountProduct
     */
    'discount': V0Discount;
    /**
     * 
     * @type {Product}
     * @memberof DiscountProduct
     */
    'product': Product;
}
/**
 * 
 * @export
 * @interface DiscountProductRequest
 */
export interface DiscountProductRequest {
    /**
     * 
     * @type {V0DiscountRequest}
     * @memberof DiscountProductRequest
     */
    'discount': V0DiscountRequest;
    /**
     * 
     * @type {ProductRequest}
     * @memberof DiscountProductRequest
     */
    'product': ProductRequest;
}
/**
 * Serializes a discount redemption.
 * @export
 * @interface DiscountRedemption
 */
export interface DiscountRedemption {
    /**
     * 
     * @type {number}
     * @memberof DiscountRedemption
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof DiscountRedemption
     */
    'redemption_date': string;
    /**
     * 
     * @type {User}
     * @memberof DiscountRedemption
     */
    'redeemed_by': User;
    /**
     * 
     * @type {V0Discount}
     * @memberof DiscountRedemption
     */
    'redeemed_discount': V0Discount;
    /**
     * 
     * @type {Order}
     * @memberof DiscountRedemption
     */
    'redeemed_order': Order;
}
/**
 * Serializes a discount redemption.
 * @export
 * @interface DiscountRedemptionRequest
 */
export interface DiscountRedemptionRequest {
    /**
     * 
     * @type {UserRequest}
     * @memberof DiscountRedemptionRequest
     */
    'redeemed_by': UserRequest;
    /**
     * 
     * @type {V0DiscountRequest}
     * @memberof DiscountRedemptionRequest
     */
    'redeemed_discount': V0DiscountRequest;
    /**
     * 
     * @type {OrderRequest}
     * @memberof DiscountRedemptionRequest
     */
    'redeemed_order': OrderRequest;
}
/**
 * * `percent-off` - percent-off * `dollars-off` - dollars-off * `fixed-price` - fixed-price
 * @export
 * @enum {string}
 */

export const DiscountTypeEnum = {
    /**
    * percent-off
    */
    PercentOff: 'percent-off',
    /**
    * dollars-off
    */
    DollarsOff: 'dollars-off',
    /**
    * fixed-price
    */
    FixedPrice: 'fixed-price'
} as const;

export type DiscountTypeEnum = typeof DiscountTypeEnum[keyof typeof DiscountTypeEnum];


/**
 * * `audit` - audit * `verified` - verified
 * @export
 * @enum {string}
 */

export const EnrollmentModeEnum = {
    /**
    * audit
    */
    Audit: 'audit',
    /**
    * verified
    */
    Verified: 'verified'
} as const;

export type EnrollmentModeEnum = typeof EnrollmentModeEnum[keyof typeof EnrollmentModeEnum];


/**
 * * `enroll-blocked` - enroll-blocked * `enroll-duplicated` - enroll-duplicated * `course-non-upgradable` - course-non-upgradable * `discount-invalid` - discount-invalid * `b2b-error-missing-enrollment-code` - b2b-error-missing-enrollment-code * `b2b-invalid-basket` - b2b-invalid-basket * `basket-empty` - basket-empty
 * @export
 * @enum {string}
 */

export const ErrorEnum = {
    /**
    * enroll-blocked
    */
    EnrollBlocked: 'enroll-blocked',
    /**
    * enroll-duplicated
    */
    EnrollDuplicated: 'enroll-duplicated',
    /**
    * course-non-upgradable
    */
    CourseNonUpgradable: 'course-non-upgradable',
    /**
    * discount-invalid
    */
    DiscountInvalid: 'discount-invalid',
    /**
    * b2b-error-missing-enrollment-code
    */
    B2bErrorMissingEnrollmentCode: 'b2b-error-missing-enrollment-code',
    /**
    * b2b-invalid-basket
    */
    B2bInvalidBasket: 'b2b-invalid-basket',
    /**
    * basket-empty
    */
    BasketEmpty: 'basket-empty'
} as const;

export type ErrorEnum = typeof ErrorEnum[keyof typeof ErrorEnum];


/**
 * Serializer class that includes email address as part of the legal address
 * @export
 * @interface ExtendedLegalAddress
 */
export interface ExtendedLegalAddress {
    /**
     * 
     * @type {string}
     * @memberof ExtendedLegalAddress
     */
    'country': string;
    /**
     * 
     * @type {string}
     * @memberof ExtendedLegalAddress
     */
    'state'?: string | null;
    /**
     * Get email from the linked user object
     * @type {string}
     * @memberof ExtendedLegalAddress
     */
    'email': string;
}
/**
 * Serializer for faculty details used in course pages.
 * @export
 * @interface Faculty
 */
export interface Faculty {
    /**
     * 
     * @type {number}
     * @memberof Faculty
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Faculty
     */
    'instructor_name': string;
    /**
     * 
     * @type {string}
     * @memberof Faculty
     */
    'instructor_title': string;
    /**
     * 
     * @type {string}
     * @memberof Faculty
     */
    'instructor_bio_short': string;
    /**
     * 
     * @type {string}
     * @memberof Faculty
     */
    'instructor_bio_long': string;
    /**
     * 
     * @type {string}
     * @memberof Faculty
     */
    'feature_image_src': string;
}
/**
 * Serializer for feature images used in course pages.
 * @export
 * @interface FeatureImage
 */
export interface FeatureImage {
    /**
     * 
     * @type {string}
     * @memberof FeatureImage
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof FeatureImage
     */
    'image_url': string;
    /**
     * 
     * @type {number}
     * @memberof FeatureImage
     */
    'height': number;
    /**
     * 
     * @type {number}
     * @memberof FeatureImage
     */
    'width': number;
}
/**
 * 
 * @export
 * @interface FlexiblePriceTier
 */
export interface FlexiblePriceTier {
    /**
     * 
     * @type {number}
     * @memberof FlexiblePriceTier
     */
    'id': number;
    /**
     * 
     * @type {BaseCourse}
     * @memberof FlexiblePriceTier
     */
    'courseware_object': BaseCourse;
    /**
     * 
     * @type {number}
     * @memberof FlexiblePriceTier
     */
    'discount': number;
    /**
     * 
     * @type {boolean}
     * @memberof FlexiblePriceTier
     */
    'current'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof FlexiblePriceTier
     */
    'income_threshold_usd': number;
}
/**
 * 
 * @export
 * @interface FlexiblePriceTierRequest
 */
export interface FlexiblePriceTierRequest {
    /**
     * 
     * @type {number}
     * @memberof FlexiblePriceTierRequest
     */
    'discount': number;
    /**
     * 
     * @type {boolean}
     * @memberof FlexiblePriceTierRequest
     */
    'current'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof FlexiblePriceTierRequest
     */
    'income_threshold_usd': number;
}
/**
 * * `m` - Male * `f` - Female * `t` - Transgender * `nb` - Non-binary/non-conforming * `o` - Other/Prefer Not to Say
 * @export
 * @enum {string}
 */

export const GenderEnum = {
    /**
    * Male
    */
    M: 'm',
    /**
    * Female
    */
    F: 'f',
    /**
    * Transgender
    */
    T: 't',
    /**
    * Non-binary/non-conforming
    */
    Nb: 'nb',
    /**
    * Other/Prefer Not to Say
    */
    O: 'o'
} as const;

export type GenderEnum = typeof GenderEnum[keyof typeof GenderEnum];


/**
 * Serializer for the result from ecommerce.api.generate_checkout_payload.  The B2B enrollment API will return the result of the checkout call if the user needs to pay for the cart because of an error creating the checkout payload. In that case, we really just need the error states; it will also include a HttpResponseRedirect that we don\'t really care about for the API\'s purposes.
 * @export
 * @interface GenerateCheckoutPayload
 */
export interface GenerateCheckoutPayload {
    /**
     * 
     * @type {boolean}
     * @memberof GenerateCheckoutPayload
     */
    'country_blocked'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof GenerateCheckoutPayload
     */
    'purchased_same_courserun'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof GenerateCheckoutPayload
     */
    'purchased_non_upgradeable_courserun'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof GenerateCheckoutPayload
     */
    'invalid_discounts'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof GenerateCheckoutPayload
     */
    'no_checkout'?: boolean | null;
}
/**
 * * `None` - ---- * `Doctorate` - Doctorate * `Master\'s or professional degree` - Master\'s or professional degree * `Bachelor\'s degree` - Bachelor\'s degree * `Associate degree` - Associate degree * `Secondary/high school` - Secondary/high school * `Junior secondary/junior high/middle school` - Junior secondary/junior high/middle school * `Elementary/primary school` - Elementary/primary school * `No formal education` - No formal education * `Other education` - Other education
 * @export
 * @enum {string}
 */

export const HighestEducationEnum = {
    /**
    * Doctorate
    */
    Doctorate: 'Doctorate',
    /**
    * Master&#39;s or professional degree
    */
    MastersOrProfessionalDegree: 'Master\'s or professional degree',
    /**
    * Bachelor&#39;s degree
    */
    BachelorsDegree: 'Bachelor\'s degree',
    /**
    * Associate degree
    */
    AssociateDegree: 'Associate degree',
    /**
    * Secondary/high school
    */
    SecondaryHighSchool: 'Secondary/high school',
    /**
    * Junior secondary/junior high/middle school
    */
    JuniorSecondaryJuniorHighMiddleSchool: 'Junior secondary/junior high/middle school',
    /**
    * Elementary/primary school
    */
    ElementaryPrimarySchool: 'Elementary/primary school',
    /**
    * No formal education
    */
    NoFormalEducation: 'No formal education',
    /**
    * Other education
    */
    OtherEducation: 'Other education'
} as const;

export type HighestEducationEnum = typeof HighestEducationEnum[keyof typeof HighestEducationEnum];


/**
 * * `sso` - SSO * `non-sso` - Non-SSO * `managed` - Managed * `code` - Enrollment Code * `auto` - Auto Enrollment
 * @export
 * @enum {string}
 */

export const IntegrationTypeEnum = {
    /**
    * SSO
    */
    Sso: 'sso',
    /**
    * Non-SSO
    */
    NonSso: 'non-sso',
    /**
    * Managed
    */
    Managed: 'managed',
    /**
    * Enrollment Code
    */
    Code: 'code',
    /**
    * Auto Enrollment
    */
    Auto: 'auto'
} as const;

export type IntegrationTypeEnum = typeof IntegrationTypeEnum[keyof typeof IntegrationTypeEnum];


/**
 * 
 * @export
 * @interface LearnerProgramRecordShare
 */
export interface LearnerProgramRecordShare {
    /**
     * 
     * @type {string}
     * @memberof LearnerProgramRecordShare
     */
    'share_uuid': string;
    /**
     * 
     * @type {string}
     * @memberof LearnerProgramRecordShare
     */
    'created_on': string;
    /**
     * 
     * @type {string}
     * @memberof LearnerProgramRecordShare
     */
    'updated_on': string;
    /**
     * 
     * @type {boolean}
     * @memberof LearnerProgramRecordShare
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof LearnerProgramRecordShare
     */
    'user': number;
    /**
     * 
     * @type {number}
     * @memberof LearnerProgramRecordShare
     */
    'program': number;
    /**
     * 
     * @type {number}
     * @memberof LearnerProgramRecordShare
     */
    'partner_school'?: number | null;
}
/**
 * Gathers the various data needed to display the learner\'s program record. Pass the program you want the record for and attach the learner via context object.
 * @export
 * @interface LearnerRecord
 */
export interface LearnerRecord {
    /**
     * User information including name, email, and username
     * @type {{ [key: string]: string; }}
     * @memberof LearnerRecord
     */
    'user': { [key: string]: string; };
    /**
     * Program details including title, readable_id, courses, and requirements
     * @type {{ [key: string]: { [key: string]: any; }; }}
     * @memberof LearnerRecord
     */
    'program': { [key: string]: { [key: string]: any; }; };
    /**
     * Active program record shares for this user
     * @type {Array<LearnerProgramRecordShare>}
     * @memberof LearnerRecord
     */
    'sharing': Array<LearnerProgramRecordShare>;
    /**
     * List of partner schools
     * @type {Array<PartnerSchool>}
     * @memberof LearnerRecord
     */
    'partner_schools': Array<PartnerSchool>;
}
/**
 * Serializer for legal address
 * @export
 * @interface LegalAddress
 */
export interface LegalAddress {
    /**
     * 
     * @type {string}
     * @memberof LegalAddress
     */
    'country': string;
    /**
     * 
     * @type {string}
     * @memberof LegalAddress
     */
    'state'?: string | null;
}
/**
 * Serializer for legal address
 * @export
 * @interface LegalAddressRequest
 */
export interface LegalAddressRequest {
    /**
     * 
     * @type {string}
     * @memberof LegalAddressRequest
     */
    'country': string;
    /**
     * 
     * @type {string}
     * @memberof LegalAddressRequest
     */
    'state'?: string | null;
}
/**
 * Serializes order lines.
 * @export
 * @interface Line
 */
export interface Line {
    /**
     * 
     * @type {number}
     * @memberof Line
     */
    'quantity': number;
    /**
     * 
     * @type {string}
     * @memberof Line
     */
    'item_description': string;
    /**
     * 
     * @type {string}
     * @memberof Line
     */
    'unit_price': string;
    /**
     * 
     * @type {string}
     * @memberof Line
     */
    'total_price': string;
    /**
     * 
     * @type {number}
     * @memberof Line
     */
    'id': number;
    /**
     * 
     * @type {Product}
     * @memberof Line
     */
    'product': Product;
}
/**
 * 
 * @export
 * @interface Nested
 */
export interface Nested {
    /**
     * 
     * @type {number}
     * @memberof Nested
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Nested
     */
    'created_on': string;
    /**
     * 
     * @type {string}
     * @memberof Nested
     */
    'updated_on': string;
    /**
     * 
     * @type {string}
     * @memberof Nested
     */
    'amount': string;
    /**
     * 
     * @type {boolean}
     * @memberof Nested
     */
    'automatic'?: boolean;
    /**
     * 
     * @type {DiscountTypeEnum}
     * @memberof Nested
     */
    'discount_type': DiscountTypeEnum;
    /**
     * 
     * @type {RedemptionTypeEnum}
     * @memberof Nested
     */
    'redemption_type': RedemptionTypeEnum;
    /**
     * 
     * @type {PaymentTypeEnum}
     * @memberof Nested
     */
    'payment_type'?: PaymentTypeEnum | null;
    /**
     * 
     * @type {number}
     * @memberof Nested
     */
    'max_redemptions'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof Nested
     */
    'discount_code': string;
    /**
     * If set, this discount code will not be redeemable before this date.
     * @type {string}
     * @memberof Nested
     */
    'activation_date'?: string | null;
    /**
     * If set, this discount code will not be redeemable after this date.
     * @type {string}
     * @memberof Nested
     */
    'expiration_date'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Nested
     */
    'is_bulk'?: boolean;
    /**
     * Discount is only for creating verified course run enrollments for a program.
     * @type {boolean}
     * @memberof Nested
     */
    'is_program_discount'?: boolean | null;
}


/**
 * * `operator` - operator * `course` - course * `program` - program
 * @export
 * @enum {string}
 */

export const NodeTypeEnum = {
    /**
    * operator
    */
    Operator: 'operator',
    /**
    * course
    */
    Course: 'course',
    /**
    * program
    */
    Program: 'program'
} as const;

export type NodeTypeEnum = typeof NodeTypeEnum[keyof typeof NodeTypeEnum];


/**
 * 
 * @export
 * @enum {string}
 */

export const NullEnum = {
    Null: 'null'
} as const;

export type NullEnum = typeof NullEnum[keyof typeof NullEnum];


/**
 * 
 * @export
 * @interface Order
 */
export interface Order {
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    'id': number;
    /**
     * 
     * @type {StateEnum}
     * @memberof Order
     */
    'state': StateEnum;
    /**
     * 
     * @type {Array<ExtendedLegalAddress>}
     * @memberof Order
     */
    'purchaser': Array<ExtendedLegalAddress>;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'total_price_paid': string;
    /**
     * 
     * @type {Array<TransactionLine>}
     * @memberof Order
     */
    'lines': Array<TransactionLine>;
    /**
     * 
     * @type {Array<RedeemedDiscount>}
     * @memberof Order
     */
    'discounts': Array<RedeemedDiscount>;
    /**
     * 
     * @type {Array<OrderRefundsInner>}
     * @memberof Order
     */
    'refunds': Array<OrderRefundsInner>;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'reference_number'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'created_on': string;
    /**
     * 
     * @type {OrderTransactions}
     * @memberof Order
     */
    'transactions': OrderTransactions;
    /**
     * 
     * @type {OrderStreetAddress}
     * @memberof Order
     */
    'street_address': OrderStreetAddress;
}


/**
 * 
 * @export
 * @interface OrderHistory
 */
export interface OrderHistory {
    /**
     * 
     * @type {number}
     * @memberof OrderHistory
     */
    'id': number;
    /**
     * 
     * @type {StateEnum}
     * @memberof OrderHistory
     */
    'state': StateEnum;
    /**
     * 
     * @type {string}
     * @memberof OrderHistory
     */
    'reference_number'?: string | null;
    /**
     * 
     * @type {PublicUser}
     * @memberof OrderHistory
     */
    'purchaser': PublicUser;
    /**
     * 
     * @type {string}
     * @memberof OrderHistory
     */
    'total_price_paid': string;
    /**
     * 
     * @type {Array<Line>}
     * @memberof OrderHistory
     */
    'lines': Array<Line>;
    /**
     * 
     * @type {string}
     * @memberof OrderHistory
     */
    'created_on': string;
    /**
     * 
     * @type {Array<any>}
     * @memberof OrderHistory
     */
    'titles': Array<any>;
    /**
     * 
     * @type {string}
     * @memberof OrderHistory
     */
    'updated_on': string;
}


/**
 * 
 * @export
 * @interface OrderRefundsInner
 */
export interface OrderRefundsInner {
    /**
     * 
     * @type {number}
     * @memberof OrderRefundsInner
     */
    'amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof OrderRefundsInner
     */
    'date'?: string;
}
/**
 * 
 * @export
 * @interface OrderRequest
 */
export interface OrderRequest {
    /**
     * 
     * @type {StateEnum}
     * @memberof OrderRequest
     */
    'state': StateEnum;
    /**
     * 
     * @type {string}
     * @memberof OrderRequest
     */
    'total_price_paid': string;
    /**
     * 
     * @type {string}
     * @memberof OrderRequest
     */
    'reference_number'?: string | null;
}


/**
 * 
 * @export
 * @interface OrderStreetAddress
 */
export interface OrderStreetAddress {
    /**
     * 
     * @type {Array<string>}
     * @memberof OrderStreetAddress
     */
    'line'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof OrderStreetAddress
     */
    'postal_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderStreetAddress
     */
    'state'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderStreetAddress
     */
    'city'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderStreetAddress
     */
    'country'?: string;
}
/**
 * 
 * @export
 * @interface OrderTransactions
 */
export interface OrderTransactions {
    /**
     * 
     * @type {string}
     * @memberof OrderTransactions
     */
    'card_number'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderTransactions
     */
    'card_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderTransactions
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderTransactions
     */
    'bill_to_email'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderTransactions
     */
    'payment_method'?: string;
}
/**
 * Serializer for the OrganizationPage model.
 * @export
 * @interface OrganizationPage
 */
export interface OrganizationPage {
    /**
     * 
     * @type {number}
     * @memberof OrganizationPage
     */
    'id': number;
    /**
     * The name of the organization
     * @type {string}
     * @memberof OrganizationPage
     */
    'name': string;
    /**
     * Any useful extra information about the organization
     * @type {string}
     * @memberof OrganizationPage
     */
    'description': string;
    /**
     * The organization\'s logo. Will be displayed in the app in various places.
     * @type {string}
     * @memberof OrganizationPage
     */
    'logo': string;
    /**
     * The name of the page as it will appear in URLs e.g http://domain.com/blog/[my-slug]/
     * @type {string}
     * @memberof OrganizationPage
     */
    'slug': string;
    /**
     * 
     * @type {Array<ContractPage>}
     * @memberof OrganizationPage
     */
    'contracts': Array<ContractPage>;
}
/**
 * Serializer for overrides used in certificate pages.
 * @export
 * @interface Override
 */
export interface Override {
    /**
     * 
     * @type {string}
     * @memberof Override
     */
    'type': string;
    /**
     * 
     * @type {OverrideValue}
     * @memberof Override
     */
    'value': OverrideValue;
    /**
     * 
     * @type {string}
     * @memberof Override
     */
    'id': string;
}
/**
 * Serializer for override values used in certificate pages.
 * @export
 * @interface OverrideValue
 */
export interface OverrideValue {
    /**
     * 
     * @type {string}
     * @memberof OverrideValue
     */
    'readable_id': string;
    /**
     * 
     * @type {string}
     * @memberof OverrideValue
     */
    'CEUs': string;
}
/**
 * Serializer for individual Wagtail pages.
 * @export
 * @interface Page
 */
export interface Page {
    /**
     * 
     * @type {number}
     * @memberof Page
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Page
     */
    'title': string;
    /**
     * 
     * @type {PageMeta}
     * @memberof Page
     */
    'meta': PageMeta;
}
/**
 * Serializer for a list of Wagtail pages.
 * @export
 * @interface PageList
 */
export interface PageList {
    /**
     * 
     * @type {PageListMeta}
     * @memberof PageList
     */
    'meta': PageListMeta;
    /**
     * 
     * @type {Array<Page>}
     * @memberof PageList
     */
    'items': Array<Page>;
}
/**
 * Serializer for metadata of a list of Wagtail pages.
 * @export
 * @interface PageListMeta
 */
export interface PageListMeta {
    /**
     * 
     * @type {number}
     * @memberof PageListMeta
     */
    'total_count': number;
}
/**
 * Serializer for page metadata used in various Wagtail pages.
 * @export
 * @interface PageMeta
 */
export interface PageMeta {
    /**
     * 
     * @type {string}
     * @memberof PageMeta
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof PageMeta
     */
    'detail_url': string;
    /**
     * 
     * @type {string}
     * @memberof PageMeta
     */
    'html_url': string;
    /**
     * 
     * @type {string}
     * @memberof PageMeta
     */
    'slug': string;
    /**
     * 
     * @type {boolean}
     * @memberof PageMeta
     */
    'show_in_menus': boolean;
    /**
     * 
     * @type {string}
     * @memberof PageMeta
     */
    'seo_title': string;
    /**
     * 
     * @type {string}
     * @memberof PageMeta
     */
    'search_description': string;
    /**
     * 
     * @type {string}
     * @memberof PageMeta
     */
    'first_published_at': string | null;
    /**
     * 
     * @type {string}
     * @memberof PageMeta
     */
    'alias_of': string | null;
    /**
     * 
     * @type {string}
     * @memberof PageMeta
     */
    'locale': string;
    /**
     * 
     * @type {boolean}
     * @memberof PageMeta
     */
    'live': boolean;
    /**
     * 
     * @type {string}
     * @memberof PageMeta
     */
    'last_published_at': string | null;
}
/**
 * Extends the PageMetaSerializer to work with a Page object
 * @export
 * @interface PageMetaModel
 */
export interface PageMetaModel {
    /**
     * Get the page type, in a more simple manner than Wagtail.  The Wagtail version of this is PageTypeField, and it tries to modify the context, which we neither need nor is in the correct format for it.
     * @type {string}
     * @memberof PageMetaModel
     */
    'type': string;
    /**
     * Get the detail URL, which should be the API call for this page.  The Wagtail version of this is DetailUrlField and it also tries to make changes to the context that we don\'t need.
     * @type {string}
     * @memberof PageMetaModel
     */
    'detail_url': string;
    /**
     * Return PageHtmlUrlField. This is wrapped for OpenAPI schema generation.
     * @type {string}
     * @memberof PageMetaModel
     */
    'html_url': string;
    /**
     * 
     * @type {string}
     * @memberof PageMetaModel
     */
    'slug': string;
    /**
     * 
     * @type {boolean}
     * @memberof PageMetaModel
     */
    'show_in_menus': boolean;
    /**
     * 
     * @type {string}
     * @memberof PageMetaModel
     */
    'seo_title': string;
    /**
     * 
     * @type {string}
     * @memberof PageMetaModel
     */
    'search_description': string;
    /**
     * 
     * @type {string}
     * @memberof PageMetaModel
     */
    'first_published_at': string | null;
    /**
     * 
     * @type {string}
     * @memberof PageMetaModel
     */
    'alias_of': string | null;
    /**
     * Return PageLocaleField. This is wrapped for OpenAPI schema generation.
     * @type {string}
     * @memberof PageMetaModel
     */
    'locale': string;
    /**
     * 
     * @type {boolean}
     * @memberof PageMetaModel
     */
    'live': boolean;
    /**
     * 
     * @type {string}
     * @memberof PageMetaModel
     */
    'last_published_at': string | null;
}
/**
 * @type PagesRetrieve200Response
 * @export
 */
export type PagesRetrieve200Response = CertificatePage | CoursePageItem | Page | ProgramPageItem;

/**
 * 
 * @export
 * @interface PaginatedCourseWithCourseRunsSerializerV2List
 */
export interface PaginatedCourseWithCourseRunsSerializerV2List {
    /**
     * 
     * @type {number}
     * @memberof PaginatedCourseWithCourseRunsSerializerV2List
     */
    'count': number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedCourseWithCourseRunsSerializerV2List
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedCourseWithCourseRunsSerializerV2List
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<CourseWithCourseRunsSerializerV2>}
     * @memberof PaginatedCourseWithCourseRunsSerializerV2List
     */
    'results': Array<CourseWithCourseRunsSerializerV2>;
}
/**
 * 
 * @export
 * @interface PaginatedDiscountProductList
 */
export interface PaginatedDiscountProductList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedDiscountProductList
     */
    'count': number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedDiscountProductList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedDiscountProductList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<DiscountProduct>}
     * @memberof PaginatedDiscountProductList
     */
    'results': Array<DiscountProduct>;
}
/**
 * 
 * @export
 * @interface PaginatedDiscountRedemptionList
 */
export interface PaginatedDiscountRedemptionList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedDiscountRedemptionList
     */
    'count': number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedDiscountRedemptionList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedDiscountRedemptionList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<DiscountRedemption>}
     * @memberof PaginatedDiscountRedemptionList
     */
    'results': Array<DiscountRedemption>;
}
/**
 * 
 * @export
 * @interface PaginatedFlexiblePriceTierList
 */
export interface PaginatedFlexiblePriceTierList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedFlexiblePriceTierList
     */
    'count': number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedFlexiblePriceTierList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedFlexiblePriceTierList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<FlexiblePriceTier>}
     * @memberof PaginatedFlexiblePriceTierList
     */
    'results': Array<FlexiblePriceTier>;
}
/**
 * 
 * @export
 * @interface PaginatedOrderHistoryList
 */
export interface PaginatedOrderHistoryList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedOrderHistoryList
     */
    'count': number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedOrderHistoryList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedOrderHistoryList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<OrderHistory>}
     * @memberof PaginatedOrderHistoryList
     */
    'results': Array<OrderHistory>;
}
/**
 * 
 * @export
 * @interface PaginatedProductList
 */
export interface PaginatedProductList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedProductList
     */
    'count': number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedProductList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedProductList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Product>}
     * @memberof PaginatedProductList
     */
    'results': Array<Product>;
}
/**
 * 
 * @export
 * @interface PaginatedStaffDashboardUserList
 */
export interface PaginatedStaffDashboardUserList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedStaffDashboardUserList
     */
    'count': number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedStaffDashboardUserList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedStaffDashboardUserList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<StaffDashboardUser>}
     * @memberof PaginatedStaffDashboardUserList
     */
    'results': Array<StaffDashboardUser>;
}
/**
 * 
 * @export
 * @interface PaginatedUserDiscountMetaList
 */
export interface PaginatedUserDiscountMetaList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedUserDiscountMetaList
     */
    'count': number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedUserDiscountMetaList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedUserDiscountMetaList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<UserDiscountMeta>}
     * @memberof PaginatedUserDiscountMetaList
     */
    'results': Array<UserDiscountMeta>;
}
/**
 * 
 * @export
 * @interface PaginatedV0DiscountList
 */
export interface PaginatedV0DiscountList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedV0DiscountList
     */
    'count': number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedV0DiscountList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedV0DiscountList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<V0Discount>}
     * @memberof PaginatedV0DiscountList
     */
    'results': Array<V0Discount>;
}
/**
 * 
 * @export
 * @interface PaginatedV1CourseWithCourseRunsList
 */
export interface PaginatedV1CourseWithCourseRunsList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedV1CourseWithCourseRunsList
     */
    'count': number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedV1CourseWithCourseRunsList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedV1CourseWithCourseRunsList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<V1CourseWithCourseRuns>}
     * @memberof PaginatedV1CourseWithCourseRunsList
     */
    'results': Array<V1CourseWithCourseRuns>;
}
/**
 * 
 * @export
 * @interface PaginatedV1ProgramList
 */
export interface PaginatedV1ProgramList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedV1ProgramList
     */
    'count': number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedV1ProgramList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedV1ProgramList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<V1Program>}
     * @memberof PaginatedV1ProgramList
     */
    'results': Array<V1Program>;
}
/**
 * 
 * @export
 * @interface PaginatedV2ProgramCollectionList
 */
export interface PaginatedV2ProgramCollectionList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedV2ProgramCollectionList
     */
    'count': number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedV2ProgramCollectionList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedV2ProgramCollectionList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<V2ProgramCollection>}
     * @memberof PaginatedV2ProgramCollectionList
     */
    'results': Array<V2ProgramCollection>;
}
/**
 * 
 * @export
 * @interface PaginatedV2ProgramList
 */
export interface PaginatedV2ProgramList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedV2ProgramList
     */
    'count': number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedV2ProgramList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedV2ProgramList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<V2Program>}
     * @memberof PaginatedV2ProgramList
     */
    'results': Array<V2Program>;
}
/**
 * 
 * @export
 * @interface PartnerSchool
 */
export interface PartnerSchool {
    /**
     * 
     * @type {number}
     * @memberof PartnerSchool
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof PartnerSchool
     */
    'created_on': string;
    /**
     * 
     * @type {string}
     * @memberof PartnerSchool
     */
    'updated_on': string;
    /**
     * 
     * @type {string}
     * @memberof PartnerSchool
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PartnerSchool
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface PartnerSchoolRequest
 */
export interface PartnerSchoolRequest {
    /**
     * 
     * @type {string}
     * @memberof PartnerSchoolRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PartnerSchoolRequest
     */
    'email': string;
}
/**
 * Serializer for confirming a user email change
 * @export
 * @interface PatchedChangeEmailRequestUpdateRequest
 */
export interface PatchedChangeEmailRequestUpdateRequest {
    /**
     * 
     * @type {boolean}
     * @memberof PatchedChangeEmailRequestUpdateRequest
     */
    'confirmed'?: boolean;
}
/**
 * 
 * @export
 * @interface PatchedDiscountProductRequest
 */
export interface PatchedDiscountProductRequest {
    /**
     * 
     * @type {V0DiscountRequest}
     * @memberof PatchedDiscountProductRequest
     */
    'discount'?: V0DiscountRequest;
    /**
     * 
     * @type {ProductRequest}
     * @memberof PatchedDiscountProductRequest
     */
    'product'?: ProductRequest;
}
/**
 * Serializes a discount redemption.
 * @export
 * @interface PatchedDiscountRedemptionRequest
 */
export interface PatchedDiscountRedemptionRequest {
    /**
     * 
     * @type {UserRequest}
     * @memberof PatchedDiscountRedemptionRequest
     */
    'redeemed_by'?: UserRequest;
    /**
     * 
     * @type {V0DiscountRequest}
     * @memberof PatchedDiscountRedemptionRequest
     */
    'redeemed_discount'?: V0DiscountRequest;
    /**
     * 
     * @type {OrderRequest}
     * @memberof PatchedDiscountRedemptionRequest
     */
    'redeemed_order'?: OrderRequest;
}
/**
 * 
 * @export
 * @interface PatchedFlexiblePriceTierRequest
 */
export interface PatchedFlexiblePriceTierRequest {
    /**
     * 
     * @type {number}
     * @memberof PatchedFlexiblePriceTierRequest
     */
    'discount'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedFlexiblePriceTierRequest
     */
    'current'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PatchedFlexiblePriceTierRequest
     */
    'income_threshold_usd'?: number;
}
/**
 * Serializes a product, including the purchasable object.
 * @export
 * @interface PatchedProductRequest
 */
export interface PatchedProductRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedProductRequest
     */
    'price'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedProductRequest
     */
    'description'?: string;
    /**
     * Controls visibility of the product in the app.
     * @type {boolean}
     * @memberof PatchedProductRequest
     */
    'is_active'?: boolean;
}
/**
 * 
 * @export
 * @interface PatchedUpdateCourseRunEnrollmentRequest
 */
export interface PatchedUpdateCourseRunEnrollmentRequest {
    /**
     * Whether to receive course emails
     * @type {boolean}
     * @memberof PatchedUpdateCourseRunEnrollmentRequest
     */
    'receive_emails'?: boolean;
}
/**
 * Serializes UserDiscount but only allows depth = 1
 * @export
 * @interface PatchedUserDiscountMetaRequest
 */
export interface PatchedUserDiscountMetaRequest {
    /**
     * 
     * @type {V0DiscountRequest}
     * @memberof PatchedUserDiscountMetaRequest
     */
    'discount'?: V0DiscountRequest;
    /**
     * 
     * @type {UserRequest}
     * @memberof PatchedUserDiscountMetaRequest
     */
    'user'?: UserRequest;
}
/**
 * Serializer for users
 * @export
 * @interface PatchedUserRequest
 */
export interface PatchedUserRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedUserRequest
     */
    'username'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedUserRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedUserRequest
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedUserRequest
     */
    'password'?: string;
    /**
     * 
     * @type {LegalAddressRequest}
     * @memberof PatchedUserRequest
     */
    'legal_address'?: LegalAddressRequest | null;
    /**
     * 
     * @type {UserProfileRequest}
     * @memberof PatchedUserRequest
     */
    'user_profile'?: UserProfileRequest | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedUserRequest
     */
    'is_active'?: boolean;
}
/**
 * Serializes a discount.
 * @export
 * @interface PatchedV0DiscountRequest
 */
export interface PatchedV0DiscountRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedV0DiscountRequest
     */
    'amount'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedV0DiscountRequest
     */
    'automatic'?: boolean;
    /**
     * 
     * @type {DiscountTypeEnum}
     * @memberof PatchedV0DiscountRequest
     */
    'discount_type'?: DiscountTypeEnum;
    /**
     * 
     * @type {RedemptionTypeEnum}
     * @memberof PatchedV0DiscountRequest
     */
    'redemption_type'?: RedemptionTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof PatchedV0DiscountRequest
     */
    'max_redemptions'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedV0DiscountRequest
     */
    'discount_code'?: string;
    /**
     * 
     * @type {PaymentTypeEnum}
     * @memberof PatchedV0DiscountRequest
     */
    'payment_type'?: PaymentTypeEnum | null;
    /**
     * If set, this discount code will not be redeemable before this date.
     * @type {string}
     * @memberof PatchedV0DiscountRequest
     */
    'activation_date'?: string | null;
    /**
     * If set, this discount code will not be redeemable after this date.
     * @type {string}
     * @memberof PatchedV0DiscountRequest
     */
    'expiration_date'?: string | null;
}


/**
 * * `marketing` - marketing * `sales` - sales * `financial-assistance` - financial-assistance * `customer-support` - customer-support * `staff` - staff * `legacy` - legacy
 * @export
 * @enum {string}
 */

export const PaymentTypeEnum = {
    /**
    * marketing
    */
    Marketing: 'marketing',
    /**
    * sales
    */
    Sales: 'sales',
    /**
    * financial-assistance
    */
    FinancialAssistance: 'financial-assistance',
    /**
    * customer-support
    */
    CustomerSupport: 'customer-support',
    /**
    * staff
    */
    Staff: 'staff',
    /**
    * legacy
    */
    Legacy: 'legacy'
} as const;

export type PaymentTypeEnum = typeof PaymentTypeEnum[keyof typeof PaymentTypeEnum];


/**
 * Serializer for price items used in course pages.
 * @export
 * @interface PriceItem
 */
export interface PriceItem {
    /**
     * 
     * @type {string}
     * @memberof PriceItem
     */
    'type': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof PriceItem
     */
    'value': { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof PriceItem
     */
    'id': string;
}
/**
 * Serializes a product, including the purchasable object.
 * @export
 * @interface Product
 */
export interface Product {
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'price': string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'description': string;
    /**
     * Controls visibility of the product in the app.
     * @type {boolean}
     * @memberof Product
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {ProductPurchasableObject}
     * @memberof Product
     */
    'purchasable_object': ProductPurchasableObject;
}
/**
 * Simple serializer for Product without related purchasable objects
 * @export
 * @interface ProductFlexibilePrice
 */
export interface ProductFlexibilePrice {
    /**
     * 
     * @type {number}
     * @memberof ProductFlexibilePrice
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ProductFlexibilePrice
     */
    'price': string;
    /**
     * 
     * @type {string}
     * @memberof ProductFlexibilePrice
     */
    'description': string;
    /**
     * Controls visibility of the product in the app.
     * @type {boolean}
     * @memberof ProductFlexibilePrice
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {Discount}
     * @memberof ProductFlexibilePrice
     */
    'product_flexible_price': Discount | null;
}
/**
 * Simple serializer for Product without related purchasable objects
 * @export
 * @interface ProductFlexibilePriceRequest
 */
export interface ProductFlexibilePriceRequest {
    /**
     * 
     * @type {string}
     * @memberof ProductFlexibilePriceRequest
     */
    'price': string;
    /**
     * 
     * @type {string}
     * @memberof ProductFlexibilePriceRequest
     */
    'description': string;
    /**
     * Controls visibility of the product in the app.
     * @type {boolean}
     * @memberof ProductFlexibilePriceRequest
     */
    'is_active'?: boolean;
}
/**
 * Simple serializer for Product without related purchasable objects
 * @export
 * @interface ProductFlexiblePrice
 */
export interface ProductFlexiblePrice {
    /**
     * 
     * @type {number}
     * @memberof ProductFlexiblePrice
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ProductFlexiblePrice
     */
    'price': string;
    /**
     * 
     * @type {string}
     * @memberof ProductFlexiblePrice
     */
    'description': string;
    /**
     * Controls visibility of the product in the app.
     * @type {boolean}
     * @memberof ProductFlexiblePrice
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {V0Discount}
     * @memberof ProductFlexiblePrice
     */
    'product_flexible_price': V0Discount | null;
}
/**
 * @type ProductPurchasableObject
 * @export
 */
export type ProductPurchasableObject = ProductPurchasableObjectOneOf | ProductPurchasableObjectOneOf1;

/**
 * 
 * @export
 * @interface ProductPurchasableObjectOneOf
 */
export interface ProductPurchasableObjectOneOf {
    /**
     * 
     * @type {number}
     * @memberof ProductPurchasableObjectOneOf
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ProductPurchasableObjectOneOf
     */
    'run_tag'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductPurchasableObjectOneOf
     */
    'start_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductPurchasableObjectOneOf
     */
    'end_date'?: string;
}
/**
 * 
 * @export
 * @interface ProductPurchasableObjectOneOf1
 */
export interface ProductPurchasableObjectOneOf1 {
    /**
     * 
     * @type {number}
     * @memberof ProductPurchasableObjectOneOf1
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ProductPurchasableObjectOneOf1
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductPurchasableObjectOneOf1
     */
    'run_tag'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductPurchasableObjectOneOf1
     */
    'start_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductPurchasableObjectOneOf1
     */
    'end_date'?: string;
    /**
     * 
     * @type {ProductPurchasableObjectOneOf1Course}
     * @memberof ProductPurchasableObjectOneOf1
     */
    'course'?: ProductPurchasableObjectOneOf1Course;
    /**
     * 
     * @type {string}
     * @memberof ProductPurchasableObjectOneOf1
     */
    'readable_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductPurchasableObjectOneOf1
     */
    'enrollment_start'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductPurchasableObjectOneOf1
     */
    'enrollment_end'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductPurchasableObjectOneOf1
     */
    'course_number'?: string;
}
/**
 * 
 * @export
 * @interface ProductPurchasableObjectOneOf1Course
 */
export interface ProductPurchasableObjectOneOf1Course {
    /**
     * 
     * @type {number}
     * @memberof ProductPurchasableObjectOneOf1Course
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ProductPurchasableObjectOneOf1Course
     */
    'title'?: string;
    /**
     * 
     * @type {object}
     * @memberof ProductPurchasableObjectOneOf1Course
     */
    'page'?: object;
}
/**
 * Serializes a product, including the purchasable object.
 * @export
 * @interface ProductRequest
 */
export interface ProductRequest {
    /**
     * 
     * @type {string}
     * @memberof ProductRequest
     */
    'price': string;
    /**
     * 
     * @type {string}
     * @memberof ProductRequest
     */
    'description': string;
    /**
     * Controls visibility of the product in the app.
     * @type {boolean}
     * @memberof ProductRequest
     */
    'is_active'?: boolean;
}
/**
 * 
 * @export
 * @interface Program
 */
export interface Program {
    /**
     * 
     * @type {number}
     * @memberof Program
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Program
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof Program
     */
    'readable_id': string;
}
/**
 * ProgramCertificate model serializer
 * @export
 * @interface ProgramCertificate
 */
export interface ProgramCertificate {
    /**
     * 
     * @type {string}
     * @memberof ProgramCertificate
     */
    'uuid': string;
    /**
     * Get the link at which this certificate will be served Format: /certificate/program/<uuid>/ Example: /certificate/program/93ebd74e-5f88-4b47-bb09-30a6d575328f/
     * @type {string}
     * @memberof ProgramCertificate
     */
    'link': string;
}
/**
 * Program page model serializer
 * @export
 * @interface ProgramPage
 */
export interface ProgramPage {
    /**
     * Serializes the source of the feature_image
     * @type {string}
     * @memberof ProgramPage
     */
    'feature_image_src': string;
    /**
     * 
     * @type {string}
     * @memberof ProgramPage
     */
    'page_url': string;
    /**
     * 
     * @type {string}
     * @memberof ProgramPage
     */
    'financial_assistance_form_url': string;
    /**
     * The description shown on the home page and product page.
     * @type {string}
     * @memberof ProgramPage
     */
    'description': string;
    /**
     * 
     * @type {boolean}
     * @memberof ProgramPage
     */
    'live': boolean;
    /**
     * A short description indicating how long it takes to complete (e.g. \'4 weeks\').
     * @type {string}
     * @memberof ProgramPage
     */
    'length'?: string;
    /**
     * A short description indicating how much effort is required (e.g. 1-3 hours per week).
     * @type {string}
     * @memberof ProgramPage
     */
    'effort'?: string | null;
    /**
     * Get the price text from the program page.
     * @type {string}
     * @memberof ProgramPage
     */
    'price': string;
}
/**
 * Serializer for individual program page items, including all relevant fields.
 * @export
 * @interface ProgramPageItem
 */
export interface ProgramPageItem {
    /**
     * 
     * @type {number}
     * @memberof ProgramPageItem
     */
    'id': number;
    /**
     * 
     * @type {PageMeta}
     * @memberof ProgramPageItem
     */
    'meta': PageMeta;
    /**
     * The page title as you\'d like it to be seen by the public
     * @type {string}
     * @memberof ProgramPageItem
     */
    'title': string;
    /**
     * The description shown on the home page and product page.
     * @type {string}
     * @memberof ProgramPageItem
     */
    'description': string;
    /**
     * A short description indicating how long it takes to complete (e.g. \'4 weeks\').
     * @type {string}
     * @memberof ProgramPageItem
     */
    'length': string;
    /**
     * A short description indicating how much effort is required (e.g. 1-3 hours per week).
     * @type {string}
     * @memberof ProgramPageItem
     */
    'effort': string | null;
    /**
     * The minimum number of hours per week required to complete the course.
     * @type {string}
     * @memberof ProgramPageItem
     */
    'min_weekly_hours': string;
    /**
     * The maximum number of hours per week required to complete the course.
     * @type {string}
     * @memberof ProgramPageItem
     */
    'max_weekly_hours': string;
    /**
     * The minimum number of weeks required to complete the course/program.
     * @type {number}
     * @memberof ProgramPageItem
     */
    'min_weeks': number | null;
    /**
     * The maximum number of weeks required to complete the course/program.
     * @type {number}
     * @memberof ProgramPageItem
     */
    'max_weeks': number | null;
    /**
     * 
     * @type {Array<PriceItem>}
     * @memberof ProgramPageItem
     */
    'price': Array<PriceItem>;
    /**
     * Specify the minimum product price. This is used by MIT Learn.
     * @type {number}
     * @memberof ProgramPageItem
     */
    'min_price': number;
    /**
     * Specify the maximum product price. This is used by MIT Learn.
     * @type {number}
     * @memberof ProgramPageItem
     */
    'max_price': number;
    /**
     * A short description indicating prerequisites of this course/program.
     * @type {string}
     * @memberof ProgramPageItem
     */
    'prerequisites': string | null;
    /**
     * URL a relevant FAQ page or entry for the course/program.
     * @type {string}
     * @memberof ProgramPageItem
     */
    'faq_url': string | null;
    /**
     * Details about this course/program.
     * @type {string}
     * @memberof ProgramPageItem
     */
    'about': string | null;
    /**
     * *Required for Verifiable Credential generation. What you will learn from this course.
     * @type {string}
     * @memberof ProgramPageItem
     */
    'what_you_learn': string | null;
    /**
     * 
     * @type {FeatureImage}
     * @memberof ProgramPageItem
     */
    'feature_image': FeatureImage;
    /**
     * URL to the video to be displayed for this course/program. It can be an HLS or Youtube video URL.
     * @type {string}
     * @memberof ProgramPageItem
     */
    'video_url': string | null;
    /**
     * The title text to display in the faculty cards section of the product page.
     * @type {string}
     * @memberof ProgramPageItem
     */
    'faculty_section_title': string | null;
    /**
     * 
     * @type {Array<Faculty>}
     * @memberof ProgramPageItem
     */
    'faculty': Array<Faculty>;
    /**
     * 
     * @type {CertificatePage}
     * @memberof ProgramPageItem
     */
    'certificate_page': CertificatePage;
    /**
     * 
     * @type {V2Program}
     * @memberof ProgramPageItem
     */
    'program_details': V2Program;
}
/**
 * Serializer for a list of program pages, including metadata and items.
 * @export
 * @interface ProgramPageList
 */
export interface ProgramPageList {
    /**
     * 
     * @type {PageListMeta}
     * @memberof ProgramPageList
     */
    'meta': PageListMeta;
    /**
     * 
     * @type {Array<ProgramPageItem>}
     * @memberof ProgramPageList
     */
    'items': Array<ProgramPageItem>;
}
/**
 * Serializer for public user data
 * @export
 * @interface PublicUser
 */
export interface PublicUser {
    /**
     * 
     * @type {number}
     * @memberof PublicUser
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof PublicUser
     */
    'username'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PublicUser
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicUser
     */
    'created_on': string;
    /**
     * 
     * @type {string}
     * @memberof PublicUser
     */
    'updated_on': string;
}
/**
 * DiscountRedemption model serializer
 * @export
 * @interface RedeemedDiscount
 */
export interface RedeemedDiscount {
    /**
     * 
     * @type {Nested}
     * @memberof RedeemedDiscount
     */
    'redeemed_discount': Nested;
}
/**
 * * `one-time` - one-time * `one-time-per-user` - one-time-per-user * `unlimited` - unlimited
 * @export
 * @enum {string}
 */

export const RedemptionTypeEnum = {
    /**
    * one-time
    */
    OneTime: 'one-time',
    /**
    * one-time-per-user
    */
    OneTimePerUser: 'one-time-per-user',
    /**
    * unlimited
    */
    Unlimited: 'unlimited'
} as const;

export type RedemptionTypeEnum = typeof RedemptionTypeEnum[keyof typeof RedemptionTypeEnum];


/**
 * * `b2b-disallowed` - b2b-disallowed * `b2b-error-no-contract` - b2b-error-no-contract * `b2b-error-no-product` - b2b-error-no-product * `b2b-error-missing-enrollment-code` - b2b-error-missing-enrollment-code * `b2b-error-invalid-enrollment-code` - b2b-error-invalid-enrollment-code * `b2b-error-requires-checkout` - b2b-error-requires-checkout * `b2b-error-not-enrollable` - b2b-error-not-enrollable * `b2b-enroll-success` - b2b-enroll-success
 * @export
 * @enum {string}
 */

export const ResultEnum = {
    /**
    * b2b-disallowed
    */
    Disallowed: 'b2b-disallowed',
    /**
    * b2b-error-no-contract
    */
    ErrorNoContract: 'b2b-error-no-contract',
    /**
    * b2b-error-no-product
    */
    ErrorNoProduct: 'b2b-error-no-product',
    /**
    * b2b-error-missing-enrollment-code
    */
    ErrorMissingEnrollmentCode: 'b2b-error-missing-enrollment-code',
    /**
    * b2b-error-invalid-enrollment-code
    */
    ErrorInvalidEnrollmentCode: 'b2b-error-invalid-enrollment-code',
    /**
    * b2b-error-requires-checkout
    */
    ErrorRequiresCheckout: 'b2b-error-requires-checkout',
    /**
    * b2b-error-not-enrollable
    */
    ErrorNotEnrollable: 'b2b-error-not-enrollable',
    /**
    * b2b-enroll-success
    */
    EnrollSuccess: 'b2b-enroll-success'
} as const;

export type ResultEnum = typeof ResultEnum[keyof typeof ResultEnum];


/**
 * Serializer for signatory items used in certificate pages.
 * @export
 * @interface SignatoryItem
 */
export interface SignatoryItem {
    /**
     * 
     * @type {string}
     * @memberof SignatoryItem
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof SignatoryItem
     */
    'title_1': string;
    /**
     * 
     * @type {string}
     * @memberof SignatoryItem
     */
    'title_2': string;
    /**
     * 
     * @type {string}
     * @memberof SignatoryItem
     */
    'title_3': string;
    /**
     * 
     * @type {string}
     * @memberof SignatoryItem
     */
    'organization': string;
    /**
     * 
     * @type {string}
     * @memberof SignatoryItem
     */
    'signature_image': string;
}
/**
 * Serializer for data we care about in the staff dashboard
 * @export
 * @interface StaffDashboardUser
 */
export interface StaffDashboardUser {
    /**
     * 
     * @type {number}
     * @memberof StaffDashboardUser
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof StaffDashboardUser
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof StaffDashboardUser
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof StaffDashboardUser
     */
    'email': string;
    /**
     * 
     * @type {LegalAddress}
     * @memberof StaffDashboardUser
     */
    'legal_address': LegalAddress | null;
    /**
     * The user can access the admin site
     * @type {boolean}
     * @memberof StaffDashboardUser
     */
    'is_staff'?: boolean;
    /**
     * Designates that this user has all permissions without explicitly assigning them.
     * @type {boolean}
     * @memberof StaffDashboardUser
     */
    'is_superuser'?: boolean;
}
/**
 * * `pending` - Pending * `fulfilled` - Fulfilled * `canceled` - Canceled * `declined` - Declined * `errored` - Errored * `refunded` - Refunded * `review` - Review * `partially_refunded` - Partially Refunded
 * @export
 * @enum {string}
 */

export const StateEnum = {
    /**
    * Pending
    */
    Pending: 'pending',
    /**
    * Fulfilled
    */
    Fulfilled: 'fulfilled',
    /**
    * Canceled
    */
    Canceled: 'canceled',
    /**
    * Declined
    */
    Declined: 'declined',
    /**
    * Errored
    */
    Errored: 'errored',
    /**
    * Refunded
    */
    Refunded: 'refunded',
    /**
    * Review
    */
    Review: 'review',
    /**
    * Partially Refunded
    */
    PartiallyRefunded: 'partially_refunded'
} as const;

export type StateEnum = typeof StateEnum[keyof typeof StateEnum];


/**
 * Serializer for topics used in course pages.
 * @export
 * @interface Topic
 */
export interface Topic {
    /**
     * 
     * @type {string}
     * @memberof Topic
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Topic
     */
    'parent'?: string;
}
/**
 * Serializes a line item from a transaction.
 * @export
 * @interface TransactionLine
 */
export interface TransactionLine {
    /**
     * 
     * @type {number}
     * @memberof TransactionLine
     */
    'quantity': number;
    /**
     * 
     * @type {string}
     * @memberof TransactionLine
     */
    'CEUs': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionLine
     */
    'content_title': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionLine
     */
    'readable_id': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionLine
     */
    'start_date': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionLine
     */
    'end_date': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionLine
     */
    'total_paid': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionLine
     */
    'discount': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionLine
     */
    'price': string;
}
/**
 * Serializer for users
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'username'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email'?: string | null;
    /**
     * 
     * @type {LegalAddress}
     * @memberof User
     */
    'legal_address': LegalAddress | null;
    /**
     * 
     * @type {UserProfile}
     * @memberof User
     */
    'user_profile'?: UserProfile | null;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'is_anonymous': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'is_authenticated': boolean;
    /**
     * Returns True if the user has editor permissions for the CMS
     * @type {boolean}
     * @memberof User
     */
    'is_editor': boolean;
    /**
     * The user can access the admin site
     * @type {boolean}
     * @memberof User
     */
    'is_staff': boolean;
    /**
     * Designates that this user has all permissions without explicitly assigning them.
     * @type {boolean}
     * @memberof User
     */
    'is_superuser': boolean;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'created_on': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'updated_on': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof User
     */
    'grants': Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {Array<OrganizationPage>}
     * @memberof User
     */
    'b2b_organizations': Array<OrganizationPage>;
    /**
     * The SSO ID (usually a Keycloak UUID) for the user.
     * @type {string}
     * @memberof User
     */
    'global_id': string | null;
}
/**
 * Serializes UserDiscount but only allows depth = 1
 * @export
 * @interface UserDiscountMeta
 */
export interface UserDiscountMeta {
    /**
     * 
     * @type {number}
     * @memberof UserDiscountMeta
     */
    'id': number;
    /**
     * 
     * @type {V0Discount}
     * @memberof UserDiscountMeta
     */
    'discount': V0Discount;
    /**
     * 
     * @type {User}
     * @memberof UserDiscountMeta
     */
    'user': User;
}
/**
 * Serializes UserDiscount but only allows depth = 1
 * @export
 * @interface UserDiscountMetaRequest
 */
export interface UserDiscountMetaRequest {
    /**
     * 
     * @type {V0DiscountRequest}
     * @memberof UserDiscountMetaRequest
     */
    'discount': V0DiscountRequest;
    /**
     * 
     * @type {UserRequest}
     * @memberof UserDiscountMetaRequest
     */
    'user': UserRequest;
}
/**
 * Serializer for profile
 * @export
 * @interface UserProfile
 */
export interface UserProfile {
    /**
     * 
     * @type {UserProfileGender}
     * @memberof UserProfile
     */
    'gender'?: UserProfileGender | null;
    /**
     * 
     * @type {number}
     * @memberof UserProfile
     */
    'year_of_birth'?: number | null;
    /**
     * Flags if we\'ve asked the user for additional information
     * @type {boolean}
     * @memberof UserProfile
     */
    'addl_field_flag'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    'company'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    'job_title'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    'industry'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    'job_function'?: string | null;
    /**
     * 
     * @type {CompanySizeEnum}
     * @memberof UserProfile
     */
    'company_size'?: CompanySizeEnum | null;
    /**
     * 
     * @type {YearsExperienceEnum}
     * @memberof UserProfile
     */
    'years_experience'?: YearsExperienceEnum | null;
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    'leadership_level'?: string | null;
    /**
     * 
     * @type {UserProfileHighestEducation}
     * @memberof UserProfile
     */
    'highest_education'?: UserProfileHighestEducation | null;
    /**
     * The learner identifies as type Student
     * @type {boolean}
     * @memberof UserProfile
     */
    'type_is_student'?: boolean | null;
    /**
     * The learner identifies as type Professional
     * @type {boolean}
     * @memberof UserProfile
     */
    'type_is_professional'?: boolean | null;
    /**
     * The learner identifies as type Educator
     * @type {boolean}
     * @memberof UserProfile
     */
    'type_is_educator'?: boolean | null;
    /**
     * The learner identifies as type Other (not professional, student, or educator)
     * @type {boolean}
     * @memberof UserProfile
     */
    'type_is_other'?: boolean | null;
}


/**
 * @type UserProfileGender
 * @export
 */
export type UserProfileGender = BlankEnum | GenderEnum;

/**
 * @type UserProfileHighestEducation
 * @export
 */
export type UserProfileHighestEducation = BlankEnum | HighestEducationEnum;

/**
 * Serializer for profile
 * @export
 * @interface UserProfileRequest
 */
export interface UserProfileRequest {
    /**
     * 
     * @type {UserProfileGender}
     * @memberof UserProfileRequest
     */
    'gender'?: UserProfileGender | null;
    /**
     * 
     * @type {number}
     * @memberof UserProfileRequest
     */
    'year_of_birth'?: number | null;
    /**
     * Flags if we\'ve asked the user for additional information
     * @type {boolean}
     * @memberof UserProfileRequest
     */
    'addl_field_flag'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserProfileRequest
     */
    'company'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserProfileRequest
     */
    'job_title'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserProfileRequest
     */
    'industry'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserProfileRequest
     */
    'job_function'?: string | null;
    /**
     * 
     * @type {CompanySizeEnum}
     * @memberof UserProfileRequest
     */
    'company_size'?: CompanySizeEnum | null;
    /**
     * 
     * @type {YearsExperienceEnum}
     * @memberof UserProfileRequest
     */
    'years_experience'?: YearsExperienceEnum | null;
    /**
     * 
     * @type {string}
     * @memberof UserProfileRequest
     */
    'leadership_level'?: string | null;
    /**
     * 
     * @type {UserProfileHighestEducation}
     * @memberof UserProfileRequest
     */
    'highest_education'?: UserProfileHighestEducation | null;
    /**
     * The learner identifies as type Student
     * @type {boolean}
     * @memberof UserProfileRequest
     */
    'type_is_student'?: boolean | null;
    /**
     * The learner identifies as type Professional
     * @type {boolean}
     * @memberof UserProfileRequest
     */
    'type_is_professional'?: boolean | null;
    /**
     * The learner identifies as type Educator
     * @type {boolean}
     * @memberof UserProfileRequest
     */
    'type_is_educator'?: boolean | null;
    /**
     * The learner identifies as type Other (not professional, student, or educator)
     * @type {boolean}
     * @memberof UserProfileRequest
     */
    'type_is_other'?: boolean | null;
}


/**
 * 
 * @export
 * @interface UserProgramEnrollmentDetail
 */
export interface UserProgramEnrollmentDetail {
    /**
     * 
     * @type {V1Program}
     * @memberof UserProgramEnrollmentDetail
     */
    'program': V1Program;
    /**
     * 
     * @type {Array<CourseRunEnrollment>}
     * @memberof UserProgramEnrollmentDetail
     */
    'enrollments': Array<CourseRunEnrollment>;
    /**
     * 
     * @type {V1ProgramCertificate}
     * @memberof UserProgramEnrollmentDetail
     */
    'certificate': V1ProgramCertificate | null;
}
/**
 * Serializer for users
 * @export
 * @interface UserRequest
 */
export interface UserRequest {
    /**
     * 
     * @type {string}
     * @memberof UserRequest
     */
    'username'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserRequest
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserRequest
     */
    'password'?: string;
    /**
     * 
     * @type {LegalAddressRequest}
     * @memberof UserRequest
     */
    'legal_address': LegalAddressRequest | null;
    /**
     * 
     * @type {UserProfileRequest}
     * @memberof UserRequest
     */
    'user_profile'?: UserProfileRequest | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserRequest
     */
    'is_active'?: boolean;
}
/**
 * Serializes a discount.
 * @export
 * @interface V0Discount
 */
export interface V0Discount {
    /**
     * 
     * @type {number}
     * @memberof V0Discount
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof V0Discount
     */
    'amount': string;
    /**
     * 
     * @type {boolean}
     * @memberof V0Discount
     */
    'automatic'?: boolean;
    /**
     * 
     * @type {DiscountTypeEnum}
     * @memberof V0Discount
     */
    'discount_type': DiscountTypeEnum;
    /**
     * 
     * @type {RedemptionTypeEnum}
     * @memberof V0Discount
     */
    'redemption_type': RedemptionTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof V0Discount
     */
    'max_redemptions'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof V0Discount
     */
    'discount_code': string;
    /**
     * 
     * @type {PaymentTypeEnum}
     * @memberof V0Discount
     */
    'payment_type'?: PaymentTypeEnum | null;
    /**
     * Returns True if the discount has been redeemed
     * @type {boolean}
     * @memberof V0Discount
     */
    'is_redeemed': boolean;
    /**
     * If set, this discount code will not be redeemable before this date.
     * @type {string}
     * @memberof V0Discount
     */
    'activation_date'?: string | null;
    /**
     * If set, this discount code will not be redeemable after this date.
     * @type {string}
     * @memberof V0Discount
     */
    'expiration_date'?: string | null;
}


/**
 * Serializes a discount.
 * @export
 * @interface V0DiscountRequest
 */
export interface V0DiscountRequest {
    /**
     * 
     * @type {string}
     * @memberof V0DiscountRequest
     */
    'amount': string;
    /**
     * 
     * @type {boolean}
     * @memberof V0DiscountRequest
     */
    'automatic'?: boolean;
    /**
     * 
     * @type {DiscountTypeEnum}
     * @memberof V0DiscountRequest
     */
    'discount_type': DiscountTypeEnum;
    /**
     * 
     * @type {RedemptionTypeEnum}
     * @memberof V0DiscountRequest
     */
    'redemption_type': RedemptionTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof V0DiscountRequest
     */
    'max_redemptions'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof V0DiscountRequest
     */
    'discount_code': string;
    /**
     * 
     * @type {PaymentTypeEnum}
     * @memberof V0DiscountRequest
     */
    'payment_type'?: PaymentTypeEnum | null;
    /**
     * If set, this discount code will not be redeemable before this date.
     * @type {string}
     * @memberof V0DiscountRequest
     */
    'activation_date'?: string | null;
    /**
     * If set, this discount code will not be redeemable after this date.
     * @type {string}
     * @memberof V0DiscountRequest
     */
    'expiration_date'?: string | null;
}


/**
 * CourseRun model serializer
 * @export
 * @interface V1BaseCourseRun
 */
export interface V1BaseCourseRun {
    /**
     * The title of the course. This value is synced automatically with edX studio.
     * @type {string}
     * @memberof V1BaseCourseRun
     */
    'title': string;
    /**
     * The day the course begins. This value is synced automatically with edX studio.
     * @type {string}
     * @memberof V1BaseCourseRun
     */
    'start_date'?: string | null;
    /**
     * The last day the course is active. This value is synced automatically with edX studio.
     * @type {string}
     * @memberof V1BaseCourseRun
     */
    'end_date'?: string | null;
    /**
     * The first day students can enroll. This value is synced automatically with edX studio.
     * @type {string}
     * @memberof V1BaseCourseRun
     */
    'enrollment_start'?: string | null;
    /**
     * The last day students can enroll. This value is synced automatically with edX studio.
     * @type {string}
     * @memberof V1BaseCourseRun
     */
    'enrollment_end'?: string | null;
    /**
     * The date beyond which the learner should not see link to this course run on their dashboard.
     * @type {string}
     * @memberof V1BaseCourseRun
     */
    'expiration_date'?: string | null;
    /**
     * Get the courseware URL
     * @type {string}
     * @memberof V1BaseCourseRun
     */
    'courseware_url': string | null;
    /**
     * 
     * @type {string}
     * @memberof V1BaseCourseRun
     */
    'courseware_id': string;
    /**
     * The day certificates should be available to users. This value is synced automatically with edX studio.
     * @type {string}
     * @memberof V1BaseCourseRun
     */
    'certificate_available_date'?: string | null;
    /**
     * The date beyond which the learner can not enroll in paid course mode.
     * @type {string}
     * @memberof V1BaseCourseRun
     */
    'upgrade_deadline'?: string | null;
    /**
     * Check if the course run is upgradable
     * @type {boolean}
     * @memberof V1BaseCourseRun
     */
    'is_upgradable': boolean;
    /**
     * Check if the course run is enrollable
     * @type {boolean}
     * @memberof V1BaseCourseRun
     */
    'is_enrollable': boolean;
    /**
     * Check if the course run is archived
     * @type {boolean}
     * @memberof V1BaseCourseRun
     */
    'is_archived': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V1BaseCourseRun
     */
    'is_self_paced'?: boolean;
    /**
     * A string that identifies the set of runs that this run belongs to (example: \'R2\')
     * @type {string}
     * @memberof V1BaseCourseRun
     */
    'run_tag': string;
    /**
     * 
     * @type {number}
     * @memberof V1BaseCourseRun
     */
    'id': number;
    /**
     * 
     * @type {boolean}
     * @memberof V1BaseCourseRun
     */
    'live'?: boolean;
    /**
     * Get the course number
     * @type {string}
     * @memberof V1BaseCourseRun
     */
    'course_number': string;
    /**
     * 
     * @type {Array<ProductFlexibilePrice>}
     * @memberof V1BaseCourseRun
     */
    'products': Array<ProductFlexibilePrice>;
    /**
     * 
     * @type {boolean}
     * @memberof V1BaseCourseRun
     */
    'approved_flexible_price_exists': boolean;
}
/**
 * CourseRun model serializer - also serializes the parent Course.
 * @export
 * @interface V1CourseRunWithCourse
 */
export interface V1CourseRunWithCourse {
    /**
     * The title of the course. This value is synced automatically with edX studio.
     * @type {string}
     * @memberof V1CourseRunWithCourse
     */
    'title': string;
    /**
     * The day the course begins. This value is synced automatically with edX studio.
     * @type {string}
     * @memberof V1CourseRunWithCourse
     */
    'start_date'?: string | null;
    /**
     * The last day the course is active. This value is synced automatically with edX studio.
     * @type {string}
     * @memberof V1CourseRunWithCourse
     */
    'end_date'?: string | null;
    /**
     * The first day students can enroll. This value is synced automatically with edX studio.
     * @type {string}
     * @memberof V1CourseRunWithCourse
     */
    'enrollment_start'?: string | null;
    /**
     * The last day students can enroll. This value is synced automatically with edX studio.
     * @type {string}
     * @memberof V1CourseRunWithCourse
     */
    'enrollment_end'?: string | null;
    /**
     * The date beyond which the learner should not see link to this course run on their dashboard.
     * @type {string}
     * @memberof V1CourseRunWithCourse
     */
    'expiration_date'?: string | null;
    /**
     * Get the courseware URL
     * @type {string}
     * @memberof V1CourseRunWithCourse
     */
    'courseware_url': string | null;
    /**
     * 
     * @type {string}
     * @memberof V1CourseRunWithCourse
     */
    'courseware_id': string;
    /**
     * The day certificates should be available to users. This value is synced automatically with edX studio.
     * @type {string}
     * @memberof V1CourseRunWithCourse
     */
    'certificate_available_date'?: string | null;
    /**
     * The date beyond which the learner can not enroll in paid course mode.
     * @type {string}
     * @memberof V1CourseRunWithCourse
     */
    'upgrade_deadline'?: string | null;
    /**
     * Check if the course run is upgradable
     * @type {boolean}
     * @memberof V1CourseRunWithCourse
     */
    'is_upgradable': boolean;
    /**
     * Check if the course run is enrollable
     * @type {boolean}
     * @memberof V1CourseRunWithCourse
     */
    'is_enrollable': boolean;
    /**
     * Check if the course run is archived
     * @type {boolean}
     * @memberof V1CourseRunWithCourse
     */
    'is_archived': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V1CourseRunWithCourse
     */
    'is_self_paced'?: boolean;
    /**
     * A string that identifies the set of runs that this run belongs to (example: \'R2\')
     * @type {string}
     * @memberof V1CourseRunWithCourse
     */
    'run_tag': string;
    /**
     * 
     * @type {number}
     * @memberof V1CourseRunWithCourse
     */
    'id': number;
    /**
     * 
     * @type {boolean}
     * @memberof V1CourseRunWithCourse
     */
    'live'?: boolean;
    /**
     * Get the course number
     * @type {string}
     * @memberof V1CourseRunWithCourse
     */
    'course_number': string;
    /**
     * List of products associated with this course run
     * @type {Array<ProductFlexibilePrice>}
     * @memberof V1CourseRunWithCourse
     */
    'products': Array<ProductFlexibilePrice>;
    /**
     * 
     * @type {boolean}
     * @memberof V1CourseRunWithCourse
     */
    'approved_flexible_price_exists': boolean;
    /**
     * 
     * @type {Course}
     * @memberof V1CourseRunWithCourse
     */
    'course': Course;
}
/**
 * CourseRun model serializer - also serializes the parent Course.
 * @export
 * @interface V1CourseRunWithCourseRequest
 */
export interface V1CourseRunWithCourseRequest {
    /**
     * The title of the course. This value is synced automatically with edX studio.
     * @type {string}
     * @memberof V1CourseRunWithCourseRequest
     */
    'title': string;
    /**
     * The day the course begins. This value is synced automatically with edX studio.
     * @type {string}
     * @memberof V1CourseRunWithCourseRequest
     */
    'start_date'?: string | null;
    /**
     * The last day the course is active. This value is synced automatically with edX studio.
     * @type {string}
     * @memberof V1CourseRunWithCourseRequest
     */
    'end_date'?: string | null;
    /**
     * The first day students can enroll. This value is synced automatically with edX studio.
     * @type {string}
     * @memberof V1CourseRunWithCourseRequest
     */
    'enrollment_start'?: string | null;
    /**
     * The last day students can enroll. This value is synced automatically with edX studio.
     * @type {string}
     * @memberof V1CourseRunWithCourseRequest
     */
    'enrollment_end'?: string | null;
    /**
     * The date beyond which the learner should not see link to this course run on their dashboard.
     * @type {string}
     * @memberof V1CourseRunWithCourseRequest
     */
    'expiration_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof V1CourseRunWithCourseRequest
     */
    'courseware_id': string;
    /**
     * The day certificates should be available to users. This value is synced automatically with edX studio.
     * @type {string}
     * @memberof V1CourseRunWithCourseRequest
     */
    'certificate_available_date'?: string | null;
    /**
     * The date beyond which the learner can not enroll in paid course mode.
     * @type {string}
     * @memberof V1CourseRunWithCourseRequest
     */
    'upgrade_deadline'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof V1CourseRunWithCourseRequest
     */
    'is_self_paced'?: boolean;
    /**
     * A string that identifies the set of runs that this run belongs to (example: \'R2\')
     * @type {string}
     * @memberof V1CourseRunWithCourseRequest
     */
    'run_tag': string;
    /**
     * 
     * @type {boolean}
     * @memberof V1CourseRunWithCourseRequest
     */
    'live'?: boolean;
}
/**
 * Course model serializer - also serializes child course runs
 * @export
 * @interface V1CourseWithCourseRuns
 */
export interface V1CourseWithCourseRuns {
    /**
     * 
     * @type {number}
     * @memberof V1CourseWithCourseRuns
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof V1CourseWithCourseRuns
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof V1CourseWithCourseRuns
     */
    'readable_id': string;
    /**
     * Get next run id
     * @type {number}
     * @memberof V1CourseWithCourseRuns
     */
    'next_run_id': number | null;
    /**
     * 
     * @type {Array<Department>}
     * @memberof V1CourseWithCourseRuns
     */
    'departments': Array<Department>;
    /**
     * 
     * @type {CoursePage}
     * @memberof V1CourseWithCourseRuns
     */
    'page': CoursePage;
    /**
     * 
     * @type {Program}
     * @memberof V1CourseWithCourseRuns
     */
    'programs': Program | null;
    /**
     * 
     * @type {Array<V1BaseCourseRun>}
     * @memberof V1CourseWithCourseRuns
     */
    'courseruns': Array<V1BaseCourseRun>;
}
/**
 * Program model serializer
 * @export
 * @interface V1Program
 */
export interface V1Program {
    /**
     * 
     * @type {string}
     * @memberof V1Program
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof V1Program
     */
    'readable_id': string;
    /**
     * 
     * @type {number}
     * @memberof V1Program
     */
    'id': number;
    /**
     * 
     * @type {V1CourseWithCourseRuns}
     * @memberof V1Program
     */
    'courses': V1CourseWithCourseRuns;
    /**
     * 
     * @type {V1ProgramRequirements}
     * @memberof V1Program
     */
    'requirements': V1ProgramRequirements;
    /**
     * 
     * @type {Array<V1ProgramRequirement>}
     * @memberof V1Program
     */
    'req_tree': Array<V1ProgramRequirement>;
    /**
     * 
     * @type {ProgramPage}
     * @memberof V1Program
     */
    'page': ProgramPage;
    /**
     * 
     * @type {string}
     * @memberof V1Program
     */
    'program_type'?: string | null;
    /**
     * 
     * @type {Array<Department>}
     * @memberof V1Program
     */
    'departments': Array<Department>;
    /**
     * 
     * @type {boolean}
     * @memberof V1Program
     */
    'live'?: boolean;
}
/**
 * ProgramCertificate model serializer
 * @export
 * @interface V1ProgramCertificate
 */
export interface V1ProgramCertificate {
    /**
     * 
     * @type {string}
     * @memberof V1ProgramCertificate
     */
    'uuid': string;
    /**
     * Get the link at which this certificate will be served Format: /certificate/program/<uuid>/ Example: /certificate/program/93ebd74e-5f88-4b47-bb09-30a6d575328f/
     * @type {string}
     * @memberof V1ProgramCertificate
     */
    'link': string;
}
/**
 * Serializer for a ProgramRequirement
 * @export
 * @interface V1ProgramRequirement
 */
export interface V1ProgramRequirement {
    /**
     * 
     * @type {number}
     * @memberof V1ProgramRequirement
     */
    'id'?: number | null;
    /**
     * 
     * @type {V1ProgramRequirementData}
     * @memberof V1ProgramRequirement
     */
    'data': V1ProgramRequirementData;
    /**
     * 
     * @type {Array<V1ProgramRequirement>}
     * @memberof V1ProgramRequirement
     */
    'children'?: Array<V1ProgramRequirement>;
}
/**
 * Serializer for ProgramRequirement data
 * @export
 * @interface V1ProgramRequirementData
 */
export interface V1ProgramRequirementData {
    /**
     * 
     * @type {NodeTypeEnum}
     * @memberof V1ProgramRequirementData
     */
    'node_type': NodeTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof V1ProgramRequirementData
     */
    'course'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof V1ProgramRequirementData
     */
    'required_program'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof V1ProgramRequirementData
     */
    'program'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ProgramRequirementData
     */
    'title'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof V1ProgramRequirementData
     */
    'operator'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof V1ProgramRequirementData
     */
    'operator_value'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof V1ProgramRequirementData
     */
    'elective_flag'?: boolean | null;
}


/**
 * 
 * @export
 * @interface V1ProgramRequirements
 */
export interface V1ProgramRequirements {
    /**
     * List of required course IDs
     * @type {Array<V1ProgramRequirementsRequiredInner>}
     * @memberof V1ProgramRequirements
     */
    'required'?: Array<V1ProgramRequirementsRequiredInner>;
    /**
     * List of elective course IDs
     * @type {Array<V1ProgramRequirementsRequiredInner>}
     * @memberof V1ProgramRequirements
     */
    'electives'?: Array<V1ProgramRequirementsRequiredInner>;
}
/**
 * @type V1ProgramRequirementsRequiredInner
 * @export
 */
export type V1ProgramRequirementsRequiredInner = number;

/**
 * Course model serializer
 * @export
 * @interface V2Course
 */
export interface V2Course {
    /**
     * 
     * @type {number}
     * @memberof V2Course
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof V2Course
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof V2Course
     */
    'readable_id': string;
    /**
     * Get next run id
     * @type {number}
     * @memberof V2Course
     */
    'next_run_id': number | null;
    /**
     * 
     * @type {Array<Department>}
     * @memberof V2Course
     */
    'departments': Array<Department>;
    /**
     * 
     * @type {CoursePage}
     * @memberof V2Course
     */
    'page': CoursePage;
    /**
     * 
     * @type {Array<BaseProgram>}
     * @memberof V2Course
     */
    'programs': Array<BaseProgram> | null;
    /**
     * List topics of a course
     * @type {Array<{ [key: string]: any; }>}
     * @memberof V2Course
     */
    'topics': Array<{ [key: string]: any; }>;
    /**
     * 
     * @type {string}
     * @memberof V2Course
     */
    'certificate_type': string;
    /**
     * Check if the prerequisites field is populated in the course page CMS. Returns:     bool: True when the prerequisites field is populated in the course page CMS.  False otherwise.
     * @type {boolean}
     * @memberof V2Course
     */
    'required_prerequisites': boolean;
    /**
     * Get the duration of the course from the course page CMS.
     * @type {string}
     * @memberof V2Course
     */
    'duration': string;
    /**
     * Get the min weeks of the course from the CMS page.
     * @type {number}
     * @memberof V2Course
     */
    'min_weeks': number | null;
    /**
     * Get the max weeks of the course from the CMS page.
     * @type {number}
     * @memberof V2Course
     */
    'max_weeks': number | null;
    /**
     * Get the min price of the product from the CMS page.
     * @type {number}
     * @memberof V2Course
     */
    'min_price': number | null;
    /**
     * Get the max price of the product from the CMS page.
     * @type {number}
     * @memberof V2Course
     */
    'max_price': number | null;
    /**
     * Get the time commitment of the course from the course page CMS.
     * @type {string}
     * @memberof V2Course
     */
    'time_commitment': string | null;
    /**
     * Get course availability
     * @type {string}
     * @memberof V2Course
     */
    'availability': string;
    /**
     * Get the min weekly hours of the course from the course page CMS.
     * @type {string}
     * @memberof V2Course
     */
    'min_weekly_hours': string | null;
    /**
     * Get the max weekly hours of the course from the course page CMS.
     * @type {string}
     * @memberof V2Course
     */
    'max_weekly_hours': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof V2Course
     */
    'include_in_learn_catalog': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V2Course
     */
    'ingest_content_files_for_ai': boolean;
}
/**
 * Course model serializer
 * @export
 * @interface V2CourseRequest
 */
export interface V2CourseRequest {
    /**
     * 
     * @type {string}
     * @memberof V2CourseRequest
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof V2CourseRequest
     */
    'readable_id': string;
}
/**
 * Serializer for course certificates.
 * @export
 * @interface V2CourseRunCertificate
 */
export interface V2CourseRunCertificate {
    /**
     * 
     * @type {PublicUser}
     * @memberof V2CourseRunCertificate
     */
    'user': PublicUser;
    /**
     * 
     * @type {string}
     * @memberof V2CourseRunCertificate
     */
    'uuid': string;
    /**
     * Indicates whether or not the certificate is revoked
     * @type {boolean}
     * @memberof V2CourseRunCertificate
     */
    'is_revoked': boolean;
    /**
     * 
     * @type {CertificatePageModel}
     * @memberof V2CourseRunCertificate
     */
    'certificate_page': CertificatePageModel;
    /**
     * 
     * @type {any}
     * @memberof V2CourseRunCertificate
     */
    'verifiable_credential_json': any;
    /**
     * 
     * @type {V2CourseRunWithCourse}
     * @memberof V2CourseRunCertificate
     */
    'course_run': V2CourseRunWithCourse;
    /**
     * 
     * @type {number}
     * @memberof V2CourseRunCertificate
     */
    'certificate_page_revision': number | null;
}
/**
 * CourseRun model serializer - also serializes the parent Course.
 * @export
 * @interface V2CourseRunWithCourse
 */
export interface V2CourseRunWithCourse {
    /**
     * The title of the course. This value is synced automatically with edX studio.
     * @type {string}
     * @memberof V2CourseRunWithCourse
     */
    'title': string;
    /**
     * The day the course begins. This value is synced automatically with edX studio.
     * @type {string}
     * @memberof V2CourseRunWithCourse
     */
    'start_date'?: string | null;
    /**
     * The last day the course is active. This value is synced automatically with edX studio.
     * @type {string}
     * @memberof V2CourseRunWithCourse
     */
    'end_date'?: string | null;
    /**
     * The first day students can enroll. This value is synced automatically with edX studio.
     * @type {string}
     * @memberof V2CourseRunWithCourse
     */
    'enrollment_start'?: string | null;
    /**
     * The last day students can enroll. This value is synced automatically with edX studio.
     * @type {string}
     * @memberof V2CourseRunWithCourse
     */
    'enrollment_end'?: string | null;
    /**
     * The date beyond which the learner should not see link to this course run on their dashboard.
     * @type {string}
     * @memberof V2CourseRunWithCourse
     */
    'expiration_date'?: string | null;
    /**
     * Get the courseware URL
     * @type {string}
     * @memberof V2CourseRunWithCourse
     */
    'courseware_url': string | null;
    /**
     * 
     * @type {string}
     * @memberof V2CourseRunWithCourse
     */
    'courseware_id': string;
    /**
     * The day certificates should be available to users. This value is synced automatically with edX studio.
     * @type {string}
     * @memberof V2CourseRunWithCourse
     */
    'certificate_available_date'?: string | null;
    /**
     * The date beyond which the learner can not enroll in paid course mode.
     * @type {string}
     * @memberof V2CourseRunWithCourse
     */
    'upgrade_deadline'?: string | null;
    /**
     * Check if the course run is upgradable
     * @type {boolean}
     * @memberof V2CourseRunWithCourse
     */
    'is_upgradable': boolean;
    /**
     * Check if the course run is enrollable
     * @type {boolean}
     * @memberof V2CourseRunWithCourse
     */
    'is_enrollable': boolean;
    /**
     * Check if the course run is archived
     * @type {boolean}
     * @memberof V2CourseRunWithCourse
     */
    'is_archived': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V2CourseRunWithCourse
     */
    'is_self_paced'?: boolean;
    /**
     * A string that identifies the set of runs that this run belongs to (example: \'R2\')
     * @type {string}
     * @memberof V2CourseRunWithCourse
     */
    'run_tag': string;
    /**
     * 
     * @type {number}
     * @memberof V2CourseRunWithCourse
     */
    'id': number;
    /**
     * 
     * @type {boolean}
     * @memberof V2CourseRunWithCourse
     */
    'live'?: boolean;
    /**
     * Get the course number
     * @type {string}
     * @memberof V2CourseRunWithCourse
     */
    'course_number': string;
    /**
     * 
     * @type {Array<ProductFlexibilePrice>}
     * @memberof V2CourseRunWithCourse
     */
    'products': Array<ProductFlexibilePrice>;
    /**
     * 
     * @type {boolean}
     * @memberof V2CourseRunWithCourse
     */
    'approved_flexible_price_exists': boolean;
    /**
     * 
     * @type {number}
     * @memberof V2CourseRunWithCourse
     */
    'b2b_contract'?: number | null;
    /**
     * 
     * @type {V2Course}
     * @memberof V2CourseRunWithCourse
     */
    'course': V2Course;
}
/**
 * CourseRun model serializer - also serializes the parent Course.
 * @export
 * @interface V2CourseRunWithCourseRequest
 */
export interface V2CourseRunWithCourseRequest {
    /**
     * The title of the course. This value is synced automatically with edX studio.
     * @type {string}
     * @memberof V2CourseRunWithCourseRequest
     */
    'title': string;
    /**
     * The day the course begins. This value is synced automatically with edX studio.
     * @type {string}
     * @memberof V2CourseRunWithCourseRequest
     */
    'start_date'?: string | null;
    /**
     * The last day the course is active. This value is synced automatically with edX studio.
     * @type {string}
     * @memberof V2CourseRunWithCourseRequest
     */
    'end_date'?: string | null;
    /**
     * The first day students can enroll. This value is synced automatically with edX studio.
     * @type {string}
     * @memberof V2CourseRunWithCourseRequest
     */
    'enrollment_start'?: string | null;
    /**
     * The last day students can enroll. This value is synced automatically with edX studio.
     * @type {string}
     * @memberof V2CourseRunWithCourseRequest
     */
    'enrollment_end'?: string | null;
    /**
     * The date beyond which the learner should not see link to this course run on their dashboard.
     * @type {string}
     * @memberof V2CourseRunWithCourseRequest
     */
    'expiration_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof V2CourseRunWithCourseRequest
     */
    'courseware_id': string;
    /**
     * The day certificates should be available to users. This value is synced automatically with edX studio.
     * @type {string}
     * @memberof V2CourseRunWithCourseRequest
     */
    'certificate_available_date'?: string | null;
    /**
     * The date beyond which the learner can not enroll in paid course mode.
     * @type {string}
     * @memberof V2CourseRunWithCourseRequest
     */
    'upgrade_deadline'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof V2CourseRunWithCourseRequest
     */
    'is_self_paced'?: boolean;
    /**
     * A string that identifies the set of runs that this run belongs to (example: \'R2\')
     * @type {string}
     * @memberof V2CourseRunWithCourseRequest
     */
    'run_tag': string;
    /**
     * 
     * @type {boolean}
     * @memberof V2CourseRunWithCourseRequest
     */
    'live'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof V2CourseRunWithCourseRequest
     */
    'b2b_contract'?: number | null;
}
/**
 * Program Model Serializer v2
 * @export
 * @interface V2Program
 */
export interface V2Program {
    /**
     * 
     * @type {string}
     * @memberof V2Program
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof V2Program
     */
    'readable_id': string;
    /**
     * 
     * @type {number}
     * @memberof V2Program
     */
    'id': number;
    /**
     * 
     * @type {Array<number>}
     * @memberof V2Program
     */
    'courses': Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof V2Program
     */
    'collections': Array<number>;
    /**
     * 
     * @type {V2ProgramRequirements}
     * @memberof V2Program
     */
    'requirements': V2ProgramRequirements;
    /**
     * 
     * @type {Array<V2ProgramRequirement>}
     * @memberof V2Program
     */
    'req_tree': Array<V2ProgramRequirement>;
    /**
     * 
     * @type {ProgramPage}
     * @memberof V2Program
     */
    'page': ProgramPage;
    /**
     * 
     * @type {string}
     * @memberof V2Program
     */
    'program_type'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof V2Program
     */
    'certificate_type': string;
    /**
     * 
     * @type {Array<Department>}
     * @memberof V2Program
     */
    'departments': Array<Department>;
    /**
     * 
     * @type {boolean}
     * @memberof V2Program
     */
    'live'?: boolean;
    /**
     * 
     * @type {Array<V2ProgramTopicsInner>}
     * @memberof V2Program
     */
    'topics': Array<V2ProgramTopicsInner>;
    /**
     * 
     * @type {AvailabilityEnum}
     * @memberof V2Program
     */
    'availability'?: AvailabilityEnum;
    /**
     * Get the start date of the program by finding the first available run.
     * @type {string}
     * @memberof V2Program
     */
    'start_date': string | null;
    /**
     * 
     * @type {string}
     * @memberof V2Program
     */
    'end_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof V2Program
     */
    'enrollment_start'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof V2Program
     */
    'enrollment_end'?: string | null;
    /**
     * Check if the prerequisites field is populated in the program page CMS.
     * @type {boolean}
     * @memberof V2Program
     */
    'required_prerequisites': boolean;
    /**
     * Get the length/duration field from the program page CMS.
     * @type {string}
     * @memberof V2Program
     */
    'duration': string | null;
    /**
     * Get the min weeks of the program from the CMS page.
     * @type {number}
     * @memberof V2Program
     */
    'min_weeks': number | null;
    /**
     * Get the max weeks of the program from the CMS page.
     * @type {number}
     * @memberof V2Program
     */
    'max_weeks': number | null;
    /**
     * Get the min price of the product from the CMS page.
     * @type {number}
     * @memberof V2Program
     */
    'min_price': number | null;
    /**
     * Get the max price of the product from the CMS page.
     * @type {number}
     * @memberof V2Program
     */
    'max_price': number | null;
    /**
     * Get the effort/time_commitment field from the program page CMS.
     * @type {string}
     * @memberof V2Program
     */
    'time_commitment': string | null;
    /**
     * Get the min weekly hours of the course from the course page CMS.
     * @type {string}
     * @memberof V2Program
     */
    'min_weekly_hours': string | null;
    /**
     * Get the max weekly hours of the course from the course page CMS.
     * @type {string}
     * @memberof V2Program
     */
    'max_weekly_hours': string | null;
}


/**
 * Serializer for course certificates.
 * @export
 * @interface V2ProgramCertificate
 */
export interface V2ProgramCertificate {
    /**
     * 
     * @type {PublicUser}
     * @memberof V2ProgramCertificate
     */
    'user': PublicUser;
    /**
     * 
     * @type {string}
     * @memberof V2ProgramCertificate
     */
    'uuid': string;
    /**
     * Indicates whether or not the certificate is revoked
     * @type {boolean}
     * @memberof V2ProgramCertificate
     */
    'is_revoked': boolean;
    /**
     * 
     * @type {CertificatePageModel}
     * @memberof V2ProgramCertificate
     */
    'certificate_page': CertificatePageModel;
    /**
     * 
     * @type {any}
     * @memberof V2ProgramCertificate
     */
    'verifiable_credential_json': any;
    /**
     * 
     * @type {V2Program}
     * @memberof V2ProgramCertificate
     */
    'program': V2Program;
    /**
     * 
     * @type {number}
     * @memberof V2ProgramCertificate
     */
    'certificate_page_revision': number | null;
}
/**
 * Serializer for ProgramCollection
 * @export
 * @interface V2ProgramCollection
 */
export interface V2ProgramCollection {
    /**
     * 
     * @type {number}
     * @memberof V2ProgramCollection
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof V2ProgramCollection
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof V2ProgramCollection
     */
    'description': string;
    /**
     * 
     * @type {Array<V2ProgramCollectionProgramsInner>}
     * @memberof V2ProgramCollection
     */
    'programs': Array<V2ProgramCollectionProgramsInner>;
    /**
     * 
     * @type {string}
     * @memberof V2ProgramCollection
     */
    'created_on': string;
    /**
     * 
     * @type {string}
     * @memberof V2ProgramCollection
     */
    'updated_on': string;
}
/**
 * 
 * @export
 * @interface V2ProgramCollectionProgramsInner
 */
export interface V2ProgramCollectionProgramsInner {
    /**
     * 
     * @type {number}
     * @memberof V2ProgramCollectionProgramsInner
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof V2ProgramCollectionProgramsInner
     */
    'title'?: string;
    /**
     * 
     * @type {number}
     * @memberof V2ProgramCollectionProgramsInner
     */
    'order'?: number;
}
/**
 * Serializer for a ProgramRequirement
 * @export
 * @interface V2ProgramRequirement
 */
export interface V2ProgramRequirement {
    /**
     * 
     * @type {number}
     * @memberof V2ProgramRequirement
     */
    'id'?: number | null;
    /**
     * 
     * @type {V2ProgramRequirementData}
     * @memberof V2ProgramRequirement
     */
    'data': V2ProgramRequirementData;
    /**
     * 
     * @type {Array<V2ProgramRequirement>}
     * @memberof V2ProgramRequirement
     */
    'children'?: Array<V2ProgramRequirement>;
}
/**
 * Serializer for ProgramRequirement data
 * @export
 * @interface V2ProgramRequirementData
 */
export interface V2ProgramRequirementData {
    /**
     * 
     * @type {NodeTypeEnum}
     * @memberof V2ProgramRequirementData
     */
    'node_type': NodeTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof V2ProgramRequirementData
     */
    'course'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof V2ProgramRequirementData
     */
    'program'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof V2ProgramRequirementData
     */
    'required_program'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof V2ProgramRequirementData
     */
    'title'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof V2ProgramRequirementData
     */
    'operator'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof V2ProgramRequirementData
     */
    'operator_value'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof V2ProgramRequirementData
     */
    'elective_flag'?: boolean | null;
}


/**
 * 
 * @export
 * @interface V2ProgramRequirements
 */
export interface V2ProgramRequirements {
    /**
     * 
     * @type {V2ProgramRequirementsCourses}
     * @memberof V2ProgramRequirements
     */
    'courses'?: V2ProgramRequirementsCourses;
    /**
     * 
     * @type {V2ProgramRequirementsPrograms}
     * @memberof V2ProgramRequirements
     */
    'programs'?: V2ProgramRequirementsPrograms;
}
/**
 * 
 * @export
 * @interface V2ProgramRequirementsCourses
 */
export interface V2ProgramRequirementsCourses {
    /**
     * List of required courses with id and readable_id
     * @type {Array<V2ProgramRequirementsCoursesRequiredInner>}
     * @memberof V2ProgramRequirementsCourses
     */
    'required'?: Array<V2ProgramRequirementsCoursesRequiredInner>;
    /**
     * List of elective courses with id and readable_id
     * @type {Array<V2ProgramRequirementsCoursesRequiredInner>}
     * @memberof V2ProgramRequirementsCourses
     */
    'electives'?: Array<V2ProgramRequirementsCoursesRequiredInner>;
}
/**
 * 
 * @export
 * @interface V2ProgramRequirementsCoursesRequiredInner
 */
export interface V2ProgramRequirementsCoursesRequiredInner {
    /**
     * 
     * @type {number}
     * @memberof V2ProgramRequirementsCoursesRequiredInner
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof V2ProgramRequirementsCoursesRequiredInner
     */
    'readable_id'?: string;
}
/**
 * 
 * @export
 * @interface V2ProgramRequirementsPrograms
 */
export interface V2ProgramRequirementsPrograms {
    /**
     * List of required programs with id and readable_id
     * @type {Array<V2ProgramRequirementsCoursesRequiredInner>}
     * @memberof V2ProgramRequirementsPrograms
     */
    'required'?: Array<V2ProgramRequirementsCoursesRequiredInner>;
    /**
     * List of elective programs with id and readable_id
     * @type {Array<V2ProgramRequirementsCoursesRequiredInner>}
     * @memberof V2ProgramRequirementsPrograms
     */
    'electives'?: Array<V2ProgramRequirementsCoursesRequiredInner>;
}
/**
 * 
 * @export
 * @interface V2ProgramTopicsInner
 */
export interface V2ProgramTopicsInner {
    /**
     * 
     * @type {string}
     * @memberof V2ProgramTopicsInner
     */
    'name'?: string;
}
/**
 * Serializer for user program enrollments with associated course enrollments.  This aggregates a program, its course enrollments for the user, and any program certificate that has been earned.
 * @export
 * @interface V2UserProgramEnrollmentDetail
 */
export interface V2UserProgramEnrollmentDetail {
    /**
     * 
     * @type {V2Program}
     * @memberof V2UserProgramEnrollmentDetail
     */
    'program': V2Program;
    /**
     * 
     * @type {Array<CourseRunEnrollmentRequestV2>}
     * @memberof V2UserProgramEnrollmentDetail
     */
    'enrollments': Array<CourseRunEnrollmentRequestV2>;
    /**
     * 
     * @type {ProgramCertificate}
     * @memberof V2UserProgramEnrollmentDetail
     */
    'certificate': ProgramCertificate | null;
}
/**
 * ProgramCertificate model serializer
 * @export
 * @interface V3ProgramCertificate
 */
export interface V3ProgramCertificate {
    /**
     * 
     * @type {string}
     * @memberof V3ProgramCertificate
     */
    'uuid': string;
    /**
     * Get the link at which this certificate will be served Format: /certificate/program/<uuid>/ Example: /certificate/program/93ebd74e-5f88-4b47-bb09-30a6d575328f/
     * @type {string}
     * @memberof V3ProgramCertificate
     */
    'link': string;
}
/**
 * Program Model Serializer v2
 * @export
 * @interface V3SimpleProgram
 */
export interface V3SimpleProgram {
    /**
     * 
     * @type {string}
     * @memberof V3SimpleProgram
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof V3SimpleProgram
     */
    'readable_id': string;
    /**
     * 
     * @type {number}
     * @memberof V3SimpleProgram
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof V3SimpleProgram
     */
    'program_type'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof V3SimpleProgram
     */
    'live'?: boolean;
}
/**
 * Serializer for user program enrollments.
 * @export
 * @interface V3UserProgramEnrollment
 */
export interface V3UserProgramEnrollment {
    /**
     * 
     * @type {V3SimpleProgram}
     * @memberof V3UserProgramEnrollment
     */
    'program': V3SimpleProgram;
    /**
     * 
     * @type {V3ProgramCertificate}
     * @memberof V3UserProgramEnrollment
     */
    'certificate': V3ProgramCertificate | null;
    /**
     * 
     * @type {string}
     * @memberof V3UserProgramEnrollment
     */
    'enrollment_mode'?: string | null;
}
/**
 * * `None` - ---- * `2` - Less than 2 years * `5` - 2-5 years * `10` - 6 - 10 years * `15` - 11 - 15 years * `20` - 16 - 20 years * `21` - More than 20 years * `0` - Prefer not to say
 * @export
 * @enum {string}
 */

export const YearsExperienceEnum = {
    /**
    * Less than 2 years
    */
    NUMBER_2: 2,
    /**
    * 2-5 years
    */
    NUMBER_5: 5,
    /**
    * 6 - 10 years
    */
    NUMBER_10: 10,
    /**
    * 11 - 15 years
    */
    NUMBER_15: 15,
    /**
    * 16 - 20 years
    */
    NUMBER_20: 20,
    /**
    * More than 20 years
    */
    NUMBER_21: 21,
    /**
    * Prefer not to say
    */
    NUMBER_0: 0
} as const;

export type YearsExperienceEnum = typeof YearsExperienceEnum[keyof typeof YearsExperienceEnum];



/**
 * ApiApi - axios parameter creator
 * @export
 */
export const ApiApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Disables sharing links for the learner\'s record. This only applies to the anonymous ones; shares sent to partner schools are always allowed once they are sent.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecordsProgramRevokeCreate: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiRecordsProgramRevokeCreate', 'id', id)
            const localVarPath = `/api/records/program/{id}/revoke/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets up a sharing link for the learner\'s record. Returns back the entire learner record.
         * @param {number} id 
         * @param {PartnerSchoolRequest} PartnerSchoolRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecordsProgramShareCreate: async (id: number, PartnerSchoolRequest: PartnerSchoolRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiRecordsProgramShareCreate', 'id', id)
            // verify required parameter 'PartnerSchoolRequest' is not null or undefined
            assertParamExists('apiRecordsProgramShareCreate', 'PartnerSchoolRequest', PartnerSchoolRequest)
            const localVarPath = `/api/records/program/{id}/share/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(PartnerSchoolRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get learner record using program ID
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        learnerRecordRetrieveById: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('learnerRecordRetrieveById', 'id', id)
            const localVarPath = `/api/records/program/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get learner record using share UUID
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        learnerRecordRetrieveByUuid: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('learnerRecordRetrieveByUuid', 'uuid', uuid)
            const localVarPath = `/api/records/shared/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApiApi - functional programming interface
 * @export
 */
export const ApiApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApiApiAxiosParamCreator(configuration)
    return {
        /**
         * Disables sharing links for the learner\'s record. This only applies to the anonymous ones; shares sent to partner schools are always allowed once they are sent.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiRecordsProgramRevokeCreate(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LearnerRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiRecordsProgramRevokeCreate(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ApiApi.apiRecordsProgramRevokeCreate']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Sets up a sharing link for the learner\'s record. Returns back the entire learner record.
         * @param {number} id 
         * @param {PartnerSchoolRequest} PartnerSchoolRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiRecordsProgramShareCreate(id: number, PartnerSchoolRequest: PartnerSchoolRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LearnerRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiRecordsProgramShareCreate(id, PartnerSchoolRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ApiApi.apiRecordsProgramShareCreate']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get learner record using program ID
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async learnerRecordRetrieveById(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LearnerRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.learnerRecordRetrieveById(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ApiApi.learnerRecordRetrieveById']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get learner record using share UUID
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async learnerRecordRetrieveByUuid(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LearnerRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.learnerRecordRetrieveByUuid(uuid, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ApiApi.learnerRecordRetrieveByUuid']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * ApiApi - factory interface
 * @export
 */
export const ApiApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApiApiFp(configuration)
    return {
        /**
         * Disables sharing links for the learner\'s record. This only applies to the anonymous ones; shares sent to partner schools are always allowed once they are sent.
         * @param {ApiApiApiRecordsProgramRevokeCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecordsProgramRevokeCreate(requestParameters: ApiApiApiRecordsProgramRevokeCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<LearnerRecord> {
            return localVarFp.apiRecordsProgramRevokeCreate(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets up a sharing link for the learner\'s record. Returns back the entire learner record.
         * @param {ApiApiApiRecordsProgramShareCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecordsProgramShareCreate(requestParameters: ApiApiApiRecordsProgramShareCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<LearnerRecord> {
            return localVarFp.apiRecordsProgramShareCreate(requestParameters.id, requestParameters.PartnerSchoolRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get learner record using program ID
         * @param {ApiApiLearnerRecordRetrieveByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        learnerRecordRetrieveById(requestParameters: ApiApiLearnerRecordRetrieveByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<LearnerRecord> {
            return localVarFp.learnerRecordRetrieveById(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get learner record using share UUID
         * @param {ApiApiLearnerRecordRetrieveByUuidRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        learnerRecordRetrieveByUuid(requestParameters: ApiApiLearnerRecordRetrieveByUuidRequest, options?: RawAxiosRequestConfig): AxiosPromise<LearnerRecord> {
            return localVarFp.learnerRecordRetrieveByUuid(requestParameters.uuid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for apiRecordsProgramRevokeCreate operation in ApiApi.
 * @export
 * @interface ApiApiApiRecordsProgramRevokeCreateRequest
 */
export interface ApiApiApiRecordsProgramRevokeCreateRequest {
    /**
     * 
     * @type {number}
     * @memberof ApiApiApiRecordsProgramRevokeCreate
     */
    readonly id: number
}

/**
 * Request parameters for apiRecordsProgramShareCreate operation in ApiApi.
 * @export
 * @interface ApiApiApiRecordsProgramShareCreateRequest
 */
export interface ApiApiApiRecordsProgramShareCreateRequest {
    /**
     * 
     * @type {number}
     * @memberof ApiApiApiRecordsProgramShareCreate
     */
    readonly id: number

    /**
     * 
     * @type {PartnerSchoolRequest}
     * @memberof ApiApiApiRecordsProgramShareCreate
     */
    readonly PartnerSchoolRequest: PartnerSchoolRequest
}

/**
 * Request parameters for learnerRecordRetrieveById operation in ApiApi.
 * @export
 * @interface ApiApiLearnerRecordRetrieveByIdRequest
 */
export interface ApiApiLearnerRecordRetrieveByIdRequest {
    /**
     * 
     * @type {number}
     * @memberof ApiApiLearnerRecordRetrieveById
     */
    readonly id: number
}

/**
 * Request parameters for learnerRecordRetrieveByUuid operation in ApiApi.
 * @export
 * @interface ApiApiLearnerRecordRetrieveByUuidRequest
 */
export interface ApiApiLearnerRecordRetrieveByUuidRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiApiLearnerRecordRetrieveByUuid
     */
    readonly uuid: string
}

/**
 * ApiApi - object-oriented interface
 * @export
 * @class ApiApi
 * @extends {BaseAPI}
 */
export class ApiApi extends BaseAPI {
    /**
     * Disables sharing links for the learner\'s record. This only applies to the anonymous ones; shares sent to partner schools are always allowed once they are sent.
     * @param {ApiApiApiRecordsProgramRevokeCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiRecordsProgramRevokeCreate(requestParameters: ApiApiApiRecordsProgramRevokeCreateRequest, options?: RawAxiosRequestConfig) {
        return ApiApiFp(this.configuration).apiRecordsProgramRevokeCreate(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sets up a sharing link for the learner\'s record. Returns back the entire learner record.
     * @param {ApiApiApiRecordsProgramShareCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiRecordsProgramShareCreate(requestParameters: ApiApiApiRecordsProgramShareCreateRequest, options?: RawAxiosRequestConfig) {
        return ApiApiFp(this.configuration).apiRecordsProgramShareCreate(requestParameters.id, requestParameters.PartnerSchoolRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get learner record using program ID
     * @param {ApiApiLearnerRecordRetrieveByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public learnerRecordRetrieveById(requestParameters: ApiApiLearnerRecordRetrieveByIdRequest, options?: RawAxiosRequestConfig) {
        return ApiApiFp(this.configuration).learnerRecordRetrieveById(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get learner record using share UUID
     * @param {ApiApiLearnerRecordRetrieveByUuidRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public learnerRecordRetrieveByUuid(requestParameters: ApiApiLearnerRecordRetrieveByUuidRequest, options?: RawAxiosRequestConfig) {
        return ApiApiFp(this.configuration).learnerRecordRetrieveByUuid(requestParameters.uuid, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * B2bApi - axios parameter creator
 * @export
 */
export const B2bApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use the provided enrollment code to attach the user to a B2B contract.  This will not create an order, nor will it enroll the user. It will attach the user to the contract and log that the code was used for this purpose (but will _not_ invalidate the code, since we\'re not actually using it at this point).  This will respect the activation and expiration dates (of both the contract and the discount), and will make sure there\'s sufficient available seats in the contract. It will also make sure the code hasn\'t been used for attachment purposes before.  If the user is already in the contract, then we skip it.  Returns: - 201: Code successfully redeemed and user attached to new contract(s) - 200: Code valid but user already attached to all associated contracts - 404: Invalid or expired enrollment code - 409: Code valid but no available seats in associated contract(s) - list of ContractPageSerializer - the contracts for the user
         * @param {string} enrollment_code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        b2bAttachCreate: async (enrollment_code: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'enrollment_code' is not null or undefined
            assertParamExists('b2bAttachCreate', 'enrollment_code', enrollment_code)
            const localVarPath = `/api/v0/b2b/attach/{enrollment_code}/`
                .replace(`{${"enrollment_code"}}`, encodeURIComponent(String(enrollment_code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Viewset for the ContractPage model.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        b2bContractsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v0/b2b/contracts/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Viewset for the ContractPage model.
         * @param {string} contract_slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        b2bContractsRetrieve: async (contract_slug: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contract_slug' is not null or undefined
            assertParamExists('b2bContractsRetrieve', 'contract_slug', contract_slug)
            const localVarPath = `/api/v0/b2b/contracts/{contract_slug}/`
                .replace(`{${"contract_slug"}}`, encodeURIComponent(String(contract_slug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an enrollment for the given course run.
         * @param {string} readable_id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        b2bEnrollCreate: async (readable_id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'readable_id' is not null or undefined
            assertParamExists('b2bEnrollCreate', 'readable_id', readable_id)
            const localVarPath = `/api/v0/b2b/enroll/{readable_id}/`
                .replace(`{${"readable_id"}}`, encodeURIComponent(String(readable_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Viewset for the OrganizationPage model.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        b2bOrganizationsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v0/b2b/organizations/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Viewset for the OrganizationPage model.
         * @param {string} organization_slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        b2bOrganizationsRetrieve: async (organization_slug: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization_slug' is not null or undefined
            assertParamExists('b2bOrganizationsRetrieve', 'organization_slug', organization_slug)
            const localVarPath = `/api/v0/b2b/organizations/{organization_slug}/`
                .replace(`{${"organization_slug"}}`, encodeURIComponent(String(organization_slug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * B2bApi - functional programming interface
 * @export
 */
export const B2bApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = B2bApiAxiosParamCreator(configuration)
    return {
        /**
         * Use the provided enrollment code to attach the user to a B2B contract.  This will not create an order, nor will it enroll the user. It will attach the user to the contract and log that the code was used for this purpose (but will _not_ invalidate the code, since we\'re not actually using it at this point).  This will respect the activation and expiration dates (of both the contract and the discount), and will make sure there\'s sufficient available seats in the contract. It will also make sure the code hasn\'t been used for attachment purposes before.  If the user is already in the contract, then we skip it.  Returns: - 201: Code successfully redeemed and user attached to new contract(s) - 200: Code valid but user already attached to all associated contracts - 404: Invalid or expired enrollment code - 409: Code valid but no available seats in associated contract(s) - list of ContractPageSerializer - the contracts for the user
         * @param {string} enrollment_code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async b2bAttachCreate(enrollment_code: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ContractPage>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.b2bAttachCreate(enrollment_code, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['B2bApi.b2bAttachCreate']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Viewset for the ContractPage model.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async b2bContractsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ContractPage>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.b2bContractsList(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['B2bApi.b2bContractsList']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Viewset for the ContractPage model.
         * @param {string} contract_slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async b2bContractsRetrieve(contract_slug: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.b2bContractsRetrieve(contract_slug, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['B2bApi.b2bContractsRetrieve']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Create an enrollment for the given course run.
         * @param {string} readable_id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async b2bEnrollCreate(readable_id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateB2BEnrollment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.b2bEnrollCreate(readable_id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['B2bApi.b2bEnrollCreate']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Viewset for the OrganizationPage model.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async b2bOrganizationsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationPage>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.b2bOrganizationsList(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['B2bApi.b2bOrganizationsList']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Viewset for the OrganizationPage model.
         * @param {string} organization_slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async b2bOrganizationsRetrieve(organization_slug: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.b2bOrganizationsRetrieve(organization_slug, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['B2bApi.b2bOrganizationsRetrieve']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * B2bApi - factory interface
 * @export
 */
export const B2bApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = B2bApiFp(configuration)
    return {
        /**
         * Use the provided enrollment code to attach the user to a B2B contract.  This will not create an order, nor will it enroll the user. It will attach the user to the contract and log that the code was used for this purpose (but will _not_ invalidate the code, since we\'re not actually using it at this point).  This will respect the activation and expiration dates (of both the contract and the discount), and will make sure there\'s sufficient available seats in the contract. It will also make sure the code hasn\'t been used for attachment purposes before.  If the user is already in the contract, then we skip it.  Returns: - 201: Code successfully redeemed and user attached to new contract(s) - 200: Code valid but user already attached to all associated contracts - 404: Invalid or expired enrollment code - 409: Code valid but no available seats in associated contract(s) - list of ContractPageSerializer - the contracts for the user
         * @param {B2bApiB2bAttachCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        b2bAttachCreate(requestParameters: B2bApiB2bAttachCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<ContractPage>> {
            return localVarFp.b2bAttachCreate(requestParameters.enrollment_code, options).then((request) => request(axios, basePath));
        },
        /**
         * Viewset for the ContractPage model.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        b2bContractsList(options?: RawAxiosRequestConfig): AxiosPromise<Array<ContractPage>> {
            return localVarFp.b2bContractsList(options).then((request) => request(axios, basePath));
        },
        /**
         * Viewset for the ContractPage model.
         * @param {B2bApiB2bContractsRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        b2bContractsRetrieve(requestParameters: B2bApiB2bContractsRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContractPage> {
            return localVarFp.b2bContractsRetrieve(requestParameters.contract_slug, options).then((request) => request(axios, basePath));
        },
        /**
         * Create an enrollment for the given course run.
         * @param {B2bApiB2bEnrollCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        b2bEnrollCreate(requestParameters: B2bApiB2bEnrollCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateB2BEnrollment> {
            return localVarFp.b2bEnrollCreate(requestParameters.readable_id, options).then((request) => request(axios, basePath));
        },
        /**
         * Viewset for the OrganizationPage model.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        b2bOrganizationsList(options?: RawAxiosRequestConfig): AxiosPromise<Array<OrganizationPage>> {
            return localVarFp.b2bOrganizationsList(options).then((request) => request(axios, basePath));
        },
        /**
         * Viewset for the OrganizationPage model.
         * @param {B2bApiB2bOrganizationsRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        b2bOrganizationsRetrieve(requestParameters: B2bApiB2bOrganizationsRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<OrganizationPage> {
            return localVarFp.b2bOrganizationsRetrieve(requestParameters.organization_slug, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for b2bAttachCreate operation in B2bApi.
 * @export
 * @interface B2bApiB2bAttachCreateRequest
 */
export interface B2bApiB2bAttachCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof B2bApiB2bAttachCreate
     */
    readonly enrollment_code: string
}

/**
 * Request parameters for b2bContractsRetrieve operation in B2bApi.
 * @export
 * @interface B2bApiB2bContractsRetrieveRequest
 */
export interface B2bApiB2bContractsRetrieveRequest {
    /**
     * 
     * @type {string}
     * @memberof B2bApiB2bContractsRetrieve
     */
    readonly contract_slug: string
}

/**
 * Request parameters for b2bEnrollCreate operation in B2bApi.
 * @export
 * @interface B2bApiB2bEnrollCreateRequest
 */
export interface B2bApiB2bEnrollCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof B2bApiB2bEnrollCreate
     */
    readonly readable_id: string
}

/**
 * Request parameters for b2bOrganizationsRetrieve operation in B2bApi.
 * @export
 * @interface B2bApiB2bOrganizationsRetrieveRequest
 */
export interface B2bApiB2bOrganizationsRetrieveRequest {
    /**
     * 
     * @type {string}
     * @memberof B2bApiB2bOrganizationsRetrieve
     */
    readonly organization_slug: string
}

/**
 * B2bApi - object-oriented interface
 * @export
 * @class B2bApi
 * @extends {BaseAPI}
 */
export class B2bApi extends BaseAPI {
    /**
     * Use the provided enrollment code to attach the user to a B2B contract.  This will not create an order, nor will it enroll the user. It will attach the user to the contract and log that the code was used for this purpose (but will _not_ invalidate the code, since we\'re not actually using it at this point).  This will respect the activation and expiration dates (of both the contract and the discount), and will make sure there\'s sufficient available seats in the contract. It will also make sure the code hasn\'t been used for attachment purposes before.  If the user is already in the contract, then we skip it.  Returns: - 201: Code successfully redeemed and user attached to new contract(s) - 200: Code valid but user already attached to all associated contracts - 404: Invalid or expired enrollment code - 409: Code valid but no available seats in associated contract(s) - list of ContractPageSerializer - the contracts for the user
     * @param {B2bApiB2bAttachCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof B2bApi
     */
    public b2bAttachCreate(requestParameters: B2bApiB2bAttachCreateRequest, options?: RawAxiosRequestConfig) {
        return B2bApiFp(this.configuration).b2bAttachCreate(requestParameters.enrollment_code, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Viewset for the ContractPage model.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof B2bApi
     */
    public b2bContractsList(options?: RawAxiosRequestConfig) {
        return B2bApiFp(this.configuration).b2bContractsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Viewset for the ContractPage model.
     * @param {B2bApiB2bContractsRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof B2bApi
     */
    public b2bContractsRetrieve(requestParameters: B2bApiB2bContractsRetrieveRequest, options?: RawAxiosRequestConfig) {
        return B2bApiFp(this.configuration).b2bContractsRetrieve(requestParameters.contract_slug, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create an enrollment for the given course run.
     * @param {B2bApiB2bEnrollCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof B2bApi
     */
    public b2bEnrollCreate(requestParameters: B2bApiB2bEnrollCreateRequest, options?: RawAxiosRequestConfig) {
        return B2bApiFp(this.configuration).b2bEnrollCreate(requestParameters.readable_id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Viewset for the OrganizationPage model.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof B2bApi
     */
    public b2bOrganizationsList(options?: RawAxiosRequestConfig) {
        return B2bApiFp(this.configuration).b2bOrganizationsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Viewset for the OrganizationPage model.
     * @param {B2bApiB2bOrganizationsRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof B2bApi
     */
    public b2bOrganizationsRetrieve(requestParameters: B2bApiB2bOrganizationsRetrieveRequest, options?: RawAxiosRequestConfig) {
        return B2bApiFp(this.configuration).b2bOrganizationsRetrieve(requestParameters.organization_slug, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BasketsApi - axios parameter creator
 * @export
 */
export const BasketsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates or updates a basket for the current user, adding the discount if valid.
         * @param {string} discount_code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        basketsAddDiscountCreate: async (discount_code: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'discount_code' is not null or undefined
            assertParamExists('basketsAddDiscountCreate', 'discount_code', discount_code)
            const localVarPath = `/api/v0/baskets/add_discount/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (discount_code !== undefined) {
                localVarQueryParameter['discount_code'] = discount_code;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the payload necessary to redirect the user to CyberSource for payment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        basketsCheckoutRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v0/baskets/checkout/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Clears the basket for the current user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        basketsClearDestroy: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v0/baskets/clear/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates or updates a basket for the current user, adding the selected product.
         * @param {number} product_id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        basketsCreateFromProductCreate: async (product_id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'product_id' is not null or undefined
            assertParamExists('basketsCreateFromProductCreate', 'product_id', product_id)
            const localVarPath = `/api/v0/baskets/create_from_product/{product_id}/`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(product_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates or updates a basket for the current user, adding the selected product.
         * @param {CreateBasketWithProductsRequest} CreateBasketWithProductsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        basketsCreateWithProductsCreate: async (CreateBasketWithProductsRequest: CreateBasketWithProductsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'CreateBasketWithProductsRequest' is not null or undefined
            assertParamExists('basketsCreateWithProductsCreate', 'CreateBasketWithProductsRequest', CreateBasketWithProductsRequest)
            const localVarPath = `/api/v0/baskets/create_with_products/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(CreateBasketWithProductsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the basket items for the current user.
         * @param {number} id ID of the basket item
         * @param {number} parent_lookup_basket ID of the parent basket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        basketsItemsCreate: async (id: number, parent_lookup_basket: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('basketsItemsCreate', 'id', id)
            // verify required parameter 'parent_lookup_basket' is not null or undefined
            assertParamExists('basketsItemsCreate', 'parent_lookup_basket', parent_lookup_basket)
            const localVarPath = `/api/v0/baskets/{parent_lookup_basket}/items/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"parent_lookup_basket"}}`, encodeURIComponent(String(parent_lookup_basket)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the basket items for the current user.
         * @param {number} id ID of the basket item
         * @param {number} parent_lookup_basket ID of the parent basket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        basketsItemsDestroy: async (id: number, parent_lookup_basket: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('basketsItemsDestroy', 'id', id)
            // verify required parameter 'parent_lookup_basket' is not null or undefined
            assertParamExists('basketsItemsDestroy', 'parent_lookup_basket', parent_lookup_basket)
            const localVarPath = `/api/v0/baskets/{parent_lookup_basket}/items/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"parent_lookup_basket"}}`, encodeURIComponent(String(parent_lookup_basket)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the basket items for the current user.
         * @param {number} id ID of the basket item
         * @param {number} parent_lookup_basket ID of the parent basket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        basketsItemsList: async (id: number, parent_lookup_basket: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('basketsItemsList', 'id', id)
            // verify required parameter 'parent_lookup_basket' is not null or undefined
            assertParamExists('basketsItemsList', 'parent_lookup_basket', parent_lookup_basket)
            const localVarPath = `/api/v0/baskets/{parent_lookup_basket}/items/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"parent_lookup_basket"}}`, encodeURIComponent(String(parent_lookup_basket)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the basket items for the current user.
         * @param {number} id ID of the basket item
         * @param {number} parent_lookup_basket ID of the parent basket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        basketsItemsPartialUpdate: async (id: number, parent_lookup_basket: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('basketsItemsPartialUpdate', 'id', id)
            // verify required parameter 'parent_lookup_basket' is not null or undefined
            assertParamExists('basketsItemsPartialUpdate', 'parent_lookup_basket', parent_lookup_basket)
            const localVarPath = `/api/v0/baskets/{parent_lookup_basket}/items/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"parent_lookup_basket"}}`, encodeURIComponent(String(parent_lookup_basket)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the basket items for the current user.
         * @param {number} id ID of the basket item
         * @param {number} parent_lookup_basket ID of the parent basket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        basketsItemsRetrieve: async (id: number, parent_lookup_basket: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('basketsItemsRetrieve', 'id', id)
            // verify required parameter 'parent_lookup_basket' is not null or undefined
            assertParamExists('basketsItemsRetrieve', 'parent_lookup_basket', parent_lookup_basket)
            const localVarPath = `/api/v0/baskets/{parent_lookup_basket}/items/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"parent_lookup_basket"}}`, encodeURIComponent(String(parent_lookup_basket)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the basket items for the current user.
         * @param {number} id ID of the basket item
         * @param {number} parent_lookup_basket ID of the parent basket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        basketsItemsUpdate: async (id: number, parent_lookup_basket: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('basketsItemsUpdate', 'id', id)
            // verify required parameter 'parent_lookup_basket' is not null or undefined
            assertParamExists('basketsItemsUpdate', 'parent_lookup_basket', parent_lookup_basket)
            const localVarPath = `/api/v0/baskets/{parent_lookup_basket}/items/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"parent_lookup_basket"}}`, encodeURIComponent(String(parent_lookup_basket)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrives the current user\'s baskets.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        basketsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v0/baskets/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a basket for the current user.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        basketsRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('basketsRetrieve', 'id', id)
            const localVarPath = `/api/v0/baskets/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates or updates a basket for the current user, adding the selected product and discount.
         * @param {string} discount_code 
         * @param {number} product_id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBasketFromProductWithDiscount: async (discount_code: string, product_id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'discount_code' is not null or undefined
            assertParamExists('createBasketFromProductWithDiscount', 'discount_code', discount_code)
            // verify required parameter 'product_id' is not null or undefined
            assertParamExists('createBasketFromProductWithDiscount', 'product_id', product_id)
            const localVarPath = `/api/v0/baskets/create_from_product/{product_id}/{discount_code}/`
                .replace(`{${"discount_code"}}`, encodeURIComponent(String(discount_code)))
                .replace(`{${"product_id"}}`, encodeURIComponent(String(product_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BasketsApi - functional programming interface
 * @export
 */
export const BasketsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BasketsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates or updates a basket for the current user, adding the discount if valid.
         * @param {string} discount_code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async basketsAddDiscountCreate(discount_code: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BasketWithProduct>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.basketsAddDiscountCreate(discount_code, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['BasketsApi.basketsAddDiscountCreate']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Returns the payload necessary to redirect the user to CyberSource for payment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async basketsCheckoutRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckoutPayload>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.basketsCheckoutRetrieve(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['BasketsApi.basketsCheckoutRetrieve']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Clears the basket for the current user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async basketsClearDestroy(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.basketsClearDestroy(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['BasketsApi.basketsClearDestroy']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Creates or updates a basket for the current user, adding the selected product.
         * @param {number} product_id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async basketsCreateFromProductCreate(product_id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BasketWithProduct>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.basketsCreateFromProductCreate(product_id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['BasketsApi.basketsCreateFromProductCreate']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Creates or updates a basket for the current user, adding the selected product.
         * @param {CreateBasketWithProductsRequest} CreateBasketWithProductsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async basketsCreateWithProductsCreate(CreateBasketWithProductsRequest: CreateBasketWithProductsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BasketWithProduct>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.basketsCreateWithProductsCreate(CreateBasketWithProductsRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['BasketsApi.basketsCreateWithProductsCreate']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Returns the basket items for the current user.
         * @param {number} id ID of the basket item
         * @param {number} parent_lookup_basket ID of the parent basket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async basketsItemsCreate(id: number, parent_lookup_basket: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BasketItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.basketsItemsCreate(id, parent_lookup_basket, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['BasketsApi.basketsItemsCreate']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Returns the basket items for the current user.
         * @param {number} id ID of the basket item
         * @param {number} parent_lookup_basket ID of the parent basket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async basketsItemsDestroy(id: number, parent_lookup_basket: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.basketsItemsDestroy(id, parent_lookup_basket, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['BasketsApi.basketsItemsDestroy']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Returns the basket items for the current user.
         * @param {number} id ID of the basket item
         * @param {number} parent_lookup_basket ID of the parent basket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async basketsItemsList(id: number, parent_lookup_basket: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BasketItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.basketsItemsList(id, parent_lookup_basket, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['BasketsApi.basketsItemsList']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Returns the basket items for the current user.
         * @param {number} id ID of the basket item
         * @param {number} parent_lookup_basket ID of the parent basket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async basketsItemsPartialUpdate(id: number, parent_lookup_basket: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BasketItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.basketsItemsPartialUpdate(id, parent_lookup_basket, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['BasketsApi.basketsItemsPartialUpdate']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Returns the basket items for the current user.
         * @param {number} id ID of the basket item
         * @param {number} parent_lookup_basket ID of the parent basket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async basketsItemsRetrieve(id: number, parent_lookup_basket: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BasketItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.basketsItemsRetrieve(id, parent_lookup_basket, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['BasketsApi.basketsItemsRetrieve']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Returns the basket items for the current user.
         * @param {number} id ID of the basket item
         * @param {number} parent_lookup_basket ID of the parent basket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async basketsItemsUpdate(id: number, parent_lookup_basket: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BasketItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.basketsItemsUpdate(id, parent_lookup_basket, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['BasketsApi.basketsItemsUpdate']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Retrives the current user\'s baskets.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async basketsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BasketWithProduct>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.basketsList(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['BasketsApi.basketsList']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Retrieve a basket for the current user.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async basketsRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BasketWithProduct>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.basketsRetrieve(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['BasketsApi.basketsRetrieve']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Creates or updates a basket for the current user, adding the selected product and discount.
         * @param {string} discount_code 
         * @param {number} product_id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBasketFromProductWithDiscount(discount_code: string, product_id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BasketWithProduct>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBasketFromProductWithDiscount(discount_code, product_id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['BasketsApi.createBasketFromProductWithDiscount']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * BasketsApi - factory interface
 * @export
 */
export const BasketsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BasketsApiFp(configuration)
    return {
        /**
         * Creates or updates a basket for the current user, adding the discount if valid.
         * @param {BasketsApiBasketsAddDiscountCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        basketsAddDiscountCreate(requestParameters: BasketsApiBasketsAddDiscountCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<BasketWithProduct> {
            return localVarFp.basketsAddDiscountCreate(requestParameters.discount_code, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the payload necessary to redirect the user to CyberSource for payment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        basketsCheckoutRetrieve(options?: RawAxiosRequestConfig): AxiosPromise<CheckoutPayload> {
            return localVarFp.basketsCheckoutRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * Clears the basket for the current user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        basketsClearDestroy(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.basketsClearDestroy(options).then((request) => request(axios, basePath));
        },
        /**
         * Creates or updates a basket for the current user, adding the selected product.
         * @param {BasketsApiBasketsCreateFromProductCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        basketsCreateFromProductCreate(requestParameters: BasketsApiBasketsCreateFromProductCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<BasketWithProduct> {
            return localVarFp.basketsCreateFromProductCreate(requestParameters.product_id, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates or updates a basket for the current user, adding the selected product.
         * @param {BasketsApiBasketsCreateWithProductsCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        basketsCreateWithProductsCreate(requestParameters: BasketsApiBasketsCreateWithProductsCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<BasketWithProduct> {
            return localVarFp.basketsCreateWithProductsCreate(requestParameters.CreateBasketWithProductsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the basket items for the current user.
         * @param {BasketsApiBasketsItemsCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        basketsItemsCreate(requestParameters: BasketsApiBasketsItemsCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<BasketItem> {
            return localVarFp.basketsItemsCreate(requestParameters.id, requestParameters.parent_lookup_basket, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the basket items for the current user.
         * @param {BasketsApiBasketsItemsDestroyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        basketsItemsDestroy(requestParameters: BasketsApiBasketsItemsDestroyRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.basketsItemsDestroy(requestParameters.id, requestParameters.parent_lookup_basket, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the basket items for the current user.
         * @param {BasketsApiBasketsItemsListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        basketsItemsList(requestParameters: BasketsApiBasketsItemsListRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<BasketItem>> {
            return localVarFp.basketsItemsList(requestParameters.id, requestParameters.parent_lookup_basket, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the basket items for the current user.
         * @param {BasketsApiBasketsItemsPartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        basketsItemsPartialUpdate(requestParameters: BasketsApiBasketsItemsPartialUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<BasketItem> {
            return localVarFp.basketsItemsPartialUpdate(requestParameters.id, requestParameters.parent_lookup_basket, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the basket items for the current user.
         * @param {BasketsApiBasketsItemsRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        basketsItemsRetrieve(requestParameters: BasketsApiBasketsItemsRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<BasketItem> {
            return localVarFp.basketsItemsRetrieve(requestParameters.id, requestParameters.parent_lookup_basket, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the basket items for the current user.
         * @param {BasketsApiBasketsItemsUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        basketsItemsUpdate(requestParameters: BasketsApiBasketsItemsUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<BasketItem> {
            return localVarFp.basketsItemsUpdate(requestParameters.id, requestParameters.parent_lookup_basket, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrives the current user\'s baskets.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        basketsList(options?: RawAxiosRequestConfig): AxiosPromise<Array<BasketWithProduct>> {
            return localVarFp.basketsList(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a basket for the current user.
         * @param {BasketsApiBasketsRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        basketsRetrieve(requestParameters: BasketsApiBasketsRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<BasketWithProduct> {
            return localVarFp.basketsRetrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates or updates a basket for the current user, adding the selected product and discount.
         * @param {BasketsApiCreateBasketFromProductWithDiscountRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBasketFromProductWithDiscount(requestParameters: BasketsApiCreateBasketFromProductWithDiscountRequest, options?: RawAxiosRequestConfig): AxiosPromise<BasketWithProduct> {
            return localVarFp.createBasketFromProductWithDiscount(requestParameters.discount_code, requestParameters.product_id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for basketsAddDiscountCreate operation in BasketsApi.
 * @export
 * @interface BasketsApiBasketsAddDiscountCreateRequest
 */
export interface BasketsApiBasketsAddDiscountCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof BasketsApiBasketsAddDiscountCreate
     */
    readonly discount_code: string
}

/**
 * Request parameters for basketsCreateFromProductCreate operation in BasketsApi.
 * @export
 * @interface BasketsApiBasketsCreateFromProductCreateRequest
 */
export interface BasketsApiBasketsCreateFromProductCreateRequest {
    /**
     * 
     * @type {number}
     * @memberof BasketsApiBasketsCreateFromProductCreate
     */
    readonly product_id: number
}

/**
 * Request parameters for basketsCreateWithProductsCreate operation in BasketsApi.
 * @export
 * @interface BasketsApiBasketsCreateWithProductsCreateRequest
 */
export interface BasketsApiBasketsCreateWithProductsCreateRequest {
    /**
     * 
     * @type {CreateBasketWithProductsRequest}
     * @memberof BasketsApiBasketsCreateWithProductsCreate
     */
    readonly CreateBasketWithProductsRequest: CreateBasketWithProductsRequest
}

/**
 * Request parameters for basketsItemsCreate operation in BasketsApi.
 * @export
 * @interface BasketsApiBasketsItemsCreateRequest
 */
export interface BasketsApiBasketsItemsCreateRequest {
    /**
     * ID of the basket item
     * @type {number}
     * @memberof BasketsApiBasketsItemsCreate
     */
    readonly id: number

    /**
     * ID of the parent basket
     * @type {number}
     * @memberof BasketsApiBasketsItemsCreate
     */
    readonly parent_lookup_basket: number
}

/**
 * Request parameters for basketsItemsDestroy operation in BasketsApi.
 * @export
 * @interface BasketsApiBasketsItemsDestroyRequest
 */
export interface BasketsApiBasketsItemsDestroyRequest {
    /**
     * ID of the basket item
     * @type {number}
     * @memberof BasketsApiBasketsItemsDestroy
     */
    readonly id: number

    /**
     * ID of the parent basket
     * @type {number}
     * @memberof BasketsApiBasketsItemsDestroy
     */
    readonly parent_lookup_basket: number
}

/**
 * Request parameters for basketsItemsList operation in BasketsApi.
 * @export
 * @interface BasketsApiBasketsItemsListRequest
 */
export interface BasketsApiBasketsItemsListRequest {
    /**
     * ID of the basket item
     * @type {number}
     * @memberof BasketsApiBasketsItemsList
     */
    readonly id: number

    /**
     * ID of the parent basket
     * @type {number}
     * @memberof BasketsApiBasketsItemsList
     */
    readonly parent_lookup_basket: number
}

/**
 * Request parameters for basketsItemsPartialUpdate operation in BasketsApi.
 * @export
 * @interface BasketsApiBasketsItemsPartialUpdateRequest
 */
export interface BasketsApiBasketsItemsPartialUpdateRequest {
    /**
     * ID of the basket item
     * @type {number}
     * @memberof BasketsApiBasketsItemsPartialUpdate
     */
    readonly id: number

    /**
     * ID of the parent basket
     * @type {number}
     * @memberof BasketsApiBasketsItemsPartialUpdate
     */
    readonly parent_lookup_basket: number
}

/**
 * Request parameters for basketsItemsRetrieve operation in BasketsApi.
 * @export
 * @interface BasketsApiBasketsItemsRetrieveRequest
 */
export interface BasketsApiBasketsItemsRetrieveRequest {
    /**
     * ID of the basket item
     * @type {number}
     * @memberof BasketsApiBasketsItemsRetrieve
     */
    readonly id: number

    /**
     * ID of the parent basket
     * @type {number}
     * @memberof BasketsApiBasketsItemsRetrieve
     */
    readonly parent_lookup_basket: number
}

/**
 * Request parameters for basketsItemsUpdate operation in BasketsApi.
 * @export
 * @interface BasketsApiBasketsItemsUpdateRequest
 */
export interface BasketsApiBasketsItemsUpdateRequest {
    /**
     * ID of the basket item
     * @type {number}
     * @memberof BasketsApiBasketsItemsUpdate
     */
    readonly id: number

    /**
     * ID of the parent basket
     * @type {number}
     * @memberof BasketsApiBasketsItemsUpdate
     */
    readonly parent_lookup_basket: number
}

/**
 * Request parameters for basketsRetrieve operation in BasketsApi.
 * @export
 * @interface BasketsApiBasketsRetrieveRequest
 */
export interface BasketsApiBasketsRetrieveRequest {
    /**
     * 
     * @type {number}
     * @memberof BasketsApiBasketsRetrieve
     */
    readonly id: number
}

/**
 * Request parameters for createBasketFromProductWithDiscount operation in BasketsApi.
 * @export
 * @interface BasketsApiCreateBasketFromProductWithDiscountRequest
 */
export interface BasketsApiCreateBasketFromProductWithDiscountRequest {
    /**
     * 
     * @type {string}
     * @memberof BasketsApiCreateBasketFromProductWithDiscount
     */
    readonly discount_code: string

    /**
     * 
     * @type {number}
     * @memberof BasketsApiCreateBasketFromProductWithDiscount
     */
    readonly product_id: number
}

/**
 * BasketsApi - object-oriented interface
 * @export
 * @class BasketsApi
 * @extends {BaseAPI}
 */
export class BasketsApi extends BaseAPI {
    /**
     * Creates or updates a basket for the current user, adding the discount if valid.
     * @param {BasketsApiBasketsAddDiscountCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    public basketsAddDiscountCreate(requestParameters: BasketsApiBasketsAddDiscountCreateRequest, options?: RawAxiosRequestConfig) {
        return BasketsApiFp(this.configuration).basketsAddDiscountCreate(requestParameters.discount_code, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the payload necessary to redirect the user to CyberSource for payment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    public basketsCheckoutRetrieve(options?: RawAxiosRequestConfig) {
        return BasketsApiFp(this.configuration).basketsCheckoutRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Clears the basket for the current user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    public basketsClearDestroy(options?: RawAxiosRequestConfig) {
        return BasketsApiFp(this.configuration).basketsClearDestroy(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates or updates a basket for the current user, adding the selected product.
     * @param {BasketsApiBasketsCreateFromProductCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    public basketsCreateFromProductCreate(requestParameters: BasketsApiBasketsCreateFromProductCreateRequest, options?: RawAxiosRequestConfig) {
        return BasketsApiFp(this.configuration).basketsCreateFromProductCreate(requestParameters.product_id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates or updates a basket for the current user, adding the selected product.
     * @param {BasketsApiBasketsCreateWithProductsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    public basketsCreateWithProductsCreate(requestParameters: BasketsApiBasketsCreateWithProductsCreateRequest, options?: RawAxiosRequestConfig) {
        return BasketsApiFp(this.configuration).basketsCreateWithProductsCreate(requestParameters.CreateBasketWithProductsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the basket items for the current user.
     * @param {BasketsApiBasketsItemsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    public basketsItemsCreate(requestParameters: BasketsApiBasketsItemsCreateRequest, options?: RawAxiosRequestConfig) {
        return BasketsApiFp(this.configuration).basketsItemsCreate(requestParameters.id, requestParameters.parent_lookup_basket, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the basket items for the current user.
     * @param {BasketsApiBasketsItemsDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    public basketsItemsDestroy(requestParameters: BasketsApiBasketsItemsDestroyRequest, options?: RawAxiosRequestConfig) {
        return BasketsApiFp(this.configuration).basketsItemsDestroy(requestParameters.id, requestParameters.parent_lookup_basket, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the basket items for the current user.
     * @param {BasketsApiBasketsItemsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    public basketsItemsList(requestParameters: BasketsApiBasketsItemsListRequest, options?: RawAxiosRequestConfig) {
        return BasketsApiFp(this.configuration).basketsItemsList(requestParameters.id, requestParameters.parent_lookup_basket, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the basket items for the current user.
     * @param {BasketsApiBasketsItemsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    public basketsItemsPartialUpdate(requestParameters: BasketsApiBasketsItemsPartialUpdateRequest, options?: RawAxiosRequestConfig) {
        return BasketsApiFp(this.configuration).basketsItemsPartialUpdate(requestParameters.id, requestParameters.parent_lookup_basket, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the basket items for the current user.
     * @param {BasketsApiBasketsItemsRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    public basketsItemsRetrieve(requestParameters: BasketsApiBasketsItemsRetrieveRequest, options?: RawAxiosRequestConfig) {
        return BasketsApiFp(this.configuration).basketsItemsRetrieve(requestParameters.id, requestParameters.parent_lookup_basket, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the basket items for the current user.
     * @param {BasketsApiBasketsItemsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    public basketsItemsUpdate(requestParameters: BasketsApiBasketsItemsUpdateRequest, options?: RawAxiosRequestConfig) {
        return BasketsApiFp(this.configuration).basketsItemsUpdate(requestParameters.id, requestParameters.parent_lookup_basket, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrives the current user\'s baskets.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    public basketsList(options?: RawAxiosRequestConfig) {
        return BasketsApiFp(this.configuration).basketsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a basket for the current user.
     * @param {BasketsApiBasketsRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    public basketsRetrieve(requestParameters: BasketsApiBasketsRetrieveRequest, options?: RawAxiosRequestConfig) {
        return BasketsApiFp(this.configuration).basketsRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates or updates a basket for the current user, adding the selected product and discount.
     * @param {BasketsApiCreateBasketFromProductWithDiscountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    public createBasketFromProductWithDiscount(requestParameters: BasketsApiCreateBasketFromProductWithDiscountRequest, options?: RawAxiosRequestConfig) {
        return BasketsApiFp(this.configuration).createBasketFromProductWithDiscount(requestParameters.discount_code, requestParameters.product_id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ChangeEmailsApi - axios parameter creator
 * @export
 */
export const ChangeEmailsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Viewset for creating and updating email change requests
         * @param {ChangeEmailRequestCreateRequest} ChangeEmailRequestCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeEmailsCreate: async (ChangeEmailRequestCreateRequest: ChangeEmailRequestCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ChangeEmailRequestCreateRequest' is not null or undefined
            assertParamExists('changeEmailsCreate', 'ChangeEmailRequestCreateRequest', ChangeEmailRequestCreateRequest)
            const localVarPath = `/api/v0/change-emails/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ChangeEmailRequestCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Viewset for creating and updating email change requests
         * @param {string} code 
         * @param {PatchedChangeEmailRequestUpdateRequest} [PatchedChangeEmailRequestUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeEmailsPartialUpdate: async (code: string, PatchedChangeEmailRequestUpdateRequest?: PatchedChangeEmailRequestUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('changeEmailsPartialUpdate', 'code', code)
            const localVarPath = `/api/v0/change-emails/{code}/`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(PatchedChangeEmailRequestUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Viewset for creating and updating email change requests
         * @param {string} code 
         * @param {ChangeEmailRequestUpdateRequest} ChangeEmailRequestUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeEmailsUpdate: async (code: string, ChangeEmailRequestUpdateRequest: ChangeEmailRequestUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('changeEmailsUpdate', 'code', code)
            // verify required parameter 'ChangeEmailRequestUpdateRequest' is not null or undefined
            assertParamExists('changeEmailsUpdate', 'ChangeEmailRequestUpdateRequest', ChangeEmailRequestUpdateRequest)
            const localVarPath = `/api/v0/change-emails/{code}/`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ChangeEmailRequestUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChangeEmailsApi - functional programming interface
 * @export
 */
export const ChangeEmailsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ChangeEmailsApiAxiosParamCreator(configuration)
    return {
        /**
         * Viewset for creating and updating email change requests
         * @param {ChangeEmailRequestCreateRequest} ChangeEmailRequestCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeEmailsCreate(ChangeEmailRequestCreateRequest: ChangeEmailRequestCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChangeEmailRequestCreate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeEmailsCreate(ChangeEmailRequestCreateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ChangeEmailsApi.changeEmailsCreate']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Viewset for creating and updating email change requests
         * @param {string} code 
         * @param {PatchedChangeEmailRequestUpdateRequest} [PatchedChangeEmailRequestUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeEmailsPartialUpdate(code: string, PatchedChangeEmailRequestUpdateRequest?: PatchedChangeEmailRequestUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChangeEmailRequestUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeEmailsPartialUpdate(code, PatchedChangeEmailRequestUpdateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ChangeEmailsApi.changeEmailsPartialUpdate']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Viewset for creating and updating email change requests
         * @param {string} code 
         * @param {ChangeEmailRequestUpdateRequest} ChangeEmailRequestUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeEmailsUpdate(code: string, ChangeEmailRequestUpdateRequest: ChangeEmailRequestUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChangeEmailRequestUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeEmailsUpdate(code, ChangeEmailRequestUpdateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ChangeEmailsApi.changeEmailsUpdate']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * ChangeEmailsApi - factory interface
 * @export
 */
export const ChangeEmailsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ChangeEmailsApiFp(configuration)
    return {
        /**
         * Viewset for creating and updating email change requests
         * @param {ChangeEmailsApiChangeEmailsCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeEmailsCreate(requestParameters: ChangeEmailsApiChangeEmailsCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ChangeEmailRequestCreate> {
            return localVarFp.changeEmailsCreate(requestParameters.ChangeEmailRequestCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Viewset for creating and updating email change requests
         * @param {ChangeEmailsApiChangeEmailsPartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeEmailsPartialUpdate(requestParameters: ChangeEmailsApiChangeEmailsPartialUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ChangeEmailRequestUpdate> {
            return localVarFp.changeEmailsPartialUpdate(requestParameters.code, requestParameters.PatchedChangeEmailRequestUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Viewset for creating and updating email change requests
         * @param {ChangeEmailsApiChangeEmailsUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeEmailsUpdate(requestParameters: ChangeEmailsApiChangeEmailsUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ChangeEmailRequestUpdate> {
            return localVarFp.changeEmailsUpdate(requestParameters.code, requestParameters.ChangeEmailRequestUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for changeEmailsCreate operation in ChangeEmailsApi.
 * @export
 * @interface ChangeEmailsApiChangeEmailsCreateRequest
 */
export interface ChangeEmailsApiChangeEmailsCreateRequest {
    /**
     * 
     * @type {ChangeEmailRequestCreateRequest}
     * @memberof ChangeEmailsApiChangeEmailsCreate
     */
    readonly ChangeEmailRequestCreateRequest: ChangeEmailRequestCreateRequest
}

/**
 * Request parameters for changeEmailsPartialUpdate operation in ChangeEmailsApi.
 * @export
 * @interface ChangeEmailsApiChangeEmailsPartialUpdateRequest
 */
export interface ChangeEmailsApiChangeEmailsPartialUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof ChangeEmailsApiChangeEmailsPartialUpdate
     */
    readonly code: string

    /**
     * 
     * @type {PatchedChangeEmailRequestUpdateRequest}
     * @memberof ChangeEmailsApiChangeEmailsPartialUpdate
     */
    readonly PatchedChangeEmailRequestUpdateRequest?: PatchedChangeEmailRequestUpdateRequest
}

/**
 * Request parameters for changeEmailsUpdate operation in ChangeEmailsApi.
 * @export
 * @interface ChangeEmailsApiChangeEmailsUpdateRequest
 */
export interface ChangeEmailsApiChangeEmailsUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof ChangeEmailsApiChangeEmailsUpdate
     */
    readonly code: string

    /**
     * 
     * @type {ChangeEmailRequestUpdateRequest}
     * @memberof ChangeEmailsApiChangeEmailsUpdate
     */
    readonly ChangeEmailRequestUpdateRequest: ChangeEmailRequestUpdateRequest
}

/**
 * ChangeEmailsApi - object-oriented interface
 * @export
 * @class ChangeEmailsApi
 * @extends {BaseAPI}
 */
export class ChangeEmailsApi extends BaseAPI {
    /**
     * Viewset for creating and updating email change requests
     * @param {ChangeEmailsApiChangeEmailsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChangeEmailsApi
     */
    public changeEmailsCreate(requestParameters: ChangeEmailsApiChangeEmailsCreateRequest, options?: RawAxiosRequestConfig) {
        return ChangeEmailsApiFp(this.configuration).changeEmailsCreate(requestParameters.ChangeEmailRequestCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Viewset for creating and updating email change requests
     * @param {ChangeEmailsApiChangeEmailsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChangeEmailsApi
     */
    public changeEmailsPartialUpdate(requestParameters: ChangeEmailsApiChangeEmailsPartialUpdateRequest, options?: RawAxiosRequestConfig) {
        return ChangeEmailsApiFp(this.configuration).changeEmailsPartialUpdate(requestParameters.code, requestParameters.PatchedChangeEmailRequestUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Viewset for creating and updating email change requests
     * @param {ChangeEmailsApiChangeEmailsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChangeEmailsApi
     */
    public changeEmailsUpdate(requestParameters: ChangeEmailsApiChangeEmailsUpdateRequest, options?: RawAxiosRequestConfig) {
        return ChangeEmailsApiFp(this.configuration).changeEmailsUpdate(requestParameters.code, requestParameters.ChangeEmailRequestUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CountriesApi - axios parameter creator
 * @export
 */
export const CountriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get generator for countries/states list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countriesList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v0/countries/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CountriesApi - functional programming interface
 * @export
 */
export const CountriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CountriesApiAxiosParamCreator(configuration)
    return {
        /**
         * Get generator for countries/states list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countriesList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Country>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countriesList(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CountriesApi.countriesList']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * CountriesApi - factory interface
 * @export
 */
export const CountriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CountriesApiFp(configuration)
    return {
        /**
         * Get generator for countries/states list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countriesList(options?: RawAxiosRequestConfig): AxiosPromise<Array<Country>> {
            return localVarFp.countriesList(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CountriesApi - object-oriented interface
 * @export
 * @class CountriesApi
 * @extends {BaseAPI}
 */
export class CountriesApi extends BaseAPI {
    /**
     * Get generator for countries/states list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CountriesApi
     */
    public countriesList(options?: RawAxiosRequestConfig) {
        return CountriesApiFp(this.configuration).countriesList(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CourseCertificatesApi - axios parameter creator
 * @export
 */
export const CourseCertificatesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a course certificate by UUID.
         * @param {string} cert_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseCertificatesRetrieve: async (cert_uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cert_uuid' is not null or undefined
            assertParamExists('courseCertificatesRetrieve', 'cert_uuid', cert_uuid)
            const localVarPath = `/api/v2/course_certificates/{cert_uuid}/`
                .replace(`{${"cert_uuid"}}`, encodeURIComponent(String(cert_uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CourseCertificatesApi - functional programming interface
 * @export
 */
export const CourseCertificatesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CourseCertificatesApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a course certificate by UUID.
         * @param {string} cert_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async courseCertificatesRetrieve(cert_uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V2CourseRunCertificate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.courseCertificatesRetrieve(cert_uuid, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CourseCertificatesApi.courseCertificatesRetrieve']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * CourseCertificatesApi - factory interface
 * @export
 */
export const CourseCertificatesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CourseCertificatesApiFp(configuration)
    return {
        /**
         * Get a course certificate by UUID.
         * @param {CourseCertificatesApiCourseCertificatesRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseCertificatesRetrieve(requestParameters: CourseCertificatesApiCourseCertificatesRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<V2CourseRunCertificate> {
            return localVarFp.courseCertificatesRetrieve(requestParameters.cert_uuid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for courseCertificatesRetrieve operation in CourseCertificatesApi.
 * @export
 * @interface CourseCertificatesApiCourseCertificatesRetrieveRequest
 */
export interface CourseCertificatesApiCourseCertificatesRetrieveRequest {
    /**
     * 
     * @type {string}
     * @memberof CourseCertificatesApiCourseCertificatesRetrieve
     */
    readonly cert_uuid: string
}

/**
 * CourseCertificatesApi - object-oriented interface
 * @export
 * @class CourseCertificatesApi
 * @extends {BaseAPI}
 */
export class CourseCertificatesApi extends BaseAPI {
    /**
     * Get a course certificate by UUID.
     * @param {CourseCertificatesApiCourseCertificatesRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseCertificatesApi
     */
    public courseCertificatesRetrieve(requestParameters: CourseCertificatesApiCourseCertificatesRetrieveRequest, options?: RawAxiosRequestConfig) {
        return CourseCertificatesApiFp(this.configuration).courseCertificatesRetrieve(requestParameters.cert_uuid, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CourseRunsApi - axios parameter creator
 * @export
 */
export const CourseRunsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * API view set for CourseRuns
         * @param {number} [id] 
         * @param {boolean} [live] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseRunsList: async (id?: number, live?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/course_runs/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (live !== undefined) {
                localVarQueryParameter['live'] = live;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API view set for CourseRuns
         * @param {number} id A unique integer value identifying this course run.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseRunsRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('courseRunsRetrieve', 'id', id)
            const localVarPath = `/api/v1/course_runs/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CourseRunsApi - functional programming interface
 * @export
 */
export const CourseRunsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CourseRunsApiAxiosParamCreator(configuration)
    return {
        /**
         * API view set for CourseRuns
         * @param {number} [id] 
         * @param {boolean} [live] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async courseRunsList(id?: number, live?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<V1CourseRunWithCourse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.courseRunsList(id, live, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CourseRunsApi.courseRunsList']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * API view set for CourseRuns
         * @param {number} id A unique integer value identifying this course run.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async courseRunsRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1CourseRunWithCourse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.courseRunsRetrieve(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CourseRunsApi.courseRunsRetrieve']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * CourseRunsApi - factory interface
 * @export
 */
export const CourseRunsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CourseRunsApiFp(configuration)
    return {
        /**
         * API view set for CourseRuns
         * @param {CourseRunsApiCourseRunsListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseRunsList(requestParameters: CourseRunsApiCourseRunsListRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<Array<V1CourseRunWithCourse>> {
            return localVarFp.courseRunsList(requestParameters.id, requestParameters.live, options).then((request) => request(axios, basePath));
        },
        /**
         * API view set for CourseRuns
         * @param {CourseRunsApiCourseRunsRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseRunsRetrieve(requestParameters: CourseRunsApiCourseRunsRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<V1CourseRunWithCourse> {
            return localVarFp.courseRunsRetrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for courseRunsList operation in CourseRunsApi.
 * @export
 * @interface CourseRunsApiCourseRunsListRequest
 */
export interface CourseRunsApiCourseRunsListRequest {
    /**
     * 
     * @type {number}
     * @memberof CourseRunsApiCourseRunsList
     */
    readonly id?: number

    /**
     * 
     * @type {boolean}
     * @memberof CourseRunsApiCourseRunsList
     */
    readonly live?: boolean
}

/**
 * Request parameters for courseRunsRetrieve operation in CourseRunsApi.
 * @export
 * @interface CourseRunsApiCourseRunsRetrieveRequest
 */
export interface CourseRunsApiCourseRunsRetrieveRequest {
    /**
     * A unique integer value identifying this course run.
     * @type {number}
     * @memberof CourseRunsApiCourseRunsRetrieve
     */
    readonly id: number
}

/**
 * CourseRunsApi - object-oriented interface
 * @export
 * @class CourseRunsApi
 * @extends {BaseAPI}
 */
export class CourseRunsApi extends BaseAPI {
    /**
     * API view set for CourseRuns
     * @param {CourseRunsApiCourseRunsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseRunsApi
     */
    public courseRunsList(requestParameters: CourseRunsApiCourseRunsListRequest = {}, options?: RawAxiosRequestConfig) {
        return CourseRunsApiFp(this.configuration).courseRunsList(requestParameters.id, requestParameters.live, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API view set for CourseRuns
     * @param {CourseRunsApiCourseRunsRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseRunsApi
     */
    public courseRunsRetrieve(requestParameters: CourseRunsApiCourseRunsRetrieveRequest, options?: RawAxiosRequestConfig) {
        return CourseRunsApiFp(this.configuration).courseRunsRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CoursesApi - axios parameter creator
 * @export
 */
export const CoursesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List all courses - API v1
         * @param {boolean} [courserun_is_enrollable] 
         * @param {number} [id] 
         * @param {boolean} [live] 
         * @param {number} [page] A page number within the paginated result set.
         * @param {boolean} [page__live] 
         * @param {number} [page_size] Number of results to return per page.
         * @param {string} [readable_id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1CoursesList: async (courserun_is_enrollable?: boolean, id?: number, live?: boolean, page?: number, page__live?: boolean, page_size?: number, readable_id?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/courses/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (courserun_is_enrollable !== undefined) {
                localVarQueryParameter['courserun_is_enrollable'] = courserun_is_enrollable;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (live !== undefined) {
                localVarQueryParameter['live'] = live;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (page__live !== undefined) {
                localVarQueryParameter['page__live'] = page__live;
            }

            if (page_size !== undefined) {
                localVarQueryParameter['page_size'] = page_size;
            }

            if (readable_id !== undefined) {
                localVarQueryParameter['readable_id'] = readable_id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a specific course - API v1
         * @param {number} id A unique integer value identifying this course.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1CoursesRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiV1CoursesRetrieve', 'id', id)
            const localVarPath = `/api/v1/courses/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all courses - API v2
         * @param {number} [contract_id] Only show courses belonging to this B2B contract
         * @param {boolean} [courserun_is_enrollable] Course Run Is Enrollable
         * @param {Array<number>} [id] Multiple values may be separated by commas.
         * @param {boolean} [include_approved_financial_aid] Include approved financial assistance information
         * @param {boolean} [live] 
         * @param {number} [org_id] Only show courses belonging to this B2B/UAI organization
         * @param {number} [page] A page number within the paginated result set.
         * @param {boolean} [page__live] 
         * @param {number} [page_size] Number of results to return per page.
         * @param {string} [readable_id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2CoursesList: async (contract_id?: number, courserun_is_enrollable?: boolean, id?: Array<number>, include_approved_financial_aid?: boolean, live?: boolean, org_id?: number, page?: number, page__live?: boolean, page_size?: number, readable_id?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/courses/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (contract_id !== undefined) {
                localVarQueryParameter['contract_id'] = contract_id;
            }

            if (courserun_is_enrollable !== undefined) {
                localVarQueryParameter['courserun_is_enrollable'] = courserun_is_enrollable;
            }

            if (id) {
                localVarQueryParameter['id'] = id.join(COLLECTION_FORMATS.csv);
            }

            if (include_approved_financial_aid !== undefined) {
                localVarQueryParameter['include_approved_financial_aid'] = include_approved_financial_aid;
            }

            if (live !== undefined) {
                localVarQueryParameter['live'] = live;
            }

            if (org_id !== undefined) {
                localVarQueryParameter['org_id'] = org_id;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (page__live !== undefined) {
                localVarQueryParameter['page__live'] = page__live;
            }

            if (page_size !== undefined) {
                localVarQueryParameter['page_size'] = page_size;
            }

            if (readable_id !== undefined) {
                localVarQueryParameter['readable_id'] = readable_id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a specific course - API v2
         * @param {string} id A unique integer value (pk) or readable_id string identifying this course.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2CoursesRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiV2CoursesRetrieve', 'id', id)
            const localVarPath = `/api/v2/courses/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CoursesApi - functional programming interface
 * @export
 */
export const CoursesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CoursesApiAxiosParamCreator(configuration)
    return {
        /**
         * List all courses - API v1
         * @param {boolean} [courserun_is_enrollable] 
         * @param {number} [id] 
         * @param {boolean} [live] 
         * @param {number} [page] A page number within the paginated result set.
         * @param {boolean} [page__live] 
         * @param {number} [page_size] Number of results to return per page.
         * @param {string} [readable_id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1CoursesList(courserun_is_enrollable?: boolean, id?: number, live?: boolean, page?: number, page__live?: boolean, page_size?: number, readable_id?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedV1CourseWithCourseRunsList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1CoursesList(courserun_is_enrollable, id, live, page, page__live, page_size, readable_id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CoursesApi.apiV1CoursesList']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Retrieve a specific course - API v1
         * @param {number} id A unique integer value identifying this course.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1CoursesRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1CourseWithCourseRuns>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1CoursesRetrieve(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CoursesApi.apiV1CoursesRetrieve']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * List all courses - API v2
         * @param {number} [contract_id] Only show courses belonging to this B2B contract
         * @param {boolean} [courserun_is_enrollable] Course Run Is Enrollable
         * @param {Array<number>} [id] Multiple values may be separated by commas.
         * @param {boolean} [include_approved_financial_aid] Include approved financial assistance information
         * @param {boolean} [live] 
         * @param {number} [org_id] Only show courses belonging to this B2B/UAI organization
         * @param {number} [page] A page number within the paginated result set.
         * @param {boolean} [page__live] 
         * @param {number} [page_size] Number of results to return per page.
         * @param {string} [readable_id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV2CoursesList(contract_id?: number, courserun_is_enrollable?: boolean, id?: Array<number>, include_approved_financial_aid?: boolean, live?: boolean, org_id?: number, page?: number, page__live?: boolean, page_size?: number, readable_id?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedCourseWithCourseRunsSerializerV2List>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV2CoursesList(contract_id, courserun_is_enrollable, id, include_approved_financial_aid, live, org_id, page, page__live, page_size, readable_id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CoursesApi.apiV2CoursesList']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Retrieve a specific course - API v2
         * @param {string} id A unique integer value (pk) or readable_id string identifying this course.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV2CoursesRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseWithCourseRunsSerializerV2>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV2CoursesRetrieve(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CoursesApi.apiV2CoursesRetrieve']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * CoursesApi - factory interface
 * @export
 */
export const CoursesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CoursesApiFp(configuration)
    return {
        /**
         * List all courses - API v1
         * @param {CoursesApiApiV1CoursesListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1CoursesList(requestParameters: CoursesApiApiV1CoursesListRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedV1CourseWithCourseRunsList> {
            return localVarFp.apiV1CoursesList(requestParameters.courserun_is_enrollable, requestParameters.id, requestParameters.live, requestParameters.page, requestParameters.page__live, requestParameters.page_size, requestParameters.readable_id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific course - API v1
         * @param {CoursesApiApiV1CoursesRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1CoursesRetrieve(requestParameters: CoursesApiApiV1CoursesRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<V1CourseWithCourseRuns> {
            return localVarFp.apiV1CoursesRetrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * List all courses - API v2
         * @param {CoursesApiApiV2CoursesListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2CoursesList(requestParameters: CoursesApiApiV2CoursesListRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedCourseWithCourseRunsSerializerV2List> {
            return localVarFp.apiV2CoursesList(requestParameters.contract_id, requestParameters.courserun_is_enrollable, requestParameters.id, requestParameters.include_approved_financial_aid, requestParameters.live, requestParameters.org_id, requestParameters.page, requestParameters.page__live, requestParameters.page_size, requestParameters.readable_id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific course - API v2
         * @param {CoursesApiApiV2CoursesRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2CoursesRetrieve(requestParameters: CoursesApiApiV2CoursesRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<CourseWithCourseRunsSerializerV2> {
            return localVarFp.apiV2CoursesRetrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for apiV1CoursesList operation in CoursesApi.
 * @export
 * @interface CoursesApiApiV1CoursesListRequest
 */
export interface CoursesApiApiV1CoursesListRequest {
    /**
     * 
     * @type {boolean}
     * @memberof CoursesApiApiV1CoursesList
     */
    readonly courserun_is_enrollable?: boolean

    /**
     * 
     * @type {number}
     * @memberof CoursesApiApiV1CoursesList
     */
    readonly id?: number

    /**
     * 
     * @type {boolean}
     * @memberof CoursesApiApiV1CoursesList
     */
    readonly live?: boolean

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof CoursesApiApiV1CoursesList
     */
    readonly page?: number

    /**
     * 
     * @type {boolean}
     * @memberof CoursesApiApiV1CoursesList
     */
    readonly page__live?: boolean

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof CoursesApiApiV1CoursesList
     */
    readonly page_size?: number

    /**
     * 
     * @type {string}
     * @memberof CoursesApiApiV1CoursesList
     */
    readonly readable_id?: string
}

/**
 * Request parameters for apiV1CoursesRetrieve operation in CoursesApi.
 * @export
 * @interface CoursesApiApiV1CoursesRetrieveRequest
 */
export interface CoursesApiApiV1CoursesRetrieveRequest {
    /**
     * A unique integer value identifying this course.
     * @type {number}
     * @memberof CoursesApiApiV1CoursesRetrieve
     */
    readonly id: number
}

/**
 * Request parameters for apiV2CoursesList operation in CoursesApi.
 * @export
 * @interface CoursesApiApiV2CoursesListRequest
 */
export interface CoursesApiApiV2CoursesListRequest {
    /**
     * Only show courses belonging to this B2B contract
     * @type {number}
     * @memberof CoursesApiApiV2CoursesList
     */
    readonly contract_id?: number

    /**
     * Course Run Is Enrollable
     * @type {boolean}
     * @memberof CoursesApiApiV2CoursesList
     */
    readonly courserun_is_enrollable?: boolean

    /**
     * Multiple values may be separated by commas.
     * @type {Array<number>}
     * @memberof CoursesApiApiV2CoursesList
     */
    readonly id?: Array<number>

    /**
     * Include approved financial assistance information
     * @type {boolean}
     * @memberof CoursesApiApiV2CoursesList
     */
    readonly include_approved_financial_aid?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof CoursesApiApiV2CoursesList
     */
    readonly live?: boolean

    /**
     * Only show courses belonging to this B2B/UAI organization
     * @type {number}
     * @memberof CoursesApiApiV2CoursesList
     */
    readonly org_id?: number

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof CoursesApiApiV2CoursesList
     */
    readonly page?: number

    /**
     * 
     * @type {boolean}
     * @memberof CoursesApiApiV2CoursesList
     */
    readonly page__live?: boolean

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof CoursesApiApiV2CoursesList
     */
    readonly page_size?: number

    /**
     * 
     * @type {string}
     * @memberof CoursesApiApiV2CoursesList
     */
    readonly readable_id?: string
}

/**
 * Request parameters for apiV2CoursesRetrieve operation in CoursesApi.
 * @export
 * @interface CoursesApiApiV2CoursesRetrieveRequest
 */
export interface CoursesApiApiV2CoursesRetrieveRequest {
    /**
     * A unique integer value (pk) or readable_id string identifying this course.
     * @type {string}
     * @memberof CoursesApiApiV2CoursesRetrieve
     */
    readonly id: string
}

/**
 * CoursesApi - object-oriented interface
 * @export
 * @class CoursesApi
 * @extends {BaseAPI}
 */
export class CoursesApi extends BaseAPI {
    /**
     * List all courses - API v1
     * @param {CoursesApiApiV1CoursesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesApi
     */
    public apiV1CoursesList(requestParameters: CoursesApiApiV1CoursesListRequest = {}, options?: RawAxiosRequestConfig) {
        return CoursesApiFp(this.configuration).apiV1CoursesList(requestParameters.courserun_is_enrollable, requestParameters.id, requestParameters.live, requestParameters.page, requestParameters.page__live, requestParameters.page_size, requestParameters.readable_id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a specific course - API v1
     * @param {CoursesApiApiV1CoursesRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesApi
     */
    public apiV1CoursesRetrieve(requestParameters: CoursesApiApiV1CoursesRetrieveRequest, options?: RawAxiosRequestConfig) {
        return CoursesApiFp(this.configuration).apiV1CoursesRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all courses - API v2
     * @param {CoursesApiApiV2CoursesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesApi
     */
    public apiV2CoursesList(requestParameters: CoursesApiApiV2CoursesListRequest = {}, options?: RawAxiosRequestConfig) {
        return CoursesApiFp(this.configuration).apiV2CoursesList(requestParameters.contract_id, requestParameters.courserun_is_enrollable, requestParameters.id, requestParameters.include_approved_financial_aid, requestParameters.live, requestParameters.org_id, requestParameters.page, requestParameters.page__live, requestParameters.page_size, requestParameters.readable_id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a specific course - API v2
     * @param {CoursesApiApiV2CoursesRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesApi
     */
    public apiV2CoursesRetrieve(requestParameters: CoursesApiApiV2CoursesRetrieveRequest, options?: RawAxiosRequestConfig) {
        return CoursesApiFp(this.configuration).apiV2CoursesRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DepartmentsApi - axios parameter creator
 * @export
 */
export const DepartmentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List departments - v1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        departmentsListV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/departments/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List departments - v2
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        departmentsListV2: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/departments/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get department details - v1
         * @param {number} id A unique integer value identifying this department.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        departmentsRetrieveV1: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('departmentsRetrieveV1', 'id', id)
            const localVarPath = `/api/v1/departments/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get department details - v2
         * @param {number} id A unique integer value identifying this department.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        departmentsRetrieveV2: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('departmentsRetrieveV2', 'id', id)
            const localVarPath = `/api/v2/departments/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DepartmentsApi - functional programming interface
 * @export
 */
export const DepartmentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DepartmentsApiAxiosParamCreator(configuration)
    return {
        /**
         * List departments - v1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async departmentsListV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DepartmentWithCount>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.departmentsListV1(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DepartmentsApi.departmentsListV1']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * List departments - v2
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async departmentsListV2(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DepartmentWithCoursesAndPrograms>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.departmentsListV2(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DepartmentsApi.departmentsListV2']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get department details - v1
         * @param {number} id A unique integer value identifying this department.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async departmentsRetrieveV1(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DepartmentWithCount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.departmentsRetrieveV1(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DepartmentsApi.departmentsRetrieveV1']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get department details - v2
         * @param {number} id A unique integer value identifying this department.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async departmentsRetrieveV2(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DepartmentWithCoursesAndPrograms>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.departmentsRetrieveV2(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DepartmentsApi.departmentsRetrieveV2']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * DepartmentsApi - factory interface
 * @export
 */
export const DepartmentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DepartmentsApiFp(configuration)
    return {
        /**
         * List departments - v1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        departmentsListV1(options?: RawAxiosRequestConfig): AxiosPromise<Array<DepartmentWithCount>> {
            return localVarFp.departmentsListV1(options).then((request) => request(axios, basePath));
        },
        /**
         * List departments - v2
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        departmentsListV2(options?: RawAxiosRequestConfig): AxiosPromise<Array<DepartmentWithCoursesAndPrograms>> {
            return localVarFp.departmentsListV2(options).then((request) => request(axios, basePath));
        },
        /**
         * Get department details - v1
         * @param {DepartmentsApiDepartmentsRetrieveV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        departmentsRetrieveV1(requestParameters: DepartmentsApiDepartmentsRetrieveV1Request, options?: RawAxiosRequestConfig): AxiosPromise<DepartmentWithCount> {
            return localVarFp.departmentsRetrieveV1(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get department details - v2
         * @param {DepartmentsApiDepartmentsRetrieveV2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        departmentsRetrieveV2(requestParameters: DepartmentsApiDepartmentsRetrieveV2Request, options?: RawAxiosRequestConfig): AxiosPromise<DepartmentWithCoursesAndPrograms> {
            return localVarFp.departmentsRetrieveV2(requestParameters.id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for departmentsRetrieveV1 operation in DepartmentsApi.
 * @export
 * @interface DepartmentsApiDepartmentsRetrieveV1Request
 */
export interface DepartmentsApiDepartmentsRetrieveV1Request {
    /**
     * A unique integer value identifying this department.
     * @type {number}
     * @memberof DepartmentsApiDepartmentsRetrieveV1
     */
    readonly id: number
}

/**
 * Request parameters for departmentsRetrieveV2 operation in DepartmentsApi.
 * @export
 * @interface DepartmentsApiDepartmentsRetrieveV2Request
 */
export interface DepartmentsApiDepartmentsRetrieveV2Request {
    /**
     * A unique integer value identifying this department.
     * @type {number}
     * @memberof DepartmentsApiDepartmentsRetrieveV2
     */
    readonly id: number
}

/**
 * DepartmentsApi - object-oriented interface
 * @export
 * @class DepartmentsApi
 * @extends {BaseAPI}
 */
export class DepartmentsApi extends BaseAPI {
    /**
     * List departments - v1
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DepartmentsApi
     */
    public departmentsListV1(options?: RawAxiosRequestConfig) {
        return DepartmentsApiFp(this.configuration).departmentsListV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List departments - v2
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DepartmentsApi
     */
    public departmentsListV2(options?: RawAxiosRequestConfig) {
        return DepartmentsApiFp(this.configuration).departmentsListV2(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get department details - v1
     * @param {DepartmentsApiDepartmentsRetrieveV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DepartmentsApi
     */
    public departmentsRetrieveV1(requestParameters: DepartmentsApiDepartmentsRetrieveV1Request, options?: RawAxiosRequestConfig) {
        return DepartmentsApiFp(this.configuration).departmentsRetrieveV1(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get department details - v2
     * @param {DepartmentsApiDepartmentsRetrieveV2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DepartmentsApi
     */
    public departmentsRetrieveV2(requestParameters: DepartmentsApiDepartmentsRetrieveV2Request, options?: RawAxiosRequestConfig) {
        return DepartmentsApiFp(this.configuration).departmentsRetrieveV2(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DiscountsApi - axios parameter creator
 * @export
 */
export const DiscountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create an association between a user and a discount.
         * @param {number} id ID of the user discount
         * @param {number} parent_lookup_discount ID of the parent discount
         * @param {UserDiscountMetaRequest} UserDiscountMetaRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsAssigneesCreate: async (id: number, parent_lookup_discount: number, UserDiscountMetaRequest: UserDiscountMetaRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('discountsAssigneesCreate', 'id', id)
            // verify required parameter 'parent_lookup_discount' is not null or undefined
            assertParamExists('discountsAssigneesCreate', 'parent_lookup_discount', parent_lookup_discount)
            // verify required parameter 'UserDiscountMetaRequest' is not null or undefined
            assertParamExists('discountsAssigneesCreate', 'UserDiscountMetaRequest', UserDiscountMetaRequest)
            const localVarPath = `/api/v0/discounts/{parent_lookup_discount}/assignees/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"parent_lookup_discount"}}`, encodeURIComponent(String(parent_lookup_discount)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(UserDiscountMetaRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a user discount.
         * @param {number} id ID of the user discount
         * @param {number} parent_lookup_discount ID of the parent discount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsAssigneesDestroy: async (id: number, parent_lookup_discount: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('discountsAssigneesDestroy', 'id', id)
            // verify required parameter 'parent_lookup_discount' is not null or undefined
            assertParamExists('discountsAssigneesDestroy', 'parent_lookup_discount', parent_lookup_discount)
            const localVarPath = `/api/v0/discounts/{parent_lookup_discount}/assignees/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"parent_lookup_discount"}}`, encodeURIComponent(String(parent_lookup_discount)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API view set for User Discounts. This one is for use within a Discount.
         * @param {number} id ID of the user discount
         * @param {number} parent_lookup_discount ID of the parent discount
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsAssigneesList: async (id: number, parent_lookup_discount: number, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('discountsAssigneesList', 'id', id)
            // verify required parameter 'parent_lookup_discount' is not null or undefined
            assertParamExists('discountsAssigneesList', 'parent_lookup_discount', parent_lookup_discount)
            const localVarPath = `/api/v0/discounts/{parent_lookup_discount}/assignees/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"parent_lookup_discount"}}`, encodeURIComponent(String(parent_lookup_discount)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Partial update for a user discount.
         * @param {number} id ID of the user discount
         * @param {number} parent_lookup_discount ID of the parent discount
         * @param {PatchedUserDiscountMetaRequest} [PatchedUserDiscountMetaRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsAssigneesPartialUpdate: async (id: number, parent_lookup_discount: number, PatchedUserDiscountMetaRequest?: PatchedUserDiscountMetaRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('discountsAssigneesPartialUpdate', 'id', id)
            // verify required parameter 'parent_lookup_discount' is not null or undefined
            assertParamExists('discountsAssigneesPartialUpdate', 'parent_lookup_discount', parent_lookup_discount)
            const localVarPath = `/api/v0/discounts/{parent_lookup_discount}/assignees/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"parent_lookup_discount"}}`, encodeURIComponent(String(parent_lookup_discount)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(PatchedUserDiscountMetaRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API view set for User Discounts. This one is for use within a Discount.
         * @param {number} id ID of the user discount
         * @param {number} parent_lookup_discount ID of the parent discount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsAssigneesRetrieve: async (id: number, parent_lookup_discount: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('discountsAssigneesRetrieve', 'id', id)
            // verify required parameter 'parent_lookup_discount' is not null or undefined
            assertParamExists('discountsAssigneesRetrieve', 'parent_lookup_discount', parent_lookup_discount)
            const localVarPath = `/api/v0/discounts/{parent_lookup_discount}/assignees/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"parent_lookup_discount"}}`, encodeURIComponent(String(parent_lookup_discount)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API view set for User Discounts. This one is for use within a Discount.
         * @param {number} id ID of the user discount
         * @param {number} parent_lookup_discount ID of the parent discount
         * @param {UserDiscountMetaRequest} UserDiscountMetaRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsAssigneesUpdate: async (id: number, parent_lookup_discount: number, UserDiscountMetaRequest: UserDiscountMetaRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('discountsAssigneesUpdate', 'id', id)
            // verify required parameter 'parent_lookup_discount' is not null or undefined
            assertParamExists('discountsAssigneesUpdate', 'parent_lookup_discount', parent_lookup_discount)
            // verify required parameter 'UserDiscountMetaRequest' is not null or undefined
            assertParamExists('discountsAssigneesUpdate', 'UserDiscountMetaRequest', UserDiscountMetaRequest)
            const localVarPath = `/api/v0/discounts/{parent_lookup_discount}/assignees/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"parent_lookup_discount"}}`, encodeURIComponent(String(parent_lookup_discount)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(UserDiscountMetaRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API view set for Discounts
         * @param {V0DiscountRequest} V0DiscountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsCreate: async (V0DiscountRequest: V0DiscountRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'V0DiscountRequest' is not null or undefined
            assertParamExists('discountsCreate', 'V0DiscountRequest', V0DiscountRequest)
            const localVarPath = `/api/v0/discounts/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(V0DiscountRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a batch of codes. This is used in the staff-dashboard. POST arguments are the same as in generate_discount_code - look there for details.
         * @param {V0DiscountRequest} V0DiscountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsCreateBatchCreate: async (V0DiscountRequest: V0DiscountRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'V0DiscountRequest' is not null or undefined
            assertParamExists('discountsCreateBatchCreate', 'V0DiscountRequest', V0DiscountRequest)
            const localVarPath = `/api/v0/discounts/create_batch/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(V0DiscountRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API view set for Discounts
         * @param {number} id A unique integer value identifying this discount.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsDestroy: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('discountsDestroy', 'id', id)
            const localVarPath = `/api/v0/discounts/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API view set for Discounts
         * @param {DiscountsListIsRedeemedEnum} [is_redeemed] * &#x60;yes&#x60; - yes * &#x60;no&#x60; - no
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {DiscountsListPaymentTypeEnum} [payment_type] * &#x60;marketing&#x60; - marketing * &#x60;sales&#x60; - sales * &#x60;financial-assistance&#x60; - financial-assistance * &#x60;customer-support&#x60; - customer-support * &#x60;staff&#x60; - staff * &#x60;legacy&#x60; - legacy
         * @param {string} [q] q
         * @param {DiscountsListRedemptionTypeEnum} [redemption_type] * &#x60;one-time&#x60; - one-time * &#x60;one-time-per-user&#x60; - one-time-per-user * &#x60;unlimited&#x60; - unlimited
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsList: async (is_redeemed?: DiscountsListIsRedeemedEnum, limit?: number, offset?: number, payment_type?: DiscountsListPaymentTypeEnum, q?: string, redemption_type?: DiscountsListRedemptionTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v0/discounts/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (is_redeemed !== undefined) {
                localVarQueryParameter['is_redeemed'] = is_redeemed;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (payment_type !== undefined) {
                localVarQueryParameter['payment_type'] = payment_type;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (redemption_type !== undefined) {
                localVarQueryParameter['redemption_type'] = redemption_type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API view set for Discounts
         * @param {number} id A unique integer value identifying this discount.
         * @param {PatchedV0DiscountRequest} [PatchedV0DiscountRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsPartialUpdate: async (id: number, PatchedV0DiscountRequest?: PatchedV0DiscountRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('discountsPartialUpdate', 'id', id)
            const localVarPath = `/api/v0/discounts/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(PatchedV0DiscountRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API view set for Discounts
         * @param {number} id ID of the discount product
         * @param {number} parent_lookup_discount ID of the parent discount
         * @param {DiscountProductRequest} DiscountProductRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsProductsCreate: async (id: number, parent_lookup_discount: number, DiscountProductRequest: DiscountProductRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('discountsProductsCreate', 'id', id)
            // verify required parameter 'parent_lookup_discount' is not null or undefined
            assertParamExists('discountsProductsCreate', 'parent_lookup_discount', parent_lookup_discount)
            // verify required parameter 'DiscountProductRequest' is not null or undefined
            assertParamExists('discountsProductsCreate', 'DiscountProductRequest', DiscountProductRequest)
            const localVarPath = `/api/v0/discounts/{parent_lookup_discount}/products/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"parent_lookup_discount"}}`, encodeURIComponent(String(parent_lookup_discount)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(DiscountProductRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a linked product from a discount.
         * @param {number} id ID of the discount product
         * @param {number} parent_lookup_discount ID of the parent discount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsProductsDestroy: async (id: number, parent_lookup_discount: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('discountsProductsDestroy', 'id', id)
            // verify required parameter 'parent_lookup_discount' is not null or undefined
            assertParamExists('discountsProductsDestroy', 'parent_lookup_discount', parent_lookup_discount)
            const localVarPath = `/api/v0/discounts/{parent_lookup_discount}/products/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"parent_lookup_discount"}}`, encodeURIComponent(String(parent_lookup_discount)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API view set for Discounts
         * @param {number} id ID of the discount product
         * @param {number} parent_lookup_discount ID of the parent discount
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsProductsList: async (id: number, parent_lookup_discount: number, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('discountsProductsList', 'id', id)
            // verify required parameter 'parent_lookup_discount' is not null or undefined
            assertParamExists('discountsProductsList', 'parent_lookup_discount', parent_lookup_discount)
            const localVarPath = `/api/v0/discounts/{parent_lookup_discount}/products/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"parent_lookup_discount"}}`, encodeURIComponent(String(parent_lookup_discount)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Partial update for a discount product.
         * @param {number} id ID of the discount product
         * @param {number} parent_lookup_discount ID of the parent discount
         * @param {PatchedDiscountProductRequest} [PatchedDiscountProductRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsProductsPartialUpdate: async (id: number, parent_lookup_discount: number, PatchedDiscountProductRequest?: PatchedDiscountProductRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('discountsProductsPartialUpdate', 'id', id)
            // verify required parameter 'parent_lookup_discount' is not null or undefined
            assertParamExists('discountsProductsPartialUpdate', 'parent_lookup_discount', parent_lookup_discount)
            const localVarPath = `/api/v0/discounts/{parent_lookup_discount}/products/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"parent_lookup_discount"}}`, encodeURIComponent(String(parent_lookup_discount)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(PatchedDiscountProductRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API view set for Discounts
         * @param {number} id ID of the discount product
         * @param {number} parent_lookup_discount ID of the parent discount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsProductsRetrieve: async (id: number, parent_lookup_discount: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('discountsProductsRetrieve', 'id', id)
            // verify required parameter 'parent_lookup_discount' is not null or undefined
            assertParamExists('discountsProductsRetrieve', 'parent_lookup_discount', parent_lookup_discount)
            const localVarPath = `/api/v0/discounts/{parent_lookup_discount}/products/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"parent_lookup_discount"}}`, encodeURIComponent(String(parent_lookup_discount)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API view set for Discounts
         * @param {number} id ID of the discount product
         * @param {number} parent_lookup_discount ID of the parent discount
         * @param {DiscountProductRequest} DiscountProductRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsProductsUpdate: async (id: number, parent_lookup_discount: number, DiscountProductRequest: DiscountProductRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('discountsProductsUpdate', 'id', id)
            // verify required parameter 'parent_lookup_discount' is not null or undefined
            assertParamExists('discountsProductsUpdate', 'parent_lookup_discount', parent_lookup_discount)
            // verify required parameter 'DiscountProductRequest' is not null or undefined
            assertParamExists('discountsProductsUpdate', 'DiscountProductRequest', DiscountProductRequest)
            const localVarPath = `/api/v0/discounts/{parent_lookup_discount}/products/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"parent_lookup_discount"}}`, encodeURIComponent(String(parent_lookup_discount)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(DiscountProductRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API view set for Discount Redemptions
         * @param {number} id ID of the user discount
         * @param {number} parent_lookup_redeemed_discount ID of the parent discount
         * @param {DiscountRedemptionRequest} DiscountRedemptionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsRedemptionsCreate: async (id: number, parent_lookup_redeemed_discount: number, DiscountRedemptionRequest: DiscountRedemptionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('discountsRedemptionsCreate', 'id', id)
            // verify required parameter 'parent_lookup_redeemed_discount' is not null or undefined
            assertParamExists('discountsRedemptionsCreate', 'parent_lookup_redeemed_discount', parent_lookup_redeemed_discount)
            // verify required parameter 'DiscountRedemptionRequest' is not null or undefined
            assertParamExists('discountsRedemptionsCreate', 'DiscountRedemptionRequest', DiscountRedemptionRequest)
            const localVarPath = `/api/v0/discounts/{parent_lookup_redeemed_discount}/redemptions/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"parent_lookup_redeemed_discount"}}`, encodeURIComponent(String(parent_lookup_redeemed_discount)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(DiscountRedemptionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API view set for Discount Redemptions
         * @param {number} id ID of the user discount
         * @param {number} parent_lookup_redeemed_discount ID of the parent discount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsRedemptionsDestroy: async (id: number, parent_lookup_redeemed_discount: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('discountsRedemptionsDestroy', 'id', id)
            // verify required parameter 'parent_lookup_redeemed_discount' is not null or undefined
            assertParamExists('discountsRedemptionsDestroy', 'parent_lookup_redeemed_discount', parent_lookup_redeemed_discount)
            const localVarPath = `/api/v0/discounts/{parent_lookup_redeemed_discount}/redemptions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"parent_lookup_redeemed_discount"}}`, encodeURIComponent(String(parent_lookup_redeemed_discount)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API view set for Discount Redemptions
         * @param {number} id ID of the user discount
         * @param {number} parent_lookup_redeemed_discount ID of the parent discount
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsRedemptionsList: async (id: number, parent_lookup_redeemed_discount: number, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('discountsRedemptionsList', 'id', id)
            // verify required parameter 'parent_lookup_redeemed_discount' is not null or undefined
            assertParamExists('discountsRedemptionsList', 'parent_lookup_redeemed_discount', parent_lookup_redeemed_discount)
            const localVarPath = `/api/v0/discounts/{parent_lookup_redeemed_discount}/redemptions/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"parent_lookup_redeemed_discount"}}`, encodeURIComponent(String(parent_lookup_redeemed_discount)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API view set for Discount Redemptions
         * @param {number} id ID of the user discount
         * @param {number} parent_lookup_redeemed_discount ID of the parent discount
         * @param {PatchedDiscountRedemptionRequest} [PatchedDiscountRedemptionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsRedemptionsPartialUpdate: async (id: number, parent_lookup_redeemed_discount: number, PatchedDiscountRedemptionRequest?: PatchedDiscountRedemptionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('discountsRedemptionsPartialUpdate', 'id', id)
            // verify required parameter 'parent_lookup_redeemed_discount' is not null or undefined
            assertParamExists('discountsRedemptionsPartialUpdate', 'parent_lookup_redeemed_discount', parent_lookup_redeemed_discount)
            const localVarPath = `/api/v0/discounts/{parent_lookup_redeemed_discount}/redemptions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"parent_lookup_redeemed_discount"}}`, encodeURIComponent(String(parent_lookup_redeemed_discount)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(PatchedDiscountRedemptionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API view set for Discount Redemptions
         * @param {number} id ID of the user discount
         * @param {number} parent_lookup_redeemed_discount ID of the parent discount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsRedemptionsRetrieve: async (id: number, parent_lookup_redeemed_discount: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('discountsRedemptionsRetrieve', 'id', id)
            // verify required parameter 'parent_lookup_redeemed_discount' is not null or undefined
            assertParamExists('discountsRedemptionsRetrieve', 'parent_lookup_redeemed_discount', parent_lookup_redeemed_discount)
            const localVarPath = `/api/v0/discounts/{parent_lookup_redeemed_discount}/redemptions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"parent_lookup_redeemed_discount"}}`, encodeURIComponent(String(parent_lookup_redeemed_discount)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API view set for Discount Redemptions
         * @param {number} id ID of the user discount
         * @param {number} parent_lookup_redeemed_discount ID of the parent discount
         * @param {DiscountRedemptionRequest} DiscountRedemptionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsRedemptionsUpdate: async (id: number, parent_lookup_redeemed_discount: number, DiscountRedemptionRequest: DiscountRedemptionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('discountsRedemptionsUpdate', 'id', id)
            // verify required parameter 'parent_lookup_redeemed_discount' is not null or undefined
            assertParamExists('discountsRedemptionsUpdate', 'parent_lookup_redeemed_discount', parent_lookup_redeemed_discount)
            // verify required parameter 'DiscountRedemptionRequest' is not null or undefined
            assertParamExists('discountsRedemptionsUpdate', 'DiscountRedemptionRequest', DiscountRedemptionRequest)
            const localVarPath = `/api/v0/discounts/{parent_lookup_redeemed_discount}/redemptions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"parent_lookup_redeemed_discount"}}`, encodeURIComponent(String(parent_lookup_redeemed_discount)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(DiscountRedemptionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API view set for Discounts
         * @param {number} id A unique integer value identifying this discount.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('discountsRetrieve', 'id', id)
            const localVarPath = `/api/v0/discounts/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API view set for Flexible Pricing Tiers. This one is for use within a Discount.
         * @param {number} id ID of the user discount
         * @param {number} parent_lookup_discount ID of the parent discount
         * @param {FlexiblePriceTierRequest} FlexiblePriceTierRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsTiersCreate: async (id: number, parent_lookup_discount: number, FlexiblePriceTierRequest: FlexiblePriceTierRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('discountsTiersCreate', 'id', id)
            // verify required parameter 'parent_lookup_discount' is not null or undefined
            assertParamExists('discountsTiersCreate', 'parent_lookup_discount', parent_lookup_discount)
            // verify required parameter 'FlexiblePriceTierRequest' is not null or undefined
            assertParamExists('discountsTiersCreate', 'FlexiblePriceTierRequest', FlexiblePriceTierRequest)
            const localVarPath = `/api/v0/discounts/{parent_lookup_discount}/tiers/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"parent_lookup_discount"}}`, encodeURIComponent(String(parent_lookup_discount)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(FlexiblePriceTierRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API view set for Flexible Pricing Tiers. This one is for use within a Discount.
         * @param {number} id ID of the user discount
         * @param {number} parent_lookup_discount ID of the parent discount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsTiersDestroy: async (id: number, parent_lookup_discount: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('discountsTiersDestroy', 'id', id)
            // verify required parameter 'parent_lookup_discount' is not null or undefined
            assertParamExists('discountsTiersDestroy', 'parent_lookup_discount', parent_lookup_discount)
            const localVarPath = `/api/v0/discounts/{parent_lookup_discount}/tiers/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"parent_lookup_discount"}}`, encodeURIComponent(String(parent_lookup_discount)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API view set for Flexible Pricing Tiers. This one is for use within a Discount.
         * @param {number} id ID of the user discount
         * @param {number} parent_lookup_discount ID of the parent discount
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsTiersList: async (id: number, parent_lookup_discount: number, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('discountsTiersList', 'id', id)
            // verify required parameter 'parent_lookup_discount' is not null or undefined
            assertParamExists('discountsTiersList', 'parent_lookup_discount', parent_lookup_discount)
            const localVarPath = `/api/v0/discounts/{parent_lookup_discount}/tiers/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"parent_lookup_discount"}}`, encodeURIComponent(String(parent_lookup_discount)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API view set for Flexible Pricing Tiers. This one is for use within a Discount.
         * @param {number} id ID of the user discount
         * @param {number} parent_lookup_discount ID of the parent discount
         * @param {PatchedFlexiblePriceTierRequest} [PatchedFlexiblePriceTierRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsTiersPartialUpdate: async (id: number, parent_lookup_discount: number, PatchedFlexiblePriceTierRequest?: PatchedFlexiblePriceTierRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('discountsTiersPartialUpdate', 'id', id)
            // verify required parameter 'parent_lookup_discount' is not null or undefined
            assertParamExists('discountsTiersPartialUpdate', 'parent_lookup_discount', parent_lookup_discount)
            const localVarPath = `/api/v0/discounts/{parent_lookup_discount}/tiers/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"parent_lookup_discount"}}`, encodeURIComponent(String(parent_lookup_discount)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(PatchedFlexiblePriceTierRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API view set for Flexible Pricing Tiers. This one is for use within a Discount.
         * @param {number} id ID of the user discount
         * @param {number} parent_lookup_discount ID of the parent discount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsTiersRetrieve: async (id: number, parent_lookup_discount: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('discountsTiersRetrieve', 'id', id)
            // verify required parameter 'parent_lookup_discount' is not null or undefined
            assertParamExists('discountsTiersRetrieve', 'parent_lookup_discount', parent_lookup_discount)
            const localVarPath = `/api/v0/discounts/{parent_lookup_discount}/tiers/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"parent_lookup_discount"}}`, encodeURIComponent(String(parent_lookup_discount)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API view set for Flexible Pricing Tiers. This one is for use within a Discount.
         * @param {number} id ID of the user discount
         * @param {number} parent_lookup_discount ID of the parent discount
         * @param {FlexiblePriceTierRequest} FlexiblePriceTierRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsTiersUpdate: async (id: number, parent_lookup_discount: number, FlexiblePriceTierRequest: FlexiblePriceTierRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('discountsTiersUpdate', 'id', id)
            // verify required parameter 'parent_lookup_discount' is not null or undefined
            assertParamExists('discountsTiersUpdate', 'parent_lookup_discount', parent_lookup_discount)
            // verify required parameter 'FlexiblePriceTierRequest' is not null or undefined
            assertParamExists('discountsTiersUpdate', 'FlexiblePriceTierRequest', FlexiblePriceTierRequest)
            const localVarPath = `/api/v0/discounts/{parent_lookup_discount}/tiers/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"parent_lookup_discount"}}`, encodeURIComponent(String(parent_lookup_discount)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(FlexiblePriceTierRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API view set for Discounts
         * @param {number} id A unique integer value identifying this discount.
         * @param {V0DiscountRequest} V0DiscountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsUpdate: async (id: number, V0DiscountRequest: V0DiscountRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('discountsUpdate', 'id', id)
            // verify required parameter 'V0DiscountRequest' is not null or undefined
            assertParamExists('discountsUpdate', 'V0DiscountRequest', V0DiscountRequest)
            const localVarPath = `/api/v0/discounts/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(V0DiscountRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DiscountsApi - functional programming interface
 * @export
 */
export const DiscountsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DiscountsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create an association between a user and a discount.
         * @param {number} id ID of the user discount
         * @param {number} parent_lookup_discount ID of the parent discount
         * @param {UserDiscountMetaRequest} UserDiscountMetaRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async discountsAssigneesCreate(id: number, parent_lookup_discount: number, UserDiscountMetaRequest: UserDiscountMetaRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDiscountMeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.discountsAssigneesCreate(id, parent_lookup_discount, UserDiscountMetaRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DiscountsApi.discountsAssigneesCreate']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Delete a user discount.
         * @param {number} id ID of the user discount
         * @param {number} parent_lookup_discount ID of the parent discount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async discountsAssigneesDestroy(id: number, parent_lookup_discount: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.discountsAssigneesDestroy(id, parent_lookup_discount, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DiscountsApi.discountsAssigneesDestroy']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * API view set for User Discounts. This one is for use within a Discount.
         * @param {number} id ID of the user discount
         * @param {number} parent_lookup_discount ID of the parent discount
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async discountsAssigneesList(id: number, parent_lookup_discount: number, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedUserDiscountMetaList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.discountsAssigneesList(id, parent_lookup_discount, limit, offset, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DiscountsApi.discountsAssigneesList']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Partial update for a user discount.
         * @param {number} id ID of the user discount
         * @param {number} parent_lookup_discount ID of the parent discount
         * @param {PatchedUserDiscountMetaRequest} [PatchedUserDiscountMetaRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async discountsAssigneesPartialUpdate(id: number, parent_lookup_discount: number, PatchedUserDiscountMetaRequest?: PatchedUserDiscountMetaRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDiscountMeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.discountsAssigneesPartialUpdate(id, parent_lookup_discount, PatchedUserDiscountMetaRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DiscountsApi.discountsAssigneesPartialUpdate']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * API view set for User Discounts. This one is for use within a Discount.
         * @param {number} id ID of the user discount
         * @param {number} parent_lookup_discount ID of the parent discount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async discountsAssigneesRetrieve(id: number, parent_lookup_discount: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDiscountMeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.discountsAssigneesRetrieve(id, parent_lookup_discount, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DiscountsApi.discountsAssigneesRetrieve']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * API view set for User Discounts. This one is for use within a Discount.
         * @param {number} id ID of the user discount
         * @param {number} parent_lookup_discount ID of the parent discount
         * @param {UserDiscountMetaRequest} UserDiscountMetaRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async discountsAssigneesUpdate(id: number, parent_lookup_discount: number, UserDiscountMetaRequest: UserDiscountMetaRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDiscountMeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.discountsAssigneesUpdate(id, parent_lookup_discount, UserDiscountMetaRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DiscountsApi.discountsAssigneesUpdate']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * API view set for Discounts
         * @param {V0DiscountRequest} V0DiscountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async discountsCreate(V0DiscountRequest: V0DiscountRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0Discount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.discountsCreate(V0DiscountRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DiscountsApi.discountsCreate']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Create a batch of codes. This is used in the staff-dashboard. POST arguments are the same as in generate_discount_code - look there for details.
         * @param {V0DiscountRequest} V0DiscountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async discountsCreateBatchCreate(V0DiscountRequest: V0DiscountRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0Discount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.discountsCreateBatchCreate(V0DiscountRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DiscountsApi.discountsCreateBatchCreate']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * API view set for Discounts
         * @param {number} id A unique integer value identifying this discount.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async discountsDestroy(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.discountsDestroy(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DiscountsApi.discountsDestroy']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * API view set for Discounts
         * @param {DiscountsListIsRedeemedEnum} [is_redeemed] * &#x60;yes&#x60; - yes * &#x60;no&#x60; - no
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {DiscountsListPaymentTypeEnum} [payment_type] * &#x60;marketing&#x60; - marketing * &#x60;sales&#x60; - sales * &#x60;financial-assistance&#x60; - financial-assistance * &#x60;customer-support&#x60; - customer-support * &#x60;staff&#x60; - staff * &#x60;legacy&#x60; - legacy
         * @param {string} [q] q
         * @param {DiscountsListRedemptionTypeEnum} [redemption_type] * &#x60;one-time&#x60; - one-time * &#x60;one-time-per-user&#x60; - one-time-per-user * &#x60;unlimited&#x60; - unlimited
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async discountsList(is_redeemed?: DiscountsListIsRedeemedEnum, limit?: number, offset?: number, payment_type?: DiscountsListPaymentTypeEnum, q?: string, redemption_type?: DiscountsListRedemptionTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedV0DiscountList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.discountsList(is_redeemed, limit, offset, payment_type, q, redemption_type, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DiscountsApi.discountsList']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * API view set for Discounts
         * @param {number} id A unique integer value identifying this discount.
         * @param {PatchedV0DiscountRequest} [PatchedV0DiscountRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async discountsPartialUpdate(id: number, PatchedV0DiscountRequest?: PatchedV0DiscountRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0Discount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.discountsPartialUpdate(id, PatchedV0DiscountRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DiscountsApi.discountsPartialUpdate']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * API view set for Discounts
         * @param {number} id ID of the discount product
         * @param {number} parent_lookup_discount ID of the parent discount
         * @param {DiscountProductRequest} DiscountProductRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async discountsProductsCreate(id: number, parent_lookup_discount: number, DiscountProductRequest: DiscountProductRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DiscountProduct>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.discountsProductsCreate(id, parent_lookup_discount, DiscountProductRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DiscountsApi.discountsProductsCreate']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Delete a linked product from a discount.
         * @param {number} id ID of the discount product
         * @param {number} parent_lookup_discount ID of the parent discount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async discountsProductsDestroy(id: number, parent_lookup_discount: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.discountsProductsDestroy(id, parent_lookup_discount, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DiscountsApi.discountsProductsDestroy']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * API view set for Discounts
         * @param {number} id ID of the discount product
         * @param {number} parent_lookup_discount ID of the parent discount
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async discountsProductsList(id: number, parent_lookup_discount: number, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedDiscountProductList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.discountsProductsList(id, parent_lookup_discount, limit, offset, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DiscountsApi.discountsProductsList']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Partial update for a discount product.
         * @param {number} id ID of the discount product
         * @param {number} parent_lookup_discount ID of the parent discount
         * @param {PatchedDiscountProductRequest} [PatchedDiscountProductRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async discountsProductsPartialUpdate(id: number, parent_lookup_discount: number, PatchedDiscountProductRequest?: PatchedDiscountProductRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DiscountProduct>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.discountsProductsPartialUpdate(id, parent_lookup_discount, PatchedDiscountProductRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DiscountsApi.discountsProductsPartialUpdate']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * API view set for Discounts
         * @param {number} id ID of the discount product
         * @param {number} parent_lookup_discount ID of the parent discount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async discountsProductsRetrieve(id: number, parent_lookup_discount: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DiscountProduct>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.discountsProductsRetrieve(id, parent_lookup_discount, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DiscountsApi.discountsProductsRetrieve']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * API view set for Discounts
         * @param {number} id ID of the discount product
         * @param {number} parent_lookup_discount ID of the parent discount
         * @param {DiscountProductRequest} DiscountProductRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async discountsProductsUpdate(id: number, parent_lookup_discount: number, DiscountProductRequest: DiscountProductRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DiscountProduct>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.discountsProductsUpdate(id, parent_lookup_discount, DiscountProductRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DiscountsApi.discountsProductsUpdate']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * API view set for Discount Redemptions
         * @param {number} id ID of the user discount
         * @param {number} parent_lookup_redeemed_discount ID of the parent discount
         * @param {DiscountRedemptionRequest} DiscountRedemptionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async discountsRedemptionsCreate(id: number, parent_lookup_redeemed_discount: number, DiscountRedemptionRequest: DiscountRedemptionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DiscountRedemption>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.discountsRedemptionsCreate(id, parent_lookup_redeemed_discount, DiscountRedemptionRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DiscountsApi.discountsRedemptionsCreate']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * API view set for Discount Redemptions
         * @param {number} id ID of the user discount
         * @param {number} parent_lookup_redeemed_discount ID of the parent discount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async discountsRedemptionsDestroy(id: number, parent_lookup_redeemed_discount: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.discountsRedemptionsDestroy(id, parent_lookup_redeemed_discount, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DiscountsApi.discountsRedemptionsDestroy']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * API view set for Discount Redemptions
         * @param {number} id ID of the user discount
         * @param {number} parent_lookup_redeemed_discount ID of the parent discount
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async discountsRedemptionsList(id: number, parent_lookup_redeemed_discount: number, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedDiscountRedemptionList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.discountsRedemptionsList(id, parent_lookup_redeemed_discount, limit, offset, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DiscountsApi.discountsRedemptionsList']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * API view set for Discount Redemptions
         * @param {number} id ID of the user discount
         * @param {number} parent_lookup_redeemed_discount ID of the parent discount
         * @param {PatchedDiscountRedemptionRequest} [PatchedDiscountRedemptionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async discountsRedemptionsPartialUpdate(id: number, parent_lookup_redeemed_discount: number, PatchedDiscountRedemptionRequest?: PatchedDiscountRedemptionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DiscountRedemption>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.discountsRedemptionsPartialUpdate(id, parent_lookup_redeemed_discount, PatchedDiscountRedemptionRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DiscountsApi.discountsRedemptionsPartialUpdate']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * API view set for Discount Redemptions
         * @param {number} id ID of the user discount
         * @param {number} parent_lookup_redeemed_discount ID of the parent discount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async discountsRedemptionsRetrieve(id: number, parent_lookup_redeemed_discount: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DiscountRedemption>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.discountsRedemptionsRetrieve(id, parent_lookup_redeemed_discount, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DiscountsApi.discountsRedemptionsRetrieve']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * API view set for Discount Redemptions
         * @param {number} id ID of the user discount
         * @param {number} parent_lookup_redeemed_discount ID of the parent discount
         * @param {DiscountRedemptionRequest} DiscountRedemptionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async discountsRedemptionsUpdate(id: number, parent_lookup_redeemed_discount: number, DiscountRedemptionRequest: DiscountRedemptionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DiscountRedemption>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.discountsRedemptionsUpdate(id, parent_lookup_redeemed_discount, DiscountRedemptionRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DiscountsApi.discountsRedemptionsUpdate']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * API view set for Discounts
         * @param {number} id A unique integer value identifying this discount.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async discountsRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0Discount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.discountsRetrieve(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DiscountsApi.discountsRetrieve']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * API view set for Flexible Pricing Tiers. This one is for use within a Discount.
         * @param {number} id ID of the user discount
         * @param {number} parent_lookup_discount ID of the parent discount
         * @param {FlexiblePriceTierRequest} FlexiblePriceTierRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async discountsTiersCreate(id: number, parent_lookup_discount: number, FlexiblePriceTierRequest: FlexiblePriceTierRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlexiblePriceTier>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.discountsTiersCreate(id, parent_lookup_discount, FlexiblePriceTierRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DiscountsApi.discountsTiersCreate']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * API view set for Flexible Pricing Tiers. This one is for use within a Discount.
         * @param {number} id ID of the user discount
         * @param {number} parent_lookup_discount ID of the parent discount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async discountsTiersDestroy(id: number, parent_lookup_discount: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.discountsTiersDestroy(id, parent_lookup_discount, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DiscountsApi.discountsTiersDestroy']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * API view set for Flexible Pricing Tiers. This one is for use within a Discount.
         * @param {number} id ID of the user discount
         * @param {number} parent_lookup_discount ID of the parent discount
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async discountsTiersList(id: number, parent_lookup_discount: number, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedFlexiblePriceTierList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.discountsTiersList(id, parent_lookup_discount, limit, offset, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DiscountsApi.discountsTiersList']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * API view set for Flexible Pricing Tiers. This one is for use within a Discount.
         * @param {number} id ID of the user discount
         * @param {number} parent_lookup_discount ID of the parent discount
         * @param {PatchedFlexiblePriceTierRequest} [PatchedFlexiblePriceTierRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async discountsTiersPartialUpdate(id: number, parent_lookup_discount: number, PatchedFlexiblePriceTierRequest?: PatchedFlexiblePriceTierRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlexiblePriceTier>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.discountsTiersPartialUpdate(id, parent_lookup_discount, PatchedFlexiblePriceTierRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DiscountsApi.discountsTiersPartialUpdate']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * API view set for Flexible Pricing Tiers. This one is for use within a Discount.
         * @param {number} id ID of the user discount
         * @param {number} parent_lookup_discount ID of the parent discount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async discountsTiersRetrieve(id: number, parent_lookup_discount: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlexiblePriceTier>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.discountsTiersRetrieve(id, parent_lookup_discount, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DiscountsApi.discountsTiersRetrieve']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * API view set for Flexible Pricing Tiers. This one is for use within a Discount.
         * @param {number} id ID of the user discount
         * @param {number} parent_lookup_discount ID of the parent discount
         * @param {FlexiblePriceTierRequest} FlexiblePriceTierRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async discountsTiersUpdate(id: number, parent_lookup_discount: number, FlexiblePriceTierRequest: FlexiblePriceTierRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlexiblePriceTier>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.discountsTiersUpdate(id, parent_lookup_discount, FlexiblePriceTierRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DiscountsApi.discountsTiersUpdate']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * API view set for Discounts
         * @param {number} id A unique integer value identifying this discount.
         * @param {V0DiscountRequest} V0DiscountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async discountsUpdate(id: number, V0DiscountRequest: V0DiscountRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0Discount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.discountsUpdate(id, V0DiscountRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DiscountsApi.discountsUpdate']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * DiscountsApi - factory interface
 * @export
 */
export const DiscountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DiscountsApiFp(configuration)
    return {
        /**
         * Create an association between a user and a discount.
         * @param {DiscountsApiDiscountsAssigneesCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsAssigneesCreate(requestParameters: DiscountsApiDiscountsAssigneesCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserDiscountMeta> {
            return localVarFp.discountsAssigneesCreate(requestParameters.id, requestParameters.parent_lookup_discount, requestParameters.UserDiscountMetaRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a user discount.
         * @param {DiscountsApiDiscountsAssigneesDestroyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsAssigneesDestroy(requestParameters: DiscountsApiDiscountsAssigneesDestroyRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.discountsAssigneesDestroy(requestParameters.id, requestParameters.parent_lookup_discount, options).then((request) => request(axios, basePath));
        },
        /**
         * API view set for User Discounts. This one is for use within a Discount.
         * @param {DiscountsApiDiscountsAssigneesListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsAssigneesList(requestParameters: DiscountsApiDiscountsAssigneesListRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedUserDiscountMetaList> {
            return localVarFp.discountsAssigneesList(requestParameters.id, requestParameters.parent_lookup_discount, requestParameters.limit, requestParameters.offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Partial update for a user discount.
         * @param {DiscountsApiDiscountsAssigneesPartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsAssigneesPartialUpdate(requestParameters: DiscountsApiDiscountsAssigneesPartialUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserDiscountMeta> {
            return localVarFp.discountsAssigneesPartialUpdate(requestParameters.id, requestParameters.parent_lookup_discount, requestParameters.PatchedUserDiscountMetaRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * API view set for User Discounts. This one is for use within a Discount.
         * @param {DiscountsApiDiscountsAssigneesRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsAssigneesRetrieve(requestParameters: DiscountsApiDiscountsAssigneesRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserDiscountMeta> {
            return localVarFp.discountsAssigneesRetrieve(requestParameters.id, requestParameters.parent_lookup_discount, options).then((request) => request(axios, basePath));
        },
        /**
         * API view set for User Discounts. This one is for use within a Discount.
         * @param {DiscountsApiDiscountsAssigneesUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsAssigneesUpdate(requestParameters: DiscountsApiDiscountsAssigneesUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserDiscountMeta> {
            return localVarFp.discountsAssigneesUpdate(requestParameters.id, requestParameters.parent_lookup_discount, requestParameters.UserDiscountMetaRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * API view set for Discounts
         * @param {DiscountsApiDiscountsCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsCreate(requestParameters: DiscountsApiDiscountsCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<V0Discount> {
            return localVarFp.discountsCreate(requestParameters.V0DiscountRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a batch of codes. This is used in the staff-dashboard. POST arguments are the same as in generate_discount_code - look there for details.
         * @param {DiscountsApiDiscountsCreateBatchCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsCreateBatchCreate(requestParameters: DiscountsApiDiscountsCreateBatchCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<V0Discount> {
            return localVarFp.discountsCreateBatchCreate(requestParameters.V0DiscountRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * API view set for Discounts
         * @param {DiscountsApiDiscountsDestroyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsDestroy(requestParameters: DiscountsApiDiscountsDestroyRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.discountsDestroy(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * API view set for Discounts
         * @param {DiscountsApiDiscountsListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsList(requestParameters: DiscountsApiDiscountsListRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedV0DiscountList> {
            return localVarFp.discountsList(requestParameters.is_redeemed, requestParameters.limit, requestParameters.offset, requestParameters.payment_type, requestParameters.q, requestParameters.redemption_type, options).then((request) => request(axios, basePath));
        },
        /**
         * API view set for Discounts
         * @param {DiscountsApiDiscountsPartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsPartialUpdate(requestParameters: DiscountsApiDiscountsPartialUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<V0Discount> {
            return localVarFp.discountsPartialUpdate(requestParameters.id, requestParameters.PatchedV0DiscountRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * API view set for Discounts
         * @param {DiscountsApiDiscountsProductsCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsProductsCreate(requestParameters: DiscountsApiDiscountsProductsCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<DiscountProduct> {
            return localVarFp.discountsProductsCreate(requestParameters.id, requestParameters.parent_lookup_discount, requestParameters.DiscountProductRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a linked product from a discount.
         * @param {DiscountsApiDiscountsProductsDestroyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsProductsDestroy(requestParameters: DiscountsApiDiscountsProductsDestroyRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.discountsProductsDestroy(requestParameters.id, requestParameters.parent_lookup_discount, options).then((request) => request(axios, basePath));
        },
        /**
         * API view set for Discounts
         * @param {DiscountsApiDiscountsProductsListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsProductsList(requestParameters: DiscountsApiDiscountsProductsListRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedDiscountProductList> {
            return localVarFp.discountsProductsList(requestParameters.id, requestParameters.parent_lookup_discount, requestParameters.limit, requestParameters.offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Partial update for a discount product.
         * @param {DiscountsApiDiscountsProductsPartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsProductsPartialUpdate(requestParameters: DiscountsApiDiscountsProductsPartialUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<DiscountProduct> {
            return localVarFp.discountsProductsPartialUpdate(requestParameters.id, requestParameters.parent_lookup_discount, requestParameters.PatchedDiscountProductRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * API view set for Discounts
         * @param {DiscountsApiDiscountsProductsRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsProductsRetrieve(requestParameters: DiscountsApiDiscountsProductsRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<DiscountProduct> {
            return localVarFp.discountsProductsRetrieve(requestParameters.id, requestParameters.parent_lookup_discount, options).then((request) => request(axios, basePath));
        },
        /**
         * API view set for Discounts
         * @param {DiscountsApiDiscountsProductsUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsProductsUpdate(requestParameters: DiscountsApiDiscountsProductsUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<DiscountProduct> {
            return localVarFp.discountsProductsUpdate(requestParameters.id, requestParameters.parent_lookup_discount, requestParameters.DiscountProductRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * API view set for Discount Redemptions
         * @param {DiscountsApiDiscountsRedemptionsCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsRedemptionsCreate(requestParameters: DiscountsApiDiscountsRedemptionsCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<DiscountRedemption> {
            return localVarFp.discountsRedemptionsCreate(requestParameters.id, requestParameters.parent_lookup_redeemed_discount, requestParameters.DiscountRedemptionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * API view set for Discount Redemptions
         * @param {DiscountsApiDiscountsRedemptionsDestroyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsRedemptionsDestroy(requestParameters: DiscountsApiDiscountsRedemptionsDestroyRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.discountsRedemptionsDestroy(requestParameters.id, requestParameters.parent_lookup_redeemed_discount, options).then((request) => request(axios, basePath));
        },
        /**
         * API view set for Discount Redemptions
         * @param {DiscountsApiDiscountsRedemptionsListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsRedemptionsList(requestParameters: DiscountsApiDiscountsRedemptionsListRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedDiscountRedemptionList> {
            return localVarFp.discountsRedemptionsList(requestParameters.id, requestParameters.parent_lookup_redeemed_discount, requestParameters.limit, requestParameters.offset, options).then((request) => request(axios, basePath));
        },
        /**
         * API view set for Discount Redemptions
         * @param {DiscountsApiDiscountsRedemptionsPartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsRedemptionsPartialUpdate(requestParameters: DiscountsApiDiscountsRedemptionsPartialUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<DiscountRedemption> {
            return localVarFp.discountsRedemptionsPartialUpdate(requestParameters.id, requestParameters.parent_lookup_redeemed_discount, requestParameters.PatchedDiscountRedemptionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * API view set for Discount Redemptions
         * @param {DiscountsApiDiscountsRedemptionsRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsRedemptionsRetrieve(requestParameters: DiscountsApiDiscountsRedemptionsRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<DiscountRedemption> {
            return localVarFp.discountsRedemptionsRetrieve(requestParameters.id, requestParameters.parent_lookup_redeemed_discount, options).then((request) => request(axios, basePath));
        },
        /**
         * API view set for Discount Redemptions
         * @param {DiscountsApiDiscountsRedemptionsUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsRedemptionsUpdate(requestParameters: DiscountsApiDiscountsRedemptionsUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<DiscountRedemption> {
            return localVarFp.discountsRedemptionsUpdate(requestParameters.id, requestParameters.parent_lookup_redeemed_discount, requestParameters.DiscountRedemptionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * API view set for Discounts
         * @param {DiscountsApiDiscountsRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsRetrieve(requestParameters: DiscountsApiDiscountsRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<V0Discount> {
            return localVarFp.discountsRetrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * API view set for Flexible Pricing Tiers. This one is for use within a Discount.
         * @param {DiscountsApiDiscountsTiersCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsTiersCreate(requestParameters: DiscountsApiDiscountsTiersCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlexiblePriceTier> {
            return localVarFp.discountsTiersCreate(requestParameters.id, requestParameters.parent_lookup_discount, requestParameters.FlexiblePriceTierRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * API view set for Flexible Pricing Tiers. This one is for use within a Discount.
         * @param {DiscountsApiDiscountsTiersDestroyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsTiersDestroy(requestParameters: DiscountsApiDiscountsTiersDestroyRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.discountsTiersDestroy(requestParameters.id, requestParameters.parent_lookup_discount, options).then((request) => request(axios, basePath));
        },
        /**
         * API view set for Flexible Pricing Tiers. This one is for use within a Discount.
         * @param {DiscountsApiDiscountsTiersListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsTiersList(requestParameters: DiscountsApiDiscountsTiersListRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedFlexiblePriceTierList> {
            return localVarFp.discountsTiersList(requestParameters.id, requestParameters.parent_lookup_discount, requestParameters.limit, requestParameters.offset, options).then((request) => request(axios, basePath));
        },
        /**
         * API view set for Flexible Pricing Tiers. This one is for use within a Discount.
         * @param {DiscountsApiDiscountsTiersPartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsTiersPartialUpdate(requestParameters: DiscountsApiDiscountsTiersPartialUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlexiblePriceTier> {
            return localVarFp.discountsTiersPartialUpdate(requestParameters.id, requestParameters.parent_lookup_discount, requestParameters.PatchedFlexiblePriceTierRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * API view set for Flexible Pricing Tiers. This one is for use within a Discount.
         * @param {DiscountsApiDiscountsTiersRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsTiersRetrieve(requestParameters: DiscountsApiDiscountsTiersRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlexiblePriceTier> {
            return localVarFp.discountsTiersRetrieve(requestParameters.id, requestParameters.parent_lookup_discount, options).then((request) => request(axios, basePath));
        },
        /**
         * API view set for Flexible Pricing Tiers. This one is for use within a Discount.
         * @param {DiscountsApiDiscountsTiersUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsTiersUpdate(requestParameters: DiscountsApiDiscountsTiersUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlexiblePriceTier> {
            return localVarFp.discountsTiersUpdate(requestParameters.id, requestParameters.parent_lookup_discount, requestParameters.FlexiblePriceTierRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * API view set for Discounts
         * @param {DiscountsApiDiscountsUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsUpdate(requestParameters: DiscountsApiDiscountsUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<V0Discount> {
            return localVarFp.discountsUpdate(requestParameters.id, requestParameters.V0DiscountRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for discountsAssigneesCreate operation in DiscountsApi.
 * @export
 * @interface DiscountsApiDiscountsAssigneesCreateRequest
 */
export interface DiscountsApiDiscountsAssigneesCreateRequest {
    /**
     * ID of the user discount
     * @type {number}
     * @memberof DiscountsApiDiscountsAssigneesCreate
     */
    readonly id: number

    /**
     * ID of the parent discount
     * @type {number}
     * @memberof DiscountsApiDiscountsAssigneesCreate
     */
    readonly parent_lookup_discount: number

    /**
     * 
     * @type {UserDiscountMetaRequest}
     * @memberof DiscountsApiDiscountsAssigneesCreate
     */
    readonly UserDiscountMetaRequest: UserDiscountMetaRequest
}

/**
 * Request parameters for discountsAssigneesDestroy operation in DiscountsApi.
 * @export
 * @interface DiscountsApiDiscountsAssigneesDestroyRequest
 */
export interface DiscountsApiDiscountsAssigneesDestroyRequest {
    /**
     * ID of the user discount
     * @type {number}
     * @memberof DiscountsApiDiscountsAssigneesDestroy
     */
    readonly id: number

    /**
     * ID of the parent discount
     * @type {number}
     * @memberof DiscountsApiDiscountsAssigneesDestroy
     */
    readonly parent_lookup_discount: number
}

/**
 * Request parameters for discountsAssigneesList operation in DiscountsApi.
 * @export
 * @interface DiscountsApiDiscountsAssigneesListRequest
 */
export interface DiscountsApiDiscountsAssigneesListRequest {
    /**
     * ID of the user discount
     * @type {number}
     * @memberof DiscountsApiDiscountsAssigneesList
     */
    readonly id: number

    /**
     * ID of the parent discount
     * @type {number}
     * @memberof DiscountsApiDiscountsAssigneesList
     */
    readonly parent_lookup_discount: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof DiscountsApiDiscountsAssigneesList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof DiscountsApiDiscountsAssigneesList
     */
    readonly offset?: number
}

/**
 * Request parameters for discountsAssigneesPartialUpdate operation in DiscountsApi.
 * @export
 * @interface DiscountsApiDiscountsAssigneesPartialUpdateRequest
 */
export interface DiscountsApiDiscountsAssigneesPartialUpdateRequest {
    /**
     * ID of the user discount
     * @type {number}
     * @memberof DiscountsApiDiscountsAssigneesPartialUpdate
     */
    readonly id: number

    /**
     * ID of the parent discount
     * @type {number}
     * @memberof DiscountsApiDiscountsAssigneesPartialUpdate
     */
    readonly parent_lookup_discount: number

    /**
     * 
     * @type {PatchedUserDiscountMetaRequest}
     * @memberof DiscountsApiDiscountsAssigneesPartialUpdate
     */
    readonly PatchedUserDiscountMetaRequest?: PatchedUserDiscountMetaRequest
}

/**
 * Request parameters for discountsAssigneesRetrieve operation in DiscountsApi.
 * @export
 * @interface DiscountsApiDiscountsAssigneesRetrieveRequest
 */
export interface DiscountsApiDiscountsAssigneesRetrieveRequest {
    /**
     * ID of the user discount
     * @type {number}
     * @memberof DiscountsApiDiscountsAssigneesRetrieve
     */
    readonly id: number

    /**
     * ID of the parent discount
     * @type {number}
     * @memberof DiscountsApiDiscountsAssigneesRetrieve
     */
    readonly parent_lookup_discount: number
}

/**
 * Request parameters for discountsAssigneesUpdate operation in DiscountsApi.
 * @export
 * @interface DiscountsApiDiscountsAssigneesUpdateRequest
 */
export interface DiscountsApiDiscountsAssigneesUpdateRequest {
    /**
     * ID of the user discount
     * @type {number}
     * @memberof DiscountsApiDiscountsAssigneesUpdate
     */
    readonly id: number

    /**
     * ID of the parent discount
     * @type {number}
     * @memberof DiscountsApiDiscountsAssigneesUpdate
     */
    readonly parent_lookup_discount: number

    /**
     * 
     * @type {UserDiscountMetaRequest}
     * @memberof DiscountsApiDiscountsAssigneesUpdate
     */
    readonly UserDiscountMetaRequest: UserDiscountMetaRequest
}

/**
 * Request parameters for discountsCreate operation in DiscountsApi.
 * @export
 * @interface DiscountsApiDiscountsCreateRequest
 */
export interface DiscountsApiDiscountsCreateRequest {
    /**
     * 
     * @type {V0DiscountRequest}
     * @memberof DiscountsApiDiscountsCreate
     */
    readonly V0DiscountRequest: V0DiscountRequest
}

/**
 * Request parameters for discountsCreateBatchCreate operation in DiscountsApi.
 * @export
 * @interface DiscountsApiDiscountsCreateBatchCreateRequest
 */
export interface DiscountsApiDiscountsCreateBatchCreateRequest {
    /**
     * 
     * @type {V0DiscountRequest}
     * @memberof DiscountsApiDiscountsCreateBatchCreate
     */
    readonly V0DiscountRequest: V0DiscountRequest
}

/**
 * Request parameters for discountsDestroy operation in DiscountsApi.
 * @export
 * @interface DiscountsApiDiscountsDestroyRequest
 */
export interface DiscountsApiDiscountsDestroyRequest {
    /**
     * A unique integer value identifying this discount.
     * @type {number}
     * @memberof DiscountsApiDiscountsDestroy
     */
    readonly id: number
}

/**
 * Request parameters for discountsList operation in DiscountsApi.
 * @export
 * @interface DiscountsApiDiscountsListRequest
 */
export interface DiscountsApiDiscountsListRequest {
    /**
     * * &#x60;yes&#x60; - yes * &#x60;no&#x60; - no
     * @type {'no' | 'yes'}
     * @memberof DiscountsApiDiscountsList
     */
    readonly is_redeemed?: DiscountsListIsRedeemedEnum

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof DiscountsApiDiscountsList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof DiscountsApiDiscountsList
     */
    readonly offset?: number

    /**
     * * &#x60;marketing&#x60; - marketing * &#x60;sales&#x60; - sales * &#x60;financial-assistance&#x60; - financial-assistance * &#x60;customer-support&#x60; - customer-support * &#x60;staff&#x60; - staff * &#x60;legacy&#x60; - legacy
     * @type {'customer-support' | 'financial-assistance' | 'legacy' | 'marketing' | 'sales' | 'staff'}
     * @memberof DiscountsApiDiscountsList
     */
    readonly payment_type?: DiscountsListPaymentTypeEnum

    /**
     * q
     * @type {string}
     * @memberof DiscountsApiDiscountsList
     */
    readonly q?: string

    /**
     * * &#x60;one-time&#x60; - one-time * &#x60;one-time-per-user&#x60; - one-time-per-user * &#x60;unlimited&#x60; - unlimited
     * @type {'one-time' | 'one-time-per-user' | 'unlimited'}
     * @memberof DiscountsApiDiscountsList
     */
    readonly redemption_type?: DiscountsListRedemptionTypeEnum
}

/**
 * Request parameters for discountsPartialUpdate operation in DiscountsApi.
 * @export
 * @interface DiscountsApiDiscountsPartialUpdateRequest
 */
export interface DiscountsApiDiscountsPartialUpdateRequest {
    /**
     * A unique integer value identifying this discount.
     * @type {number}
     * @memberof DiscountsApiDiscountsPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {PatchedV0DiscountRequest}
     * @memberof DiscountsApiDiscountsPartialUpdate
     */
    readonly PatchedV0DiscountRequest?: PatchedV0DiscountRequest
}

/**
 * Request parameters for discountsProductsCreate operation in DiscountsApi.
 * @export
 * @interface DiscountsApiDiscountsProductsCreateRequest
 */
export interface DiscountsApiDiscountsProductsCreateRequest {
    /**
     * ID of the discount product
     * @type {number}
     * @memberof DiscountsApiDiscountsProductsCreate
     */
    readonly id: number

    /**
     * ID of the parent discount
     * @type {number}
     * @memberof DiscountsApiDiscountsProductsCreate
     */
    readonly parent_lookup_discount: number

    /**
     * 
     * @type {DiscountProductRequest}
     * @memberof DiscountsApiDiscountsProductsCreate
     */
    readonly DiscountProductRequest: DiscountProductRequest
}

/**
 * Request parameters for discountsProductsDestroy operation in DiscountsApi.
 * @export
 * @interface DiscountsApiDiscountsProductsDestroyRequest
 */
export interface DiscountsApiDiscountsProductsDestroyRequest {
    /**
     * ID of the discount product
     * @type {number}
     * @memberof DiscountsApiDiscountsProductsDestroy
     */
    readonly id: number

    /**
     * ID of the parent discount
     * @type {number}
     * @memberof DiscountsApiDiscountsProductsDestroy
     */
    readonly parent_lookup_discount: number
}

/**
 * Request parameters for discountsProductsList operation in DiscountsApi.
 * @export
 * @interface DiscountsApiDiscountsProductsListRequest
 */
export interface DiscountsApiDiscountsProductsListRequest {
    /**
     * ID of the discount product
     * @type {number}
     * @memberof DiscountsApiDiscountsProductsList
     */
    readonly id: number

    /**
     * ID of the parent discount
     * @type {number}
     * @memberof DiscountsApiDiscountsProductsList
     */
    readonly parent_lookup_discount: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof DiscountsApiDiscountsProductsList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof DiscountsApiDiscountsProductsList
     */
    readonly offset?: number
}

/**
 * Request parameters for discountsProductsPartialUpdate operation in DiscountsApi.
 * @export
 * @interface DiscountsApiDiscountsProductsPartialUpdateRequest
 */
export interface DiscountsApiDiscountsProductsPartialUpdateRequest {
    /**
     * ID of the discount product
     * @type {number}
     * @memberof DiscountsApiDiscountsProductsPartialUpdate
     */
    readonly id: number

    /**
     * ID of the parent discount
     * @type {number}
     * @memberof DiscountsApiDiscountsProductsPartialUpdate
     */
    readonly parent_lookup_discount: number

    /**
     * 
     * @type {PatchedDiscountProductRequest}
     * @memberof DiscountsApiDiscountsProductsPartialUpdate
     */
    readonly PatchedDiscountProductRequest?: PatchedDiscountProductRequest
}

/**
 * Request parameters for discountsProductsRetrieve operation in DiscountsApi.
 * @export
 * @interface DiscountsApiDiscountsProductsRetrieveRequest
 */
export interface DiscountsApiDiscountsProductsRetrieveRequest {
    /**
     * ID of the discount product
     * @type {number}
     * @memberof DiscountsApiDiscountsProductsRetrieve
     */
    readonly id: number

    /**
     * ID of the parent discount
     * @type {number}
     * @memberof DiscountsApiDiscountsProductsRetrieve
     */
    readonly parent_lookup_discount: number
}

/**
 * Request parameters for discountsProductsUpdate operation in DiscountsApi.
 * @export
 * @interface DiscountsApiDiscountsProductsUpdateRequest
 */
export interface DiscountsApiDiscountsProductsUpdateRequest {
    /**
     * ID of the discount product
     * @type {number}
     * @memberof DiscountsApiDiscountsProductsUpdate
     */
    readonly id: number

    /**
     * ID of the parent discount
     * @type {number}
     * @memberof DiscountsApiDiscountsProductsUpdate
     */
    readonly parent_lookup_discount: number

    /**
     * 
     * @type {DiscountProductRequest}
     * @memberof DiscountsApiDiscountsProductsUpdate
     */
    readonly DiscountProductRequest: DiscountProductRequest
}

/**
 * Request parameters for discountsRedemptionsCreate operation in DiscountsApi.
 * @export
 * @interface DiscountsApiDiscountsRedemptionsCreateRequest
 */
export interface DiscountsApiDiscountsRedemptionsCreateRequest {
    /**
     * ID of the user discount
     * @type {number}
     * @memberof DiscountsApiDiscountsRedemptionsCreate
     */
    readonly id: number

    /**
     * ID of the parent discount
     * @type {number}
     * @memberof DiscountsApiDiscountsRedemptionsCreate
     */
    readonly parent_lookup_redeemed_discount: number

    /**
     * 
     * @type {DiscountRedemptionRequest}
     * @memberof DiscountsApiDiscountsRedemptionsCreate
     */
    readonly DiscountRedemptionRequest: DiscountRedemptionRequest
}

/**
 * Request parameters for discountsRedemptionsDestroy operation in DiscountsApi.
 * @export
 * @interface DiscountsApiDiscountsRedemptionsDestroyRequest
 */
export interface DiscountsApiDiscountsRedemptionsDestroyRequest {
    /**
     * ID of the user discount
     * @type {number}
     * @memberof DiscountsApiDiscountsRedemptionsDestroy
     */
    readonly id: number

    /**
     * ID of the parent discount
     * @type {number}
     * @memberof DiscountsApiDiscountsRedemptionsDestroy
     */
    readonly parent_lookup_redeemed_discount: number
}

/**
 * Request parameters for discountsRedemptionsList operation in DiscountsApi.
 * @export
 * @interface DiscountsApiDiscountsRedemptionsListRequest
 */
export interface DiscountsApiDiscountsRedemptionsListRequest {
    /**
     * ID of the user discount
     * @type {number}
     * @memberof DiscountsApiDiscountsRedemptionsList
     */
    readonly id: number

    /**
     * ID of the parent discount
     * @type {number}
     * @memberof DiscountsApiDiscountsRedemptionsList
     */
    readonly parent_lookup_redeemed_discount: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof DiscountsApiDiscountsRedemptionsList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof DiscountsApiDiscountsRedemptionsList
     */
    readonly offset?: number
}

/**
 * Request parameters for discountsRedemptionsPartialUpdate operation in DiscountsApi.
 * @export
 * @interface DiscountsApiDiscountsRedemptionsPartialUpdateRequest
 */
export interface DiscountsApiDiscountsRedemptionsPartialUpdateRequest {
    /**
     * ID of the user discount
     * @type {number}
     * @memberof DiscountsApiDiscountsRedemptionsPartialUpdate
     */
    readonly id: number

    /**
     * ID of the parent discount
     * @type {number}
     * @memberof DiscountsApiDiscountsRedemptionsPartialUpdate
     */
    readonly parent_lookup_redeemed_discount: number

    /**
     * 
     * @type {PatchedDiscountRedemptionRequest}
     * @memberof DiscountsApiDiscountsRedemptionsPartialUpdate
     */
    readonly PatchedDiscountRedemptionRequest?: PatchedDiscountRedemptionRequest
}

/**
 * Request parameters for discountsRedemptionsRetrieve operation in DiscountsApi.
 * @export
 * @interface DiscountsApiDiscountsRedemptionsRetrieveRequest
 */
export interface DiscountsApiDiscountsRedemptionsRetrieveRequest {
    /**
     * ID of the user discount
     * @type {number}
     * @memberof DiscountsApiDiscountsRedemptionsRetrieve
     */
    readonly id: number

    /**
     * ID of the parent discount
     * @type {number}
     * @memberof DiscountsApiDiscountsRedemptionsRetrieve
     */
    readonly parent_lookup_redeemed_discount: number
}

/**
 * Request parameters for discountsRedemptionsUpdate operation in DiscountsApi.
 * @export
 * @interface DiscountsApiDiscountsRedemptionsUpdateRequest
 */
export interface DiscountsApiDiscountsRedemptionsUpdateRequest {
    /**
     * ID of the user discount
     * @type {number}
     * @memberof DiscountsApiDiscountsRedemptionsUpdate
     */
    readonly id: number

    /**
     * ID of the parent discount
     * @type {number}
     * @memberof DiscountsApiDiscountsRedemptionsUpdate
     */
    readonly parent_lookup_redeemed_discount: number

    /**
     * 
     * @type {DiscountRedemptionRequest}
     * @memberof DiscountsApiDiscountsRedemptionsUpdate
     */
    readonly DiscountRedemptionRequest: DiscountRedemptionRequest
}

/**
 * Request parameters for discountsRetrieve operation in DiscountsApi.
 * @export
 * @interface DiscountsApiDiscountsRetrieveRequest
 */
export interface DiscountsApiDiscountsRetrieveRequest {
    /**
     * A unique integer value identifying this discount.
     * @type {number}
     * @memberof DiscountsApiDiscountsRetrieve
     */
    readonly id: number
}

/**
 * Request parameters for discountsTiersCreate operation in DiscountsApi.
 * @export
 * @interface DiscountsApiDiscountsTiersCreateRequest
 */
export interface DiscountsApiDiscountsTiersCreateRequest {
    /**
     * ID of the user discount
     * @type {number}
     * @memberof DiscountsApiDiscountsTiersCreate
     */
    readonly id: number

    /**
     * ID of the parent discount
     * @type {number}
     * @memberof DiscountsApiDiscountsTiersCreate
     */
    readonly parent_lookup_discount: number

    /**
     * 
     * @type {FlexiblePriceTierRequest}
     * @memberof DiscountsApiDiscountsTiersCreate
     */
    readonly FlexiblePriceTierRequest: FlexiblePriceTierRequest
}

/**
 * Request parameters for discountsTiersDestroy operation in DiscountsApi.
 * @export
 * @interface DiscountsApiDiscountsTiersDestroyRequest
 */
export interface DiscountsApiDiscountsTiersDestroyRequest {
    /**
     * ID of the user discount
     * @type {number}
     * @memberof DiscountsApiDiscountsTiersDestroy
     */
    readonly id: number

    /**
     * ID of the parent discount
     * @type {number}
     * @memberof DiscountsApiDiscountsTiersDestroy
     */
    readonly parent_lookup_discount: number
}

/**
 * Request parameters for discountsTiersList operation in DiscountsApi.
 * @export
 * @interface DiscountsApiDiscountsTiersListRequest
 */
export interface DiscountsApiDiscountsTiersListRequest {
    /**
     * ID of the user discount
     * @type {number}
     * @memberof DiscountsApiDiscountsTiersList
     */
    readonly id: number

    /**
     * ID of the parent discount
     * @type {number}
     * @memberof DiscountsApiDiscountsTiersList
     */
    readonly parent_lookup_discount: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof DiscountsApiDiscountsTiersList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof DiscountsApiDiscountsTiersList
     */
    readonly offset?: number
}

/**
 * Request parameters for discountsTiersPartialUpdate operation in DiscountsApi.
 * @export
 * @interface DiscountsApiDiscountsTiersPartialUpdateRequest
 */
export interface DiscountsApiDiscountsTiersPartialUpdateRequest {
    /**
     * ID of the user discount
     * @type {number}
     * @memberof DiscountsApiDiscountsTiersPartialUpdate
     */
    readonly id: number

    /**
     * ID of the parent discount
     * @type {number}
     * @memberof DiscountsApiDiscountsTiersPartialUpdate
     */
    readonly parent_lookup_discount: number

    /**
     * 
     * @type {PatchedFlexiblePriceTierRequest}
     * @memberof DiscountsApiDiscountsTiersPartialUpdate
     */
    readonly PatchedFlexiblePriceTierRequest?: PatchedFlexiblePriceTierRequest
}

/**
 * Request parameters for discountsTiersRetrieve operation in DiscountsApi.
 * @export
 * @interface DiscountsApiDiscountsTiersRetrieveRequest
 */
export interface DiscountsApiDiscountsTiersRetrieveRequest {
    /**
     * ID of the user discount
     * @type {number}
     * @memberof DiscountsApiDiscountsTiersRetrieve
     */
    readonly id: number

    /**
     * ID of the parent discount
     * @type {number}
     * @memberof DiscountsApiDiscountsTiersRetrieve
     */
    readonly parent_lookup_discount: number
}

/**
 * Request parameters for discountsTiersUpdate operation in DiscountsApi.
 * @export
 * @interface DiscountsApiDiscountsTiersUpdateRequest
 */
export interface DiscountsApiDiscountsTiersUpdateRequest {
    /**
     * ID of the user discount
     * @type {number}
     * @memberof DiscountsApiDiscountsTiersUpdate
     */
    readonly id: number

    /**
     * ID of the parent discount
     * @type {number}
     * @memberof DiscountsApiDiscountsTiersUpdate
     */
    readonly parent_lookup_discount: number

    /**
     * 
     * @type {FlexiblePriceTierRequest}
     * @memberof DiscountsApiDiscountsTiersUpdate
     */
    readonly FlexiblePriceTierRequest: FlexiblePriceTierRequest
}

/**
 * Request parameters for discountsUpdate operation in DiscountsApi.
 * @export
 * @interface DiscountsApiDiscountsUpdateRequest
 */
export interface DiscountsApiDiscountsUpdateRequest {
    /**
     * A unique integer value identifying this discount.
     * @type {number}
     * @memberof DiscountsApiDiscountsUpdate
     */
    readonly id: number

    /**
     * 
     * @type {V0DiscountRequest}
     * @memberof DiscountsApiDiscountsUpdate
     */
    readonly V0DiscountRequest: V0DiscountRequest
}

/**
 * DiscountsApi - object-oriented interface
 * @export
 * @class DiscountsApi
 * @extends {BaseAPI}
 */
export class DiscountsApi extends BaseAPI {
    /**
     * Create an association between a user and a discount.
     * @param {DiscountsApiDiscountsAssigneesCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountsApi
     */
    public discountsAssigneesCreate(requestParameters: DiscountsApiDiscountsAssigneesCreateRequest, options?: RawAxiosRequestConfig) {
        return DiscountsApiFp(this.configuration).discountsAssigneesCreate(requestParameters.id, requestParameters.parent_lookup_discount, requestParameters.UserDiscountMetaRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a user discount.
     * @param {DiscountsApiDiscountsAssigneesDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountsApi
     */
    public discountsAssigneesDestroy(requestParameters: DiscountsApiDiscountsAssigneesDestroyRequest, options?: RawAxiosRequestConfig) {
        return DiscountsApiFp(this.configuration).discountsAssigneesDestroy(requestParameters.id, requestParameters.parent_lookup_discount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API view set for User Discounts. This one is for use within a Discount.
     * @param {DiscountsApiDiscountsAssigneesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountsApi
     */
    public discountsAssigneesList(requestParameters: DiscountsApiDiscountsAssigneesListRequest, options?: RawAxiosRequestConfig) {
        return DiscountsApiFp(this.configuration).discountsAssigneesList(requestParameters.id, requestParameters.parent_lookup_discount, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Partial update for a user discount.
     * @param {DiscountsApiDiscountsAssigneesPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountsApi
     */
    public discountsAssigneesPartialUpdate(requestParameters: DiscountsApiDiscountsAssigneesPartialUpdateRequest, options?: RawAxiosRequestConfig) {
        return DiscountsApiFp(this.configuration).discountsAssigneesPartialUpdate(requestParameters.id, requestParameters.parent_lookup_discount, requestParameters.PatchedUserDiscountMetaRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API view set for User Discounts. This one is for use within a Discount.
     * @param {DiscountsApiDiscountsAssigneesRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountsApi
     */
    public discountsAssigneesRetrieve(requestParameters: DiscountsApiDiscountsAssigneesRetrieveRequest, options?: RawAxiosRequestConfig) {
        return DiscountsApiFp(this.configuration).discountsAssigneesRetrieve(requestParameters.id, requestParameters.parent_lookup_discount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API view set for User Discounts. This one is for use within a Discount.
     * @param {DiscountsApiDiscountsAssigneesUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountsApi
     */
    public discountsAssigneesUpdate(requestParameters: DiscountsApiDiscountsAssigneesUpdateRequest, options?: RawAxiosRequestConfig) {
        return DiscountsApiFp(this.configuration).discountsAssigneesUpdate(requestParameters.id, requestParameters.parent_lookup_discount, requestParameters.UserDiscountMetaRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API view set for Discounts
     * @param {DiscountsApiDiscountsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountsApi
     */
    public discountsCreate(requestParameters: DiscountsApiDiscountsCreateRequest, options?: RawAxiosRequestConfig) {
        return DiscountsApiFp(this.configuration).discountsCreate(requestParameters.V0DiscountRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a batch of codes. This is used in the staff-dashboard. POST arguments are the same as in generate_discount_code - look there for details.
     * @param {DiscountsApiDiscountsCreateBatchCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountsApi
     */
    public discountsCreateBatchCreate(requestParameters: DiscountsApiDiscountsCreateBatchCreateRequest, options?: RawAxiosRequestConfig) {
        return DiscountsApiFp(this.configuration).discountsCreateBatchCreate(requestParameters.V0DiscountRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API view set for Discounts
     * @param {DiscountsApiDiscountsDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountsApi
     */
    public discountsDestroy(requestParameters: DiscountsApiDiscountsDestroyRequest, options?: RawAxiosRequestConfig) {
        return DiscountsApiFp(this.configuration).discountsDestroy(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API view set for Discounts
     * @param {DiscountsApiDiscountsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountsApi
     */
    public discountsList(requestParameters: DiscountsApiDiscountsListRequest = {}, options?: RawAxiosRequestConfig) {
        return DiscountsApiFp(this.configuration).discountsList(requestParameters.is_redeemed, requestParameters.limit, requestParameters.offset, requestParameters.payment_type, requestParameters.q, requestParameters.redemption_type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API view set for Discounts
     * @param {DiscountsApiDiscountsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountsApi
     */
    public discountsPartialUpdate(requestParameters: DiscountsApiDiscountsPartialUpdateRequest, options?: RawAxiosRequestConfig) {
        return DiscountsApiFp(this.configuration).discountsPartialUpdate(requestParameters.id, requestParameters.PatchedV0DiscountRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API view set for Discounts
     * @param {DiscountsApiDiscountsProductsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountsApi
     */
    public discountsProductsCreate(requestParameters: DiscountsApiDiscountsProductsCreateRequest, options?: RawAxiosRequestConfig) {
        return DiscountsApiFp(this.configuration).discountsProductsCreate(requestParameters.id, requestParameters.parent_lookup_discount, requestParameters.DiscountProductRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a linked product from a discount.
     * @param {DiscountsApiDiscountsProductsDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountsApi
     */
    public discountsProductsDestroy(requestParameters: DiscountsApiDiscountsProductsDestroyRequest, options?: RawAxiosRequestConfig) {
        return DiscountsApiFp(this.configuration).discountsProductsDestroy(requestParameters.id, requestParameters.parent_lookup_discount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API view set for Discounts
     * @param {DiscountsApiDiscountsProductsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountsApi
     */
    public discountsProductsList(requestParameters: DiscountsApiDiscountsProductsListRequest, options?: RawAxiosRequestConfig) {
        return DiscountsApiFp(this.configuration).discountsProductsList(requestParameters.id, requestParameters.parent_lookup_discount, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Partial update for a discount product.
     * @param {DiscountsApiDiscountsProductsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountsApi
     */
    public discountsProductsPartialUpdate(requestParameters: DiscountsApiDiscountsProductsPartialUpdateRequest, options?: RawAxiosRequestConfig) {
        return DiscountsApiFp(this.configuration).discountsProductsPartialUpdate(requestParameters.id, requestParameters.parent_lookup_discount, requestParameters.PatchedDiscountProductRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API view set for Discounts
     * @param {DiscountsApiDiscountsProductsRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountsApi
     */
    public discountsProductsRetrieve(requestParameters: DiscountsApiDiscountsProductsRetrieveRequest, options?: RawAxiosRequestConfig) {
        return DiscountsApiFp(this.configuration).discountsProductsRetrieve(requestParameters.id, requestParameters.parent_lookup_discount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API view set for Discounts
     * @param {DiscountsApiDiscountsProductsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountsApi
     */
    public discountsProductsUpdate(requestParameters: DiscountsApiDiscountsProductsUpdateRequest, options?: RawAxiosRequestConfig) {
        return DiscountsApiFp(this.configuration).discountsProductsUpdate(requestParameters.id, requestParameters.parent_lookup_discount, requestParameters.DiscountProductRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API view set for Discount Redemptions
     * @param {DiscountsApiDiscountsRedemptionsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountsApi
     */
    public discountsRedemptionsCreate(requestParameters: DiscountsApiDiscountsRedemptionsCreateRequest, options?: RawAxiosRequestConfig) {
        return DiscountsApiFp(this.configuration).discountsRedemptionsCreate(requestParameters.id, requestParameters.parent_lookup_redeemed_discount, requestParameters.DiscountRedemptionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API view set for Discount Redemptions
     * @param {DiscountsApiDiscountsRedemptionsDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountsApi
     */
    public discountsRedemptionsDestroy(requestParameters: DiscountsApiDiscountsRedemptionsDestroyRequest, options?: RawAxiosRequestConfig) {
        return DiscountsApiFp(this.configuration).discountsRedemptionsDestroy(requestParameters.id, requestParameters.parent_lookup_redeemed_discount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API view set for Discount Redemptions
     * @param {DiscountsApiDiscountsRedemptionsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountsApi
     */
    public discountsRedemptionsList(requestParameters: DiscountsApiDiscountsRedemptionsListRequest, options?: RawAxiosRequestConfig) {
        return DiscountsApiFp(this.configuration).discountsRedemptionsList(requestParameters.id, requestParameters.parent_lookup_redeemed_discount, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API view set for Discount Redemptions
     * @param {DiscountsApiDiscountsRedemptionsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountsApi
     */
    public discountsRedemptionsPartialUpdate(requestParameters: DiscountsApiDiscountsRedemptionsPartialUpdateRequest, options?: RawAxiosRequestConfig) {
        return DiscountsApiFp(this.configuration).discountsRedemptionsPartialUpdate(requestParameters.id, requestParameters.parent_lookup_redeemed_discount, requestParameters.PatchedDiscountRedemptionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API view set for Discount Redemptions
     * @param {DiscountsApiDiscountsRedemptionsRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountsApi
     */
    public discountsRedemptionsRetrieve(requestParameters: DiscountsApiDiscountsRedemptionsRetrieveRequest, options?: RawAxiosRequestConfig) {
        return DiscountsApiFp(this.configuration).discountsRedemptionsRetrieve(requestParameters.id, requestParameters.parent_lookup_redeemed_discount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API view set for Discount Redemptions
     * @param {DiscountsApiDiscountsRedemptionsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountsApi
     */
    public discountsRedemptionsUpdate(requestParameters: DiscountsApiDiscountsRedemptionsUpdateRequest, options?: RawAxiosRequestConfig) {
        return DiscountsApiFp(this.configuration).discountsRedemptionsUpdate(requestParameters.id, requestParameters.parent_lookup_redeemed_discount, requestParameters.DiscountRedemptionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API view set for Discounts
     * @param {DiscountsApiDiscountsRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountsApi
     */
    public discountsRetrieve(requestParameters: DiscountsApiDiscountsRetrieveRequest, options?: RawAxiosRequestConfig) {
        return DiscountsApiFp(this.configuration).discountsRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API view set for Flexible Pricing Tiers. This one is for use within a Discount.
     * @param {DiscountsApiDiscountsTiersCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountsApi
     */
    public discountsTiersCreate(requestParameters: DiscountsApiDiscountsTiersCreateRequest, options?: RawAxiosRequestConfig) {
        return DiscountsApiFp(this.configuration).discountsTiersCreate(requestParameters.id, requestParameters.parent_lookup_discount, requestParameters.FlexiblePriceTierRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API view set for Flexible Pricing Tiers. This one is for use within a Discount.
     * @param {DiscountsApiDiscountsTiersDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountsApi
     */
    public discountsTiersDestroy(requestParameters: DiscountsApiDiscountsTiersDestroyRequest, options?: RawAxiosRequestConfig) {
        return DiscountsApiFp(this.configuration).discountsTiersDestroy(requestParameters.id, requestParameters.parent_lookup_discount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API view set for Flexible Pricing Tiers. This one is for use within a Discount.
     * @param {DiscountsApiDiscountsTiersListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountsApi
     */
    public discountsTiersList(requestParameters: DiscountsApiDiscountsTiersListRequest, options?: RawAxiosRequestConfig) {
        return DiscountsApiFp(this.configuration).discountsTiersList(requestParameters.id, requestParameters.parent_lookup_discount, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API view set for Flexible Pricing Tiers. This one is for use within a Discount.
     * @param {DiscountsApiDiscountsTiersPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountsApi
     */
    public discountsTiersPartialUpdate(requestParameters: DiscountsApiDiscountsTiersPartialUpdateRequest, options?: RawAxiosRequestConfig) {
        return DiscountsApiFp(this.configuration).discountsTiersPartialUpdate(requestParameters.id, requestParameters.parent_lookup_discount, requestParameters.PatchedFlexiblePriceTierRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API view set for Flexible Pricing Tiers. This one is for use within a Discount.
     * @param {DiscountsApiDiscountsTiersRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountsApi
     */
    public discountsTiersRetrieve(requestParameters: DiscountsApiDiscountsTiersRetrieveRequest, options?: RawAxiosRequestConfig) {
        return DiscountsApiFp(this.configuration).discountsTiersRetrieve(requestParameters.id, requestParameters.parent_lookup_discount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API view set for Flexible Pricing Tiers. This one is for use within a Discount.
     * @param {DiscountsApiDiscountsTiersUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountsApi
     */
    public discountsTiersUpdate(requestParameters: DiscountsApiDiscountsTiersUpdateRequest, options?: RawAxiosRequestConfig) {
        return DiscountsApiFp(this.configuration).discountsTiersUpdate(requestParameters.id, requestParameters.parent_lookup_discount, requestParameters.FlexiblePriceTierRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API view set for Discounts
     * @param {DiscountsApiDiscountsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountsApi
     */
    public discountsUpdate(requestParameters: DiscountsApiDiscountsUpdateRequest, options?: RawAxiosRequestConfig) {
        return DiscountsApiFp(this.configuration).discountsUpdate(requestParameters.id, requestParameters.V0DiscountRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const DiscountsListIsRedeemedEnum = {
    No: 'no',
    Yes: 'yes'
} as const;
export type DiscountsListIsRedeemedEnum = typeof DiscountsListIsRedeemedEnum[keyof typeof DiscountsListIsRedeemedEnum];
/**
 * @export
 */
export const DiscountsListPaymentTypeEnum = {
    CustomerSupport: 'customer-support',
    FinancialAssistance: 'financial-assistance',
    Legacy: 'legacy',
    Marketing: 'marketing',
    Sales: 'sales',
    Staff: 'staff'
} as const;
export type DiscountsListPaymentTypeEnum = typeof DiscountsListPaymentTypeEnum[keyof typeof DiscountsListPaymentTypeEnum];
/**
 * @export
 */
export const DiscountsListRedemptionTypeEnum = {
    OneTime: 'one-time',
    OneTimePerUser: 'one-time-per-user',
    Unlimited: 'unlimited'
} as const;
export type DiscountsListRedemptionTypeEnum = typeof DiscountsListRedemptionTypeEnum[keyof typeof DiscountsListRedemptionTypeEnum];


/**
 * EnrollmentsApi - axios parameter creator
 * @export
 */
export const EnrollmentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * View to handle direct POST requests to enroll in a course run.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiEnrollmentsCreate: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/enrollments/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API view set for user enrollments
         * @param {CourseRunEnrollmentRequest} CourseRunEnrollmentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enrollmentsCreate: async (CourseRunEnrollmentRequest: CourseRunEnrollmentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'CourseRunEnrollmentRequest' is not null or undefined
            assertParamExists('enrollmentsCreate', 'CourseRunEnrollmentRequest', CourseRunEnrollmentRequest)
            const localVarPath = `/api/v1/enrollments/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(CourseRunEnrollmentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API view set for user enrollments
         * @param {number} id A unique integer value identifying this course run enrollment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enrollmentsDestroy: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('enrollmentsDestroy', 'id', id)
            const localVarPath = `/api/v1/enrollments/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API view set for user enrollments
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enrollmentsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/enrollments/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update enrollment email preferences
         * @param {number} id A unique integer value identifying this course run enrollment.
         * @param {PatchedUpdateCourseRunEnrollmentRequest} [PatchedUpdateCourseRunEnrollmentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enrollmentsPartialUpdate: async (id: number, PatchedUpdateCourseRunEnrollmentRequest?: PatchedUpdateCourseRunEnrollmentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('enrollmentsPartialUpdate', 'id', id)
            const localVarPath = `/api/v1/enrollments/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(PatchedUpdateCourseRunEnrollmentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API view set for user enrollments
         * @param {number} id A unique integer value identifying this course run enrollment.
         * @param {CourseRunEnrollmentRequest} CourseRunEnrollmentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enrollmentsUpdate: async (id: number, CourseRunEnrollmentRequest: CourseRunEnrollmentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('enrollmentsUpdate', 'id', id)
            // verify required parameter 'CourseRunEnrollmentRequest' is not null or undefined
            assertParamExists('enrollmentsUpdate', 'CourseRunEnrollmentRequest', CourseRunEnrollmentRequest)
            const localVarPath = `/api/v1/enrollments/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(CourseRunEnrollmentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new user enrollment - API v2
         * @param {CourseRunEnrollmentRequestV2Request} CourseRunEnrollmentRequestV2Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userEnrollmentsCreateV2: async (CourseRunEnrollmentRequestV2Request: CourseRunEnrollmentRequestV2Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'CourseRunEnrollmentRequestV2Request' is not null or undefined
            assertParamExists('userEnrollmentsCreateV2', 'CourseRunEnrollmentRequestV2Request', CourseRunEnrollmentRequestV2Request)
            const localVarPath = `/api/v2/enrollments/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(CourseRunEnrollmentRequestV2Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unenroll from a course - API v2
         * @param {number} id A unique integer value identifying this course run enrollment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userEnrollmentsDestroyV2: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userEnrollmentsDestroyV2', 'id', id)
            const localVarPath = `/api/v2/enrollments/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List user enrollments with B2B organization and contract information - API v2. Use ?exclude_b2b=true to filter out enrollments linked to course runs with B2B contracts. Use ?org_id=<id> to filter enrollments by specific B2B organization.
         * @param {boolean} [exclude_b2b] Exclude B2B enrollments (enrollments linked to course runs with B2B contracts)
         * @param {number} [org_id] Filter by B2B organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userEnrollmentsListV2: async (exclude_b2b?: boolean, org_id?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/enrollments/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (exclude_b2b !== undefined) {
                localVarQueryParameter['exclude_b2b'] = exclude_b2b;
            }

            if (org_id !== undefined) {
                localVarQueryParameter['org_id'] = org_id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EnrollmentsApi - functional programming interface
 * @export
 */
export const EnrollmentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EnrollmentsApiAxiosParamCreator(configuration)
    return {
        /**
         * View to handle direct POST requests to enroll in a course run.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiEnrollmentsCreate(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiEnrollmentsCreate(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EnrollmentsApi.apiEnrollmentsCreate']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * API view set for user enrollments
         * @param {CourseRunEnrollmentRequest} CourseRunEnrollmentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async enrollmentsCreate(CourseRunEnrollmentRequest: CourseRunEnrollmentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseRunEnrollment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enrollmentsCreate(CourseRunEnrollmentRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EnrollmentsApi.enrollmentsCreate']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * API view set for user enrollments
         * @param {number} id A unique integer value identifying this course run enrollment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async enrollmentsDestroy(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enrollmentsDestroy(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EnrollmentsApi.enrollmentsDestroy']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * API view set for user enrollments
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async enrollmentsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CourseRunEnrollment>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enrollmentsList(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EnrollmentsApi.enrollmentsList']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Update enrollment email preferences
         * @param {number} id A unique integer value identifying this course run enrollment.
         * @param {PatchedUpdateCourseRunEnrollmentRequest} [PatchedUpdateCourseRunEnrollmentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async enrollmentsPartialUpdate(id: number, PatchedUpdateCourseRunEnrollmentRequest?: PatchedUpdateCourseRunEnrollmentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseRunEnrollment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enrollmentsPartialUpdate(id, PatchedUpdateCourseRunEnrollmentRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EnrollmentsApi.enrollmentsPartialUpdate']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * API view set for user enrollments
         * @param {number} id A unique integer value identifying this course run enrollment.
         * @param {CourseRunEnrollmentRequest} CourseRunEnrollmentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async enrollmentsUpdate(id: number, CourseRunEnrollmentRequest: CourseRunEnrollmentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseRunEnrollment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enrollmentsUpdate(id, CourseRunEnrollmentRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EnrollmentsApi.enrollmentsUpdate']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Create a new user enrollment - API v2
         * @param {CourseRunEnrollmentRequestV2Request} CourseRunEnrollmentRequestV2Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userEnrollmentsCreateV2(CourseRunEnrollmentRequestV2Request: CourseRunEnrollmentRequestV2Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseRunEnrollmentRequestV2>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userEnrollmentsCreateV2(CourseRunEnrollmentRequestV2Request, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EnrollmentsApi.userEnrollmentsCreateV2']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Unenroll from a course - API v2
         * @param {number} id A unique integer value identifying this course run enrollment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userEnrollmentsDestroyV2(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userEnrollmentsDestroyV2(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EnrollmentsApi.userEnrollmentsDestroyV2']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * List user enrollments with B2B organization and contract information - API v2. Use ?exclude_b2b=true to filter out enrollments linked to course runs with B2B contracts. Use ?org_id=<id> to filter enrollments by specific B2B organization.
         * @param {boolean} [exclude_b2b] Exclude B2B enrollments (enrollments linked to course runs with B2B contracts)
         * @param {number} [org_id] Filter by B2B organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userEnrollmentsListV2(exclude_b2b?: boolean, org_id?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CourseRunEnrollmentRequestV2>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userEnrollmentsListV2(exclude_b2b, org_id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EnrollmentsApi.userEnrollmentsListV2']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * EnrollmentsApi - factory interface
 * @export
 */
export const EnrollmentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EnrollmentsApiFp(configuration)
    return {
        /**
         * View to handle direct POST requests to enroll in a course run.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiEnrollmentsCreate(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiEnrollmentsCreate(options).then((request) => request(axios, basePath));
        },
        /**
         * API view set for user enrollments
         * @param {EnrollmentsApiEnrollmentsCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enrollmentsCreate(requestParameters: EnrollmentsApiEnrollmentsCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<CourseRunEnrollment> {
            return localVarFp.enrollmentsCreate(requestParameters.CourseRunEnrollmentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * API view set for user enrollments
         * @param {EnrollmentsApiEnrollmentsDestroyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enrollmentsDestroy(requestParameters: EnrollmentsApiEnrollmentsDestroyRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.enrollmentsDestroy(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * API view set for user enrollments
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enrollmentsList(options?: RawAxiosRequestConfig): AxiosPromise<Array<CourseRunEnrollment>> {
            return localVarFp.enrollmentsList(options).then((request) => request(axios, basePath));
        },
        /**
         * Update enrollment email preferences
         * @param {EnrollmentsApiEnrollmentsPartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enrollmentsPartialUpdate(requestParameters: EnrollmentsApiEnrollmentsPartialUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<CourseRunEnrollment> {
            return localVarFp.enrollmentsPartialUpdate(requestParameters.id, requestParameters.PatchedUpdateCourseRunEnrollmentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * API view set for user enrollments
         * @param {EnrollmentsApiEnrollmentsUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enrollmentsUpdate(requestParameters: EnrollmentsApiEnrollmentsUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<CourseRunEnrollment> {
            return localVarFp.enrollmentsUpdate(requestParameters.id, requestParameters.CourseRunEnrollmentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new user enrollment - API v2
         * @param {EnrollmentsApiUserEnrollmentsCreateV2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userEnrollmentsCreateV2(requestParameters: EnrollmentsApiUserEnrollmentsCreateV2Request, options?: RawAxiosRequestConfig): AxiosPromise<CourseRunEnrollmentRequestV2> {
            return localVarFp.userEnrollmentsCreateV2(requestParameters.CourseRunEnrollmentRequestV2Request, options).then((request) => request(axios, basePath));
        },
        /**
         * Unenroll from a course - API v2
         * @param {EnrollmentsApiUserEnrollmentsDestroyV2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userEnrollmentsDestroyV2(requestParameters: EnrollmentsApiUserEnrollmentsDestroyV2Request, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.userEnrollmentsDestroyV2(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * List user enrollments with B2B organization and contract information - API v2. Use ?exclude_b2b=true to filter out enrollments linked to course runs with B2B contracts. Use ?org_id=<id> to filter enrollments by specific B2B organization.
         * @param {EnrollmentsApiUserEnrollmentsListV2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userEnrollmentsListV2(requestParameters: EnrollmentsApiUserEnrollmentsListV2Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<Array<CourseRunEnrollmentRequestV2>> {
            return localVarFp.userEnrollmentsListV2(requestParameters.exclude_b2b, requestParameters.org_id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for enrollmentsCreate operation in EnrollmentsApi.
 * @export
 * @interface EnrollmentsApiEnrollmentsCreateRequest
 */
export interface EnrollmentsApiEnrollmentsCreateRequest {
    /**
     * 
     * @type {CourseRunEnrollmentRequest}
     * @memberof EnrollmentsApiEnrollmentsCreate
     */
    readonly CourseRunEnrollmentRequest: CourseRunEnrollmentRequest
}

/**
 * Request parameters for enrollmentsDestroy operation in EnrollmentsApi.
 * @export
 * @interface EnrollmentsApiEnrollmentsDestroyRequest
 */
export interface EnrollmentsApiEnrollmentsDestroyRequest {
    /**
     * A unique integer value identifying this course run enrollment.
     * @type {number}
     * @memberof EnrollmentsApiEnrollmentsDestroy
     */
    readonly id: number
}

/**
 * Request parameters for enrollmentsPartialUpdate operation in EnrollmentsApi.
 * @export
 * @interface EnrollmentsApiEnrollmentsPartialUpdateRequest
 */
export interface EnrollmentsApiEnrollmentsPartialUpdateRequest {
    /**
     * A unique integer value identifying this course run enrollment.
     * @type {number}
     * @memberof EnrollmentsApiEnrollmentsPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {PatchedUpdateCourseRunEnrollmentRequest}
     * @memberof EnrollmentsApiEnrollmentsPartialUpdate
     */
    readonly PatchedUpdateCourseRunEnrollmentRequest?: PatchedUpdateCourseRunEnrollmentRequest
}

/**
 * Request parameters for enrollmentsUpdate operation in EnrollmentsApi.
 * @export
 * @interface EnrollmentsApiEnrollmentsUpdateRequest
 */
export interface EnrollmentsApiEnrollmentsUpdateRequest {
    /**
     * A unique integer value identifying this course run enrollment.
     * @type {number}
     * @memberof EnrollmentsApiEnrollmentsUpdate
     */
    readonly id: number

    /**
     * 
     * @type {CourseRunEnrollmentRequest}
     * @memberof EnrollmentsApiEnrollmentsUpdate
     */
    readonly CourseRunEnrollmentRequest: CourseRunEnrollmentRequest
}

/**
 * Request parameters for userEnrollmentsCreateV2 operation in EnrollmentsApi.
 * @export
 * @interface EnrollmentsApiUserEnrollmentsCreateV2Request
 */
export interface EnrollmentsApiUserEnrollmentsCreateV2Request {
    /**
     * 
     * @type {CourseRunEnrollmentRequestV2Request}
     * @memberof EnrollmentsApiUserEnrollmentsCreateV2
     */
    readonly CourseRunEnrollmentRequestV2Request: CourseRunEnrollmentRequestV2Request
}

/**
 * Request parameters for userEnrollmentsDestroyV2 operation in EnrollmentsApi.
 * @export
 * @interface EnrollmentsApiUserEnrollmentsDestroyV2Request
 */
export interface EnrollmentsApiUserEnrollmentsDestroyV2Request {
    /**
     * A unique integer value identifying this course run enrollment.
     * @type {number}
     * @memberof EnrollmentsApiUserEnrollmentsDestroyV2
     */
    readonly id: number
}

/**
 * Request parameters for userEnrollmentsListV2 operation in EnrollmentsApi.
 * @export
 * @interface EnrollmentsApiUserEnrollmentsListV2Request
 */
export interface EnrollmentsApiUserEnrollmentsListV2Request {
    /**
     * Exclude B2B enrollments (enrollments linked to course runs with B2B contracts)
     * @type {boolean}
     * @memberof EnrollmentsApiUserEnrollmentsListV2
     */
    readonly exclude_b2b?: boolean

    /**
     * Filter by B2B organization ID
     * @type {number}
     * @memberof EnrollmentsApiUserEnrollmentsListV2
     */
    readonly org_id?: number
}

/**
 * EnrollmentsApi - object-oriented interface
 * @export
 * @class EnrollmentsApi
 * @extends {BaseAPI}
 */
export class EnrollmentsApi extends BaseAPI {
    /**
     * View to handle direct POST requests to enroll in a course run.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnrollmentsApi
     */
    public apiEnrollmentsCreate(options?: RawAxiosRequestConfig) {
        return EnrollmentsApiFp(this.configuration).apiEnrollmentsCreate(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API view set for user enrollments
     * @param {EnrollmentsApiEnrollmentsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnrollmentsApi
     */
    public enrollmentsCreate(requestParameters: EnrollmentsApiEnrollmentsCreateRequest, options?: RawAxiosRequestConfig) {
        return EnrollmentsApiFp(this.configuration).enrollmentsCreate(requestParameters.CourseRunEnrollmentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API view set for user enrollments
     * @param {EnrollmentsApiEnrollmentsDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnrollmentsApi
     */
    public enrollmentsDestroy(requestParameters: EnrollmentsApiEnrollmentsDestroyRequest, options?: RawAxiosRequestConfig) {
        return EnrollmentsApiFp(this.configuration).enrollmentsDestroy(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API view set for user enrollments
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnrollmentsApi
     */
    public enrollmentsList(options?: RawAxiosRequestConfig) {
        return EnrollmentsApiFp(this.configuration).enrollmentsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update enrollment email preferences
     * @param {EnrollmentsApiEnrollmentsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnrollmentsApi
     */
    public enrollmentsPartialUpdate(requestParameters: EnrollmentsApiEnrollmentsPartialUpdateRequest, options?: RawAxiosRequestConfig) {
        return EnrollmentsApiFp(this.configuration).enrollmentsPartialUpdate(requestParameters.id, requestParameters.PatchedUpdateCourseRunEnrollmentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API view set for user enrollments
     * @param {EnrollmentsApiEnrollmentsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnrollmentsApi
     */
    public enrollmentsUpdate(requestParameters: EnrollmentsApiEnrollmentsUpdateRequest, options?: RawAxiosRequestConfig) {
        return EnrollmentsApiFp(this.configuration).enrollmentsUpdate(requestParameters.id, requestParameters.CourseRunEnrollmentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new user enrollment - API v2
     * @param {EnrollmentsApiUserEnrollmentsCreateV2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnrollmentsApi
     */
    public userEnrollmentsCreateV2(requestParameters: EnrollmentsApiUserEnrollmentsCreateV2Request, options?: RawAxiosRequestConfig) {
        return EnrollmentsApiFp(this.configuration).userEnrollmentsCreateV2(requestParameters.CourseRunEnrollmentRequestV2Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unenroll from a course - API v2
     * @param {EnrollmentsApiUserEnrollmentsDestroyV2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnrollmentsApi
     */
    public userEnrollmentsDestroyV2(requestParameters: EnrollmentsApiUserEnrollmentsDestroyV2Request, options?: RawAxiosRequestConfig) {
        return EnrollmentsApiFp(this.configuration).userEnrollmentsDestroyV2(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List user enrollments with B2B organization and contract information - API v2. Use ?exclude_b2b=true to filter out enrollments linked to course runs with B2B contracts. Use ?org_id=<id> to filter enrollments by specific B2B organization.
     * @param {EnrollmentsApiUserEnrollmentsListV2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnrollmentsApi
     */
    public userEnrollmentsListV2(requestParameters: EnrollmentsApiUserEnrollmentsListV2Request = {}, options?: RawAxiosRequestConfig) {
        return EnrollmentsApiFp(this.configuration).userEnrollmentsListV2(requestParameters.exclude_b2b, requestParameters.org_id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrdersApi - axios parameter creator
 * @export
 */
export const OrdersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrives the current user\'s order history.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersHistoryList: async (limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v0/orders/history/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a historical order for the current user.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersHistoryRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ordersHistoryRetrieve', 'id', id)
            const localVarPath = `/api/v0/orders/history/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Viewset to retrieve an order so it can be viewed as a receipt.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersReceiptRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ordersReceiptRetrieve', 'id', id)
            const localVarPath = `/api/v0/orders/receipt/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrdersApi - functional programming interface
 * @export
 */
export const OrdersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrdersApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrives the current user\'s order history.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ordersHistoryList(limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedOrderHistoryList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ordersHistoryList(limit, offset, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OrdersApi.ordersHistoryList']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Retrieve a historical order for the current user.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ordersHistoryRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderHistory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ordersHistoryRetrieve(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OrdersApi.ordersHistoryRetrieve']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Viewset to retrieve an order so it can be viewed as a receipt.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ordersReceiptRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ordersReceiptRetrieve(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OrdersApi.ordersReceiptRetrieve']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * OrdersApi - factory interface
 * @export
 */
export const OrdersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrdersApiFp(configuration)
    return {
        /**
         * Retrives the current user\'s order history.
         * @param {OrdersApiOrdersHistoryListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersHistoryList(requestParameters: OrdersApiOrdersHistoryListRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedOrderHistoryList> {
            return localVarFp.ordersHistoryList(requestParameters.limit, requestParameters.offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a historical order for the current user.
         * @param {OrdersApiOrdersHistoryRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersHistoryRetrieve(requestParameters: OrdersApiOrdersHistoryRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<OrderHistory> {
            return localVarFp.ordersHistoryRetrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Viewset to retrieve an order so it can be viewed as a receipt.
         * @param {OrdersApiOrdersReceiptRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersReceiptRetrieve(requestParameters: OrdersApiOrdersReceiptRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<Order> {
            return localVarFp.ordersReceiptRetrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for ordersHistoryList operation in OrdersApi.
 * @export
 * @interface OrdersApiOrdersHistoryListRequest
 */
export interface OrdersApiOrdersHistoryListRequest {
    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof OrdersApiOrdersHistoryList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof OrdersApiOrdersHistoryList
     */
    readonly offset?: number
}

/**
 * Request parameters for ordersHistoryRetrieve operation in OrdersApi.
 * @export
 * @interface OrdersApiOrdersHistoryRetrieveRequest
 */
export interface OrdersApiOrdersHistoryRetrieveRequest {
    /**
     * 
     * @type {number}
     * @memberof OrdersApiOrdersHistoryRetrieve
     */
    readonly id: number
}

/**
 * Request parameters for ordersReceiptRetrieve operation in OrdersApi.
 * @export
 * @interface OrdersApiOrdersReceiptRetrieveRequest
 */
export interface OrdersApiOrdersReceiptRetrieveRequest {
    /**
     * 
     * @type {number}
     * @memberof OrdersApiOrdersReceiptRetrieve
     */
    readonly id: number
}

/**
 * OrdersApi - object-oriented interface
 * @export
 * @class OrdersApi
 * @extends {BaseAPI}
 */
export class OrdersApi extends BaseAPI {
    /**
     * Retrives the current user\'s order history.
     * @param {OrdersApiOrdersHistoryListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public ordersHistoryList(requestParameters: OrdersApiOrdersHistoryListRequest = {}, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).ordersHistoryList(requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a historical order for the current user.
     * @param {OrdersApiOrdersHistoryRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public ordersHistoryRetrieve(requestParameters: OrdersApiOrdersHistoryRetrieveRequest, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).ordersHistoryRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Viewset to retrieve an order so it can be viewed as a receipt.
     * @param {OrdersApiOrdersReceiptRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public ordersReceiptRetrieve(requestParameters: OrdersApiOrdersReceiptRetrieveRequest, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).ordersReceiptRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PagesApi - axios parameter creator
 * @export
 */
export const PagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns pages of all types
         * @summary List all Wagtail Pages
         * @param {string} [fields] Specify fields (e.g. &#x60;*&#x60;)
         * @param {string} [type] Filter by Wagtail page type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pagesList: async (fields?: string, type?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/pages/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns details of a specific Wagtail page by ID
         * @summary Get Wagtail Page Details
         * @param {number} id ID of the Wagtail page
         * @param {number} [revision_id] Optional certificate revision ID to retrieve a specific revision of the certificate page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pagesRetrieve: async (id: number, revision_id?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pagesRetrieve', 'id', id)
            const localVarPath = `/api/v2/pages/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (revision_id !== undefined) {
                localVarQueryParameter['revision_id'] = revision_id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns pages of type cms.CertificatePage
         * @summary List all Certificate Pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pagesfieldstypecmsCertificatepageRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/pages/?fields=*&type=cms.certificatepage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns pages of type cms.CoursePage
         * @summary List all Course Pages
         * @param {string} [readable_id] filter by course readable_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pagesfieldstypecmsCoursepageRetrieve: async (readable_id?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/pages/?fields=*&type=cms.coursepage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (readable_id !== undefined) {
                localVarQueryParameter['readable_id'] = readable_id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns pages of type cms.ProgramPage
         * @summary List all Program Pages
         * @param {string} [readable_id] filter by program readable_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pagesfieldstypecmsProgrampageRetrieve: async (readable_id?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/pages/?fields=*&type=cms.programpage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (readable_id !== undefined) {
                localVarQueryParameter['readable_id'] = readable_id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PagesApi - functional programming interface
 * @export
 */
export const PagesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PagesApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns pages of all types
         * @summary List all Wagtail Pages
         * @param {string} [fields] Specify fields (e.g. &#x60;*&#x60;)
         * @param {string} [type] Filter by Wagtail page type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pagesList(fields?: string, type?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pagesList(fields, type, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PagesApi.pagesList']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Returns details of a specific Wagtail page by ID
         * @summary Get Wagtail Page Details
         * @param {number} id ID of the Wagtail page
         * @param {number} [revision_id] Optional certificate revision ID to retrieve a specific revision of the certificate page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pagesRetrieve(id: number, revision_id?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PagesRetrieve200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pagesRetrieve(id, revision_id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PagesApi.pagesRetrieve']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Returns pages of type cms.CertificatePage
         * @summary List all Certificate Pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pagesfieldstypecmsCertificatepageRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CertificatePageList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pagesfieldstypecmsCertificatepageRetrieve(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PagesApi.pagesfieldstypecmsCertificatepageRetrieve']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Returns pages of type cms.CoursePage
         * @summary List all Course Pages
         * @param {string} [readable_id] filter by course readable_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pagesfieldstypecmsCoursepageRetrieve(readable_id?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CoursePageList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pagesfieldstypecmsCoursepageRetrieve(readable_id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PagesApi.pagesfieldstypecmsCoursepageRetrieve']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Returns pages of type cms.ProgramPage
         * @summary List all Program Pages
         * @param {string} [readable_id] filter by program readable_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pagesfieldstypecmsProgrampageRetrieve(readable_id?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProgramPageList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pagesfieldstypecmsProgrampageRetrieve(readable_id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PagesApi.pagesfieldstypecmsProgrampageRetrieve']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * PagesApi - factory interface
 * @export
 */
export const PagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PagesApiFp(configuration)
    return {
        /**
         * Returns pages of all types
         * @summary List all Wagtail Pages
         * @param {PagesApiPagesListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pagesList(requestParameters: PagesApiPagesListRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PageList> {
            return localVarFp.pagesList(requestParameters.fields, requestParameters.type, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns details of a specific Wagtail page by ID
         * @summary Get Wagtail Page Details
         * @param {PagesApiPagesRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pagesRetrieve(requestParameters: PagesApiPagesRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<PagesRetrieve200Response> {
            return localVarFp.pagesRetrieve(requestParameters.id, requestParameters.revision_id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns pages of type cms.CertificatePage
         * @summary List all Certificate Pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pagesfieldstypecmsCertificatepageRetrieve(options?: RawAxiosRequestConfig): AxiosPromise<CertificatePageList> {
            return localVarFp.pagesfieldstypecmsCertificatepageRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns pages of type cms.CoursePage
         * @summary List all Course Pages
         * @param {PagesApiPagesfieldstypecmsCoursepageRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pagesfieldstypecmsCoursepageRetrieve(requestParameters: PagesApiPagesfieldstypecmsCoursepageRetrieveRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<CoursePageList> {
            return localVarFp.pagesfieldstypecmsCoursepageRetrieve(requestParameters.readable_id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns pages of type cms.ProgramPage
         * @summary List all Program Pages
         * @param {PagesApiPagesfieldstypecmsProgrampageRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pagesfieldstypecmsProgrampageRetrieve(requestParameters: PagesApiPagesfieldstypecmsProgrampageRetrieveRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<ProgramPageList> {
            return localVarFp.pagesfieldstypecmsProgrampageRetrieve(requestParameters.readable_id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for pagesList operation in PagesApi.
 * @export
 * @interface PagesApiPagesListRequest
 */
export interface PagesApiPagesListRequest {
    /**
     * Specify fields (e.g. &#x60;*&#x60;)
     * @type {string}
     * @memberof PagesApiPagesList
     */
    readonly fields?: string

    /**
     * Filter by Wagtail page type
     * @type {string}
     * @memberof PagesApiPagesList
     */
    readonly type?: string
}

/**
 * Request parameters for pagesRetrieve operation in PagesApi.
 * @export
 * @interface PagesApiPagesRetrieveRequest
 */
export interface PagesApiPagesRetrieveRequest {
    /**
     * ID of the Wagtail page
     * @type {number}
     * @memberof PagesApiPagesRetrieve
     */
    readonly id: number

    /**
     * Optional certificate revision ID to retrieve a specific revision of the certificate page
     * @type {number}
     * @memberof PagesApiPagesRetrieve
     */
    readonly revision_id?: number
}

/**
 * Request parameters for pagesfieldstypecmsCoursepageRetrieve operation in PagesApi.
 * @export
 * @interface PagesApiPagesfieldstypecmsCoursepageRetrieveRequest
 */
export interface PagesApiPagesfieldstypecmsCoursepageRetrieveRequest {
    /**
     * filter by course readable_id
     * @type {string}
     * @memberof PagesApiPagesfieldstypecmsCoursepageRetrieve
     */
    readonly readable_id?: string
}

/**
 * Request parameters for pagesfieldstypecmsProgrampageRetrieve operation in PagesApi.
 * @export
 * @interface PagesApiPagesfieldstypecmsProgrampageRetrieveRequest
 */
export interface PagesApiPagesfieldstypecmsProgrampageRetrieveRequest {
    /**
     * filter by program readable_id
     * @type {string}
     * @memberof PagesApiPagesfieldstypecmsProgrampageRetrieve
     */
    readonly readable_id?: string
}

/**
 * PagesApi - object-oriented interface
 * @export
 * @class PagesApi
 * @extends {BaseAPI}
 */
export class PagesApi extends BaseAPI {
    /**
     * Returns pages of all types
     * @summary List all Wagtail Pages
     * @param {PagesApiPagesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PagesApi
     */
    public pagesList(requestParameters: PagesApiPagesListRequest = {}, options?: RawAxiosRequestConfig) {
        return PagesApiFp(this.configuration).pagesList(requestParameters.fields, requestParameters.type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns details of a specific Wagtail page by ID
     * @summary Get Wagtail Page Details
     * @param {PagesApiPagesRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PagesApi
     */
    public pagesRetrieve(requestParameters: PagesApiPagesRetrieveRequest, options?: RawAxiosRequestConfig) {
        return PagesApiFp(this.configuration).pagesRetrieve(requestParameters.id, requestParameters.revision_id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns pages of type cms.CertificatePage
     * @summary List all Certificate Pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PagesApi
     */
    public pagesfieldstypecmsCertificatepageRetrieve(options?: RawAxiosRequestConfig) {
        return PagesApiFp(this.configuration).pagesfieldstypecmsCertificatepageRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns pages of type cms.CoursePage
     * @summary List all Course Pages
     * @param {PagesApiPagesfieldstypecmsCoursepageRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PagesApi
     */
    public pagesfieldstypecmsCoursepageRetrieve(requestParameters: PagesApiPagesfieldstypecmsCoursepageRetrieveRequest = {}, options?: RawAxiosRequestConfig) {
        return PagesApiFp(this.configuration).pagesfieldstypecmsCoursepageRetrieve(requestParameters.readable_id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns pages of type cms.ProgramPage
     * @summary List all Program Pages
     * @param {PagesApiPagesfieldstypecmsProgrampageRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PagesApi
     */
    public pagesfieldstypecmsProgrampageRetrieve(requestParameters: PagesApiPagesfieldstypecmsProgrampageRetrieveRequest = {}, options?: RawAxiosRequestConfig) {
        return PagesApiFp(this.configuration).pagesfieldstypecmsProgrampageRetrieve(requestParameters.readable_id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProductsApi - axios parameter creator
 * @export
 */
export const ProductsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This doesn\'t filter unenrollable products out, and adds name search for courseware object readable id. It\'s really for the staff dashboard.
         * @param {ProductRequest} ProductRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsAllCreate: async (ProductRequest: ProductRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ProductRequest' is not null or undefined
            assertParamExists('productsAllCreate', 'ProductRequest', ProductRequest)
            const localVarPath = `/api/v0/products/all/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ProductRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This doesn\'t filter unenrollable products out, and adds name search for courseware object readable id. It\'s really for the staff dashboard.
         * @param {number} id A unique integer value identifying this product.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsAllDestroy: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('productsAllDestroy', 'id', id)
            const localVarPath = `/api/v0/products/all/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This doesn\'t filter unenrollable products out, and adds name search for courseware object readable id. It\'s really for the staff dashboard.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsAllList: async (limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v0/products/all/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This doesn\'t filter unenrollable products out, and adds name search for courseware object readable id. It\'s really for the staff dashboard.
         * @param {number} id A unique integer value identifying this product.
         * @param {PatchedProductRequest} [PatchedProductRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsAllPartialUpdate: async (id: number, PatchedProductRequest?: PatchedProductRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('productsAllPartialUpdate', 'id', id)
            const localVarPath = `/api/v0/products/all/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(PatchedProductRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This doesn\'t filter unenrollable products out, and adds name search for courseware object readable id. It\'s really for the staff dashboard.
         * @param {number} id A unique integer value identifying this product.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsAllRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('productsAllRetrieve', 'id', id)
            const localVarPath = `/api/v0/products/all/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This doesn\'t filter unenrollable products out, and adds name search for courseware object readable id. It\'s really for the staff dashboard.
         * @param {number} id A unique integer value identifying this product.
         * @param {ProductRequest} ProductRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsAllUpdate: async (id: number, ProductRequest: ProductRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('productsAllUpdate', 'id', id)
            // verify required parameter 'ProductRequest' is not null or undefined
            assertParamExists('productsAllUpdate', 'ProductRequest', ProductRequest)
            const localVarPath = `/api/v0/products/all/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ProductRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List and view products within the system.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsList: async (limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v0/products/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List and view products within the system.
         * @param {number} id A unique integer value identifying this product.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('productsRetrieve', 'id', id)
            const localVarPath = `/api/v0/products/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a product with user-specific flexible price information
         * @param {number} id A unique integer value identifying this product.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsUserFlexiblePriceRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('productsUserFlexiblePriceRetrieve', 'id', id)
            const localVarPath = `/api/v0/products/{id}/user_flexible_price/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductsApi - functional programming interface
 * @export
 */
export const ProductsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductsApiAxiosParamCreator(configuration)
    return {
        /**
         * This doesn\'t filter unenrollable products out, and adds name search for courseware object readable id. It\'s really for the staff dashboard.
         * @param {ProductRequest} ProductRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productsAllCreate(ProductRequest: ProductRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productsAllCreate(ProductRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProductsApi.productsAllCreate']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This doesn\'t filter unenrollable products out, and adds name search for courseware object readable id. It\'s really for the staff dashboard.
         * @param {number} id A unique integer value identifying this product.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productsAllDestroy(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productsAllDestroy(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProductsApi.productsAllDestroy']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This doesn\'t filter unenrollable products out, and adds name search for courseware object readable id. It\'s really for the staff dashboard.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productsAllList(limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedProductList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productsAllList(limit, offset, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProductsApi.productsAllList']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This doesn\'t filter unenrollable products out, and adds name search for courseware object readable id. It\'s really for the staff dashboard.
         * @param {number} id A unique integer value identifying this product.
         * @param {PatchedProductRequest} [PatchedProductRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productsAllPartialUpdate(id: number, PatchedProductRequest?: PatchedProductRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productsAllPartialUpdate(id, PatchedProductRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProductsApi.productsAllPartialUpdate']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This doesn\'t filter unenrollable products out, and adds name search for courseware object readable id. It\'s really for the staff dashboard.
         * @param {number} id A unique integer value identifying this product.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productsAllRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productsAllRetrieve(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProductsApi.productsAllRetrieve']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This doesn\'t filter unenrollable products out, and adds name search for courseware object readable id. It\'s really for the staff dashboard.
         * @param {number} id A unique integer value identifying this product.
         * @param {ProductRequest} ProductRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productsAllUpdate(id: number, ProductRequest: ProductRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productsAllUpdate(id, ProductRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProductsApi.productsAllUpdate']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * List and view products within the system.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productsList(limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedProductList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productsList(limit, offset, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProductsApi.productsList']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * List and view products within the system.
         * @param {number} id A unique integer value identifying this product.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productsRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productsRetrieve(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProductsApi.productsRetrieve']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Retrieve a product with user-specific flexible price information
         * @param {number} id A unique integer value identifying this product.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productsUserFlexiblePriceRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductFlexiblePrice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productsUserFlexiblePriceRetrieve(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProductsApi.productsUserFlexiblePriceRetrieve']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * ProductsApi - factory interface
 * @export
 */
export const ProductsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductsApiFp(configuration)
    return {
        /**
         * This doesn\'t filter unenrollable products out, and adds name search for courseware object readable id. It\'s really for the staff dashboard.
         * @param {ProductsApiProductsAllCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsAllCreate(requestParameters: ProductsApiProductsAllCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<Product> {
            return localVarFp.productsAllCreate(requestParameters.ProductRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This doesn\'t filter unenrollable products out, and adds name search for courseware object readable id. It\'s really for the staff dashboard.
         * @param {ProductsApiProductsAllDestroyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsAllDestroy(requestParameters: ProductsApiProductsAllDestroyRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.productsAllDestroy(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * This doesn\'t filter unenrollable products out, and adds name search for courseware object readable id. It\'s really for the staff dashboard.
         * @param {ProductsApiProductsAllListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsAllList(requestParameters: ProductsApiProductsAllListRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedProductList> {
            return localVarFp.productsAllList(requestParameters.limit, requestParameters.offset, options).then((request) => request(axios, basePath));
        },
        /**
         * This doesn\'t filter unenrollable products out, and adds name search for courseware object readable id. It\'s really for the staff dashboard.
         * @param {ProductsApiProductsAllPartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsAllPartialUpdate(requestParameters: ProductsApiProductsAllPartialUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<Product> {
            return localVarFp.productsAllPartialUpdate(requestParameters.id, requestParameters.PatchedProductRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This doesn\'t filter unenrollable products out, and adds name search for courseware object readable id. It\'s really for the staff dashboard.
         * @param {ProductsApiProductsAllRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsAllRetrieve(requestParameters: ProductsApiProductsAllRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<Product> {
            return localVarFp.productsAllRetrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * This doesn\'t filter unenrollable products out, and adds name search for courseware object readable id. It\'s really for the staff dashboard.
         * @param {ProductsApiProductsAllUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsAllUpdate(requestParameters: ProductsApiProductsAllUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<Product> {
            return localVarFp.productsAllUpdate(requestParameters.id, requestParameters.ProductRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * List and view products within the system.
         * @param {ProductsApiProductsListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsList(requestParameters: ProductsApiProductsListRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedProductList> {
            return localVarFp.productsList(requestParameters.limit, requestParameters.offset, options).then((request) => request(axios, basePath));
        },
        /**
         * List and view products within the system.
         * @param {ProductsApiProductsRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsRetrieve(requestParameters: ProductsApiProductsRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<Product> {
            return localVarFp.productsRetrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a product with user-specific flexible price information
         * @param {ProductsApiProductsUserFlexiblePriceRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsUserFlexiblePriceRetrieve(requestParameters: ProductsApiProductsUserFlexiblePriceRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProductFlexiblePrice> {
            return localVarFp.productsUserFlexiblePriceRetrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for productsAllCreate operation in ProductsApi.
 * @export
 * @interface ProductsApiProductsAllCreateRequest
 */
export interface ProductsApiProductsAllCreateRequest {
    /**
     * 
     * @type {ProductRequest}
     * @memberof ProductsApiProductsAllCreate
     */
    readonly ProductRequest: ProductRequest
}

/**
 * Request parameters for productsAllDestroy operation in ProductsApi.
 * @export
 * @interface ProductsApiProductsAllDestroyRequest
 */
export interface ProductsApiProductsAllDestroyRequest {
    /**
     * A unique integer value identifying this product.
     * @type {number}
     * @memberof ProductsApiProductsAllDestroy
     */
    readonly id: number
}

/**
 * Request parameters for productsAllList operation in ProductsApi.
 * @export
 * @interface ProductsApiProductsAllListRequest
 */
export interface ProductsApiProductsAllListRequest {
    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof ProductsApiProductsAllList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof ProductsApiProductsAllList
     */
    readonly offset?: number
}

/**
 * Request parameters for productsAllPartialUpdate operation in ProductsApi.
 * @export
 * @interface ProductsApiProductsAllPartialUpdateRequest
 */
export interface ProductsApiProductsAllPartialUpdateRequest {
    /**
     * A unique integer value identifying this product.
     * @type {number}
     * @memberof ProductsApiProductsAllPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {PatchedProductRequest}
     * @memberof ProductsApiProductsAllPartialUpdate
     */
    readonly PatchedProductRequest?: PatchedProductRequest
}

/**
 * Request parameters for productsAllRetrieve operation in ProductsApi.
 * @export
 * @interface ProductsApiProductsAllRetrieveRequest
 */
export interface ProductsApiProductsAllRetrieveRequest {
    /**
     * A unique integer value identifying this product.
     * @type {number}
     * @memberof ProductsApiProductsAllRetrieve
     */
    readonly id: number
}

/**
 * Request parameters for productsAllUpdate operation in ProductsApi.
 * @export
 * @interface ProductsApiProductsAllUpdateRequest
 */
export interface ProductsApiProductsAllUpdateRequest {
    /**
     * A unique integer value identifying this product.
     * @type {number}
     * @memberof ProductsApiProductsAllUpdate
     */
    readonly id: number

    /**
     * 
     * @type {ProductRequest}
     * @memberof ProductsApiProductsAllUpdate
     */
    readonly ProductRequest: ProductRequest
}

/**
 * Request parameters for productsList operation in ProductsApi.
 * @export
 * @interface ProductsApiProductsListRequest
 */
export interface ProductsApiProductsListRequest {
    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof ProductsApiProductsList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof ProductsApiProductsList
     */
    readonly offset?: number
}

/**
 * Request parameters for productsRetrieve operation in ProductsApi.
 * @export
 * @interface ProductsApiProductsRetrieveRequest
 */
export interface ProductsApiProductsRetrieveRequest {
    /**
     * A unique integer value identifying this product.
     * @type {number}
     * @memberof ProductsApiProductsRetrieve
     */
    readonly id: number
}

/**
 * Request parameters for productsUserFlexiblePriceRetrieve operation in ProductsApi.
 * @export
 * @interface ProductsApiProductsUserFlexiblePriceRetrieveRequest
 */
export interface ProductsApiProductsUserFlexiblePriceRetrieveRequest {
    /**
     * A unique integer value identifying this product.
     * @type {number}
     * @memberof ProductsApiProductsUserFlexiblePriceRetrieve
     */
    readonly id: number
}

/**
 * ProductsApi - object-oriented interface
 * @export
 * @class ProductsApi
 * @extends {BaseAPI}
 */
export class ProductsApi extends BaseAPI {
    /**
     * This doesn\'t filter unenrollable products out, and adds name search for courseware object readable id. It\'s really for the staff dashboard.
     * @param {ProductsApiProductsAllCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public productsAllCreate(requestParameters: ProductsApiProductsAllCreateRequest, options?: RawAxiosRequestConfig) {
        return ProductsApiFp(this.configuration).productsAllCreate(requestParameters.ProductRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This doesn\'t filter unenrollable products out, and adds name search for courseware object readable id. It\'s really for the staff dashboard.
     * @param {ProductsApiProductsAllDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public productsAllDestroy(requestParameters: ProductsApiProductsAllDestroyRequest, options?: RawAxiosRequestConfig) {
        return ProductsApiFp(this.configuration).productsAllDestroy(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This doesn\'t filter unenrollable products out, and adds name search for courseware object readable id. It\'s really for the staff dashboard.
     * @param {ProductsApiProductsAllListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public productsAllList(requestParameters: ProductsApiProductsAllListRequest = {}, options?: RawAxiosRequestConfig) {
        return ProductsApiFp(this.configuration).productsAllList(requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This doesn\'t filter unenrollable products out, and adds name search for courseware object readable id. It\'s really for the staff dashboard.
     * @param {ProductsApiProductsAllPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public productsAllPartialUpdate(requestParameters: ProductsApiProductsAllPartialUpdateRequest, options?: RawAxiosRequestConfig) {
        return ProductsApiFp(this.configuration).productsAllPartialUpdate(requestParameters.id, requestParameters.PatchedProductRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This doesn\'t filter unenrollable products out, and adds name search for courseware object readable id. It\'s really for the staff dashboard.
     * @param {ProductsApiProductsAllRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public productsAllRetrieve(requestParameters: ProductsApiProductsAllRetrieveRequest, options?: RawAxiosRequestConfig) {
        return ProductsApiFp(this.configuration).productsAllRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This doesn\'t filter unenrollable products out, and adds name search for courseware object readable id. It\'s really for the staff dashboard.
     * @param {ProductsApiProductsAllUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public productsAllUpdate(requestParameters: ProductsApiProductsAllUpdateRequest, options?: RawAxiosRequestConfig) {
        return ProductsApiFp(this.configuration).productsAllUpdate(requestParameters.id, requestParameters.ProductRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List and view products within the system.
     * @param {ProductsApiProductsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public productsList(requestParameters: ProductsApiProductsListRequest = {}, options?: RawAxiosRequestConfig) {
        return ProductsApiFp(this.configuration).productsList(requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List and view products within the system.
     * @param {ProductsApiProductsRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public productsRetrieve(requestParameters: ProductsApiProductsRetrieveRequest, options?: RawAxiosRequestConfig) {
        return ProductsApiFp(this.configuration).productsRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a product with user-specific flexible price information
     * @param {ProductsApiProductsUserFlexiblePriceRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public productsUserFlexiblePriceRetrieve(requestParameters: ProductsApiProductsUserFlexiblePriceRetrieveRequest, options?: RawAxiosRequestConfig) {
        return ProductsApiFp(this.configuration).productsUserFlexiblePriceRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProgramCertificatesApi - axios parameter creator
 * @export
 */
export const ProgramCertificatesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a program certificate by UUID.
         * @param {string} cert_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        programCertificatesRetrieve: async (cert_uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cert_uuid' is not null or undefined
            assertParamExists('programCertificatesRetrieve', 'cert_uuid', cert_uuid)
            const localVarPath = `/api/v2/program_certificates/{cert_uuid}/`
                .replace(`{${"cert_uuid"}}`, encodeURIComponent(String(cert_uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProgramCertificatesApi - functional programming interface
 * @export
 */
export const ProgramCertificatesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProgramCertificatesApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a program certificate by UUID.
         * @param {string} cert_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async programCertificatesRetrieve(cert_uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V2ProgramCertificate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.programCertificatesRetrieve(cert_uuid, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProgramCertificatesApi.programCertificatesRetrieve']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * ProgramCertificatesApi - factory interface
 * @export
 */
export const ProgramCertificatesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProgramCertificatesApiFp(configuration)
    return {
        /**
         * Get a program certificate by UUID.
         * @param {ProgramCertificatesApiProgramCertificatesRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        programCertificatesRetrieve(requestParameters: ProgramCertificatesApiProgramCertificatesRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<V2ProgramCertificate> {
            return localVarFp.programCertificatesRetrieve(requestParameters.cert_uuid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for programCertificatesRetrieve operation in ProgramCertificatesApi.
 * @export
 * @interface ProgramCertificatesApiProgramCertificatesRetrieveRequest
 */
export interface ProgramCertificatesApiProgramCertificatesRetrieveRequest {
    /**
     * 
     * @type {string}
     * @memberof ProgramCertificatesApiProgramCertificatesRetrieve
     */
    readonly cert_uuid: string
}

/**
 * ProgramCertificatesApi - object-oriented interface
 * @export
 * @class ProgramCertificatesApi
 * @extends {BaseAPI}
 */
export class ProgramCertificatesApi extends BaseAPI {
    /**
     * Get a program certificate by UUID.
     * @param {ProgramCertificatesApiProgramCertificatesRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramCertificatesApi
     */
    public programCertificatesRetrieve(requestParameters: ProgramCertificatesApiProgramCertificatesRetrieveRequest, options?: RawAxiosRequestConfig) {
        return ProgramCertificatesApiFp(this.configuration).programCertificatesRetrieve(requestParameters.cert_uuid, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProgramCollectionsApi - axios parameter creator
 * @export
 */
export const ProgramCollectionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Readonly viewset for ProgramCollection objects.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [page_size] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        programCollectionsList: async (page?: number, page_size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/program-collections/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (page_size !== undefined) {
                localVarQueryParameter['page_size'] = page_size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Readonly viewset for ProgramCollection objects.
         * @param {number} id A unique integer value identifying this Program Collection.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        programCollectionsRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('programCollectionsRetrieve', 'id', id)
            const localVarPath = `/api/v2/program-collections/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProgramCollectionsApi - functional programming interface
 * @export
 */
export const ProgramCollectionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProgramCollectionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Readonly viewset for ProgramCollection objects.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [page_size] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async programCollectionsList(page?: number, page_size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedV2ProgramCollectionList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.programCollectionsList(page, page_size, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProgramCollectionsApi.programCollectionsList']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Readonly viewset for ProgramCollection objects.
         * @param {number} id A unique integer value identifying this Program Collection.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async programCollectionsRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V2ProgramCollection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.programCollectionsRetrieve(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProgramCollectionsApi.programCollectionsRetrieve']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * ProgramCollectionsApi - factory interface
 * @export
 */
export const ProgramCollectionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProgramCollectionsApiFp(configuration)
    return {
        /**
         * Readonly viewset for ProgramCollection objects.
         * @param {ProgramCollectionsApiProgramCollectionsListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        programCollectionsList(requestParameters: ProgramCollectionsApiProgramCollectionsListRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedV2ProgramCollectionList> {
            return localVarFp.programCollectionsList(requestParameters.page, requestParameters.page_size, options).then((request) => request(axios, basePath));
        },
        /**
         * Readonly viewset for ProgramCollection objects.
         * @param {ProgramCollectionsApiProgramCollectionsRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        programCollectionsRetrieve(requestParameters: ProgramCollectionsApiProgramCollectionsRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<V2ProgramCollection> {
            return localVarFp.programCollectionsRetrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for programCollectionsList operation in ProgramCollectionsApi.
 * @export
 * @interface ProgramCollectionsApiProgramCollectionsListRequest
 */
export interface ProgramCollectionsApiProgramCollectionsListRequest {
    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof ProgramCollectionsApiProgramCollectionsList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof ProgramCollectionsApiProgramCollectionsList
     */
    readonly page_size?: number
}

/**
 * Request parameters for programCollectionsRetrieve operation in ProgramCollectionsApi.
 * @export
 * @interface ProgramCollectionsApiProgramCollectionsRetrieveRequest
 */
export interface ProgramCollectionsApiProgramCollectionsRetrieveRequest {
    /**
     * A unique integer value identifying this Program Collection.
     * @type {number}
     * @memberof ProgramCollectionsApiProgramCollectionsRetrieve
     */
    readonly id: number
}

/**
 * ProgramCollectionsApi - object-oriented interface
 * @export
 * @class ProgramCollectionsApi
 * @extends {BaseAPI}
 */
export class ProgramCollectionsApi extends BaseAPI {
    /**
     * Readonly viewset for ProgramCollection objects.
     * @param {ProgramCollectionsApiProgramCollectionsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramCollectionsApi
     */
    public programCollectionsList(requestParameters: ProgramCollectionsApiProgramCollectionsListRequest = {}, options?: RawAxiosRequestConfig) {
        return ProgramCollectionsApiFp(this.configuration).programCollectionsList(requestParameters.page, requestParameters.page_size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Readonly viewset for ProgramCollection objects.
     * @param {ProgramCollectionsApiProgramCollectionsRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramCollectionsApi
     */
    public programCollectionsRetrieve(requestParameters: ProgramCollectionsApiProgramCollectionsRetrieveRequest, options?: RawAxiosRequestConfig) {
        return ProgramCollectionsApiFp(this.configuration).programCollectionsRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProgramEnrollmentsApi - axios parameter creator
 * @export
 */
export const ProgramEnrollmentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Unenroll the user from this program. This is simpler than the corresponding function for CourseRunEnrollments; edX doesn\'t really know what programs are so there\'s nothing to process there.
         * @param {number} id Program enrollment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        programEnrollmentsDestroy: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('programEnrollmentsDestroy', 'id', id)
            const localVarPath = `/api/v1/program_enrollments/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a unified set of program and course enrollments for the current user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        programEnrollmentsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/program_enrollments/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a specific program enrollment.
         * @param {number} id Program enrollment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        programEnrollmentsRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('programEnrollmentsRetrieve', 'id', id)
            const localVarPath = `/api/v1/program_enrollments/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unenroll the user from this program. This is simpler than the corresponding function for CourseRunEnrollments; edX doesn\'t really know what programs are so there\'s nothing to process there.
         * @param {number} id Program enrollment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2ProgramEnrollmentsDestroy: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v2ProgramEnrollmentsDestroy', 'id', id)
            const localVarPath = `/api/v2/program_enrollments/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a unified set of program and course enrollments for the current user using v2 serializers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2ProgramEnrollmentsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/program_enrollments/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a specific program enrollment using v2 serializers.
         * @param {number} id Program enrollment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2ProgramEnrollmentsRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v2ProgramEnrollmentsRetrieve', 'id', id)
            const localVarPath = `/api/v2/program_enrollments/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for user program enrollments with v3 serializers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v3ProgramEnrollmentsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/program_enrollments/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for user program enrollments with v3 serializers.
         * @param {number} program_id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v3ProgramEnrollmentsRetrieve: async (program_id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'program_id' is not null or undefined
            assertParamExists('v3ProgramEnrollmentsRetrieve', 'program_id', program_id)
            const localVarPath = `/api/v3/program_enrollments/{program_id}/`
                .replace(`{${"program_id"}}`, encodeURIComponent(String(program_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProgramEnrollmentsApi - functional programming interface
 * @export
 */
export const ProgramEnrollmentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProgramEnrollmentsApiAxiosParamCreator(configuration)
    return {
        /**
         * Unenroll the user from this program. This is simpler than the corresponding function for CourseRunEnrollments; edX doesn\'t really know what programs are so there\'s nothing to process there.
         * @param {number} id Program enrollment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async programEnrollmentsDestroy(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProgramEnrollmentDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.programEnrollmentsDestroy(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProgramEnrollmentsApi.programEnrollmentsDestroy']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Returns a unified set of program and course enrollments for the current user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async programEnrollmentsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserProgramEnrollmentDetail>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.programEnrollmentsList(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProgramEnrollmentsApi.programEnrollmentsList']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Retrieve a specific program enrollment.
         * @param {number} id Program enrollment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async programEnrollmentsRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProgramEnrollmentDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.programEnrollmentsRetrieve(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProgramEnrollmentsApi.programEnrollmentsRetrieve']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Unenroll the user from this program. This is simpler than the corresponding function for CourseRunEnrollments; edX doesn\'t really know what programs are so there\'s nothing to process there.
         * @param {number} id Program enrollment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2ProgramEnrollmentsDestroy(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<V2UserProgramEnrollmentDetail>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2ProgramEnrollmentsDestroy(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProgramEnrollmentsApi.v2ProgramEnrollmentsDestroy']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Returns a unified set of program and course enrollments for the current user using v2 serializers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2ProgramEnrollmentsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<V2UserProgramEnrollmentDetail>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2ProgramEnrollmentsList(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProgramEnrollmentsApi.v2ProgramEnrollmentsList']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Retrieve a specific program enrollment using v2 serializers.
         * @param {number} id Program enrollment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2ProgramEnrollmentsRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V2UserProgramEnrollmentDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2ProgramEnrollmentsRetrieve(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProgramEnrollmentsApi.v2ProgramEnrollmentsRetrieve']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * ViewSet for user program enrollments with v3 serializers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v3ProgramEnrollmentsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<V3UserProgramEnrollment>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v3ProgramEnrollmentsList(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProgramEnrollmentsApi.v3ProgramEnrollmentsList']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * ViewSet for user program enrollments with v3 serializers.
         * @param {number} program_id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v3ProgramEnrollmentsRetrieve(program_id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V3UserProgramEnrollment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v3ProgramEnrollmentsRetrieve(program_id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProgramEnrollmentsApi.v3ProgramEnrollmentsRetrieve']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * ProgramEnrollmentsApi - factory interface
 * @export
 */
export const ProgramEnrollmentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProgramEnrollmentsApiFp(configuration)
    return {
        /**
         * Unenroll the user from this program. This is simpler than the corresponding function for CourseRunEnrollments; edX doesn\'t really know what programs are so there\'s nothing to process there.
         * @param {ProgramEnrollmentsApiProgramEnrollmentsDestroyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        programEnrollmentsDestroy(requestParameters: ProgramEnrollmentsApiProgramEnrollmentsDestroyRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserProgramEnrollmentDetail> {
            return localVarFp.programEnrollmentsDestroy(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a unified set of program and course enrollments for the current user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        programEnrollmentsList(options?: RawAxiosRequestConfig): AxiosPromise<Array<UserProgramEnrollmentDetail>> {
            return localVarFp.programEnrollmentsList(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific program enrollment.
         * @param {ProgramEnrollmentsApiProgramEnrollmentsRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        programEnrollmentsRetrieve(requestParameters: ProgramEnrollmentsApiProgramEnrollmentsRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserProgramEnrollmentDetail> {
            return localVarFp.programEnrollmentsRetrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Unenroll the user from this program. This is simpler than the corresponding function for CourseRunEnrollments; edX doesn\'t really know what programs are so there\'s nothing to process there.
         * @param {ProgramEnrollmentsApiV2ProgramEnrollmentsDestroyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2ProgramEnrollmentsDestroy(requestParameters: ProgramEnrollmentsApiV2ProgramEnrollmentsDestroyRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<V2UserProgramEnrollmentDetail>> {
            return localVarFp.v2ProgramEnrollmentsDestroy(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a unified set of program and course enrollments for the current user using v2 serializers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2ProgramEnrollmentsList(options?: RawAxiosRequestConfig): AxiosPromise<Array<V2UserProgramEnrollmentDetail>> {
            return localVarFp.v2ProgramEnrollmentsList(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific program enrollment using v2 serializers.
         * @param {ProgramEnrollmentsApiV2ProgramEnrollmentsRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2ProgramEnrollmentsRetrieve(requestParameters: ProgramEnrollmentsApiV2ProgramEnrollmentsRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<V2UserProgramEnrollmentDetail> {
            return localVarFp.v2ProgramEnrollmentsRetrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for user program enrollments with v3 serializers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v3ProgramEnrollmentsList(options?: RawAxiosRequestConfig): AxiosPromise<Array<V3UserProgramEnrollment>> {
            return localVarFp.v3ProgramEnrollmentsList(options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for user program enrollments with v3 serializers.
         * @param {ProgramEnrollmentsApiV3ProgramEnrollmentsRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v3ProgramEnrollmentsRetrieve(requestParameters: ProgramEnrollmentsApiV3ProgramEnrollmentsRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<V3UserProgramEnrollment> {
            return localVarFp.v3ProgramEnrollmentsRetrieve(requestParameters.program_id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for programEnrollmentsDestroy operation in ProgramEnrollmentsApi.
 * @export
 * @interface ProgramEnrollmentsApiProgramEnrollmentsDestroyRequest
 */
export interface ProgramEnrollmentsApiProgramEnrollmentsDestroyRequest {
    /**
     * Program enrollment ID
     * @type {number}
     * @memberof ProgramEnrollmentsApiProgramEnrollmentsDestroy
     */
    readonly id: number
}

/**
 * Request parameters for programEnrollmentsRetrieve operation in ProgramEnrollmentsApi.
 * @export
 * @interface ProgramEnrollmentsApiProgramEnrollmentsRetrieveRequest
 */
export interface ProgramEnrollmentsApiProgramEnrollmentsRetrieveRequest {
    /**
     * Program enrollment ID
     * @type {number}
     * @memberof ProgramEnrollmentsApiProgramEnrollmentsRetrieve
     */
    readonly id: number
}

/**
 * Request parameters for v2ProgramEnrollmentsDestroy operation in ProgramEnrollmentsApi.
 * @export
 * @interface ProgramEnrollmentsApiV2ProgramEnrollmentsDestroyRequest
 */
export interface ProgramEnrollmentsApiV2ProgramEnrollmentsDestroyRequest {
    /**
     * Program enrollment ID
     * @type {number}
     * @memberof ProgramEnrollmentsApiV2ProgramEnrollmentsDestroy
     */
    readonly id: number
}

/**
 * Request parameters for v2ProgramEnrollmentsRetrieve operation in ProgramEnrollmentsApi.
 * @export
 * @interface ProgramEnrollmentsApiV2ProgramEnrollmentsRetrieveRequest
 */
export interface ProgramEnrollmentsApiV2ProgramEnrollmentsRetrieveRequest {
    /**
     * Program enrollment ID
     * @type {number}
     * @memberof ProgramEnrollmentsApiV2ProgramEnrollmentsRetrieve
     */
    readonly id: number
}

/**
 * Request parameters for v3ProgramEnrollmentsRetrieve operation in ProgramEnrollmentsApi.
 * @export
 * @interface ProgramEnrollmentsApiV3ProgramEnrollmentsRetrieveRequest
 */
export interface ProgramEnrollmentsApiV3ProgramEnrollmentsRetrieveRequest {
    /**
     * 
     * @type {number}
     * @memberof ProgramEnrollmentsApiV3ProgramEnrollmentsRetrieve
     */
    readonly program_id: number
}

/**
 * ProgramEnrollmentsApi - object-oriented interface
 * @export
 * @class ProgramEnrollmentsApi
 * @extends {BaseAPI}
 */
export class ProgramEnrollmentsApi extends BaseAPI {
    /**
     * Unenroll the user from this program. This is simpler than the corresponding function for CourseRunEnrollments; edX doesn\'t really know what programs are so there\'s nothing to process there.
     * @param {ProgramEnrollmentsApiProgramEnrollmentsDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramEnrollmentsApi
     */
    public programEnrollmentsDestroy(requestParameters: ProgramEnrollmentsApiProgramEnrollmentsDestroyRequest, options?: RawAxiosRequestConfig) {
        return ProgramEnrollmentsApiFp(this.configuration).programEnrollmentsDestroy(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a unified set of program and course enrollments for the current user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramEnrollmentsApi
     */
    public programEnrollmentsList(options?: RawAxiosRequestConfig) {
        return ProgramEnrollmentsApiFp(this.configuration).programEnrollmentsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a specific program enrollment.
     * @param {ProgramEnrollmentsApiProgramEnrollmentsRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramEnrollmentsApi
     */
    public programEnrollmentsRetrieve(requestParameters: ProgramEnrollmentsApiProgramEnrollmentsRetrieveRequest, options?: RawAxiosRequestConfig) {
        return ProgramEnrollmentsApiFp(this.configuration).programEnrollmentsRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unenroll the user from this program. This is simpler than the corresponding function for CourseRunEnrollments; edX doesn\'t really know what programs are so there\'s nothing to process there.
     * @param {ProgramEnrollmentsApiV2ProgramEnrollmentsDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramEnrollmentsApi
     */
    public v2ProgramEnrollmentsDestroy(requestParameters: ProgramEnrollmentsApiV2ProgramEnrollmentsDestroyRequest, options?: RawAxiosRequestConfig) {
        return ProgramEnrollmentsApiFp(this.configuration).v2ProgramEnrollmentsDestroy(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a unified set of program and course enrollments for the current user using v2 serializers.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramEnrollmentsApi
     */
    public v2ProgramEnrollmentsList(options?: RawAxiosRequestConfig) {
        return ProgramEnrollmentsApiFp(this.configuration).v2ProgramEnrollmentsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a specific program enrollment using v2 serializers.
     * @param {ProgramEnrollmentsApiV2ProgramEnrollmentsRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramEnrollmentsApi
     */
    public v2ProgramEnrollmentsRetrieve(requestParameters: ProgramEnrollmentsApiV2ProgramEnrollmentsRetrieveRequest, options?: RawAxiosRequestConfig) {
        return ProgramEnrollmentsApiFp(this.configuration).v2ProgramEnrollmentsRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for user program enrollments with v3 serializers.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramEnrollmentsApi
     */
    public v3ProgramEnrollmentsList(options?: RawAxiosRequestConfig) {
        return ProgramEnrollmentsApiFp(this.configuration).v3ProgramEnrollmentsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for user program enrollments with v3 serializers.
     * @param {ProgramEnrollmentsApiV3ProgramEnrollmentsRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramEnrollmentsApi
     */
    public v3ProgramEnrollmentsRetrieve(requestParameters: ProgramEnrollmentsApiV3ProgramEnrollmentsRetrieveRequest, options?: RawAxiosRequestConfig) {
        return ProgramEnrollmentsApiFp(this.configuration).v3ProgramEnrollmentsRetrieve(requestParameters.program_id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProgramsApi - axios parameter creator
 * @export
 */
export const ProgramsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List Programs - v1
         * @param {number} [id] 
         * @param {boolean} [live] 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [page_size] Number of results to return per page.
         * @param {string} [readable_id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        programsListV1: async (id?: number, live?: boolean, page?: number, page_size?: number, readable_id?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/programs/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (live !== undefined) {
                localVarQueryParameter['live'] = live;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (page_size !== undefined) {
                localVarQueryParameter['page_size'] = page_size;
            }

            if (readable_id !== undefined) {
                localVarQueryParameter['readable_id'] = readable_id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List Programs - v2
         * @param {number} [contract_id] 
         * @param {Array<number>} [id] Multiple values may be separated by commas.
         * @param {boolean} [live] 
         * @param {number} [org_id] 
         * @param {number} [page] A page number within the paginated result set.
         * @param {boolean} [page__live] 
         * @param {number} [page_size] Number of results to return per page.
         * @param {string} [readable_id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        programsListV2: async (contract_id?: number, id?: Array<number>, live?: boolean, org_id?: number, page?: number, page__live?: boolean, page_size?: number, readable_id?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/programs/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (contract_id !== undefined) {
                localVarQueryParameter['contract_id'] = contract_id;
            }

            if (id) {
                localVarQueryParameter['id'] = id.join(COLLECTION_FORMATS.csv);
            }

            if (live !== undefined) {
                localVarQueryParameter['live'] = live;
            }

            if (org_id !== undefined) {
                localVarQueryParameter['org_id'] = org_id;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (page__live !== undefined) {
                localVarQueryParameter['page__live'] = page__live;
            }

            if (page_size !== undefined) {
                localVarQueryParameter['page_size'] = page_size;
            }

            if (readable_id !== undefined) {
                localVarQueryParameter['readable_id'] = readable_id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API view set for Programs - v1
         * @param {number} id A unique integer value identifying this program.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        programsRetrieveV1: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('programsRetrieveV1', 'id', id)
            const localVarPath = `/api/v1/programs/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API view set for Programs - v2
         * @param {string} id A unique integer value (pk) or readable_id string identifying this program.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        programsRetrieveV2: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('programsRetrieveV2', 'id', id)
            const localVarPath = `/api/v2/programs/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProgramsApi - functional programming interface
 * @export
 */
export const ProgramsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProgramsApiAxiosParamCreator(configuration)
    return {
        /**
         * List Programs - v1
         * @param {number} [id] 
         * @param {boolean} [live] 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [page_size] Number of results to return per page.
         * @param {string} [readable_id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async programsListV1(id?: number, live?: boolean, page?: number, page_size?: number, readable_id?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedV1ProgramList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.programsListV1(id, live, page, page_size, readable_id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProgramsApi.programsListV1']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * List Programs - v2
         * @param {number} [contract_id] 
         * @param {Array<number>} [id] Multiple values may be separated by commas.
         * @param {boolean} [live] 
         * @param {number} [org_id] 
         * @param {number} [page] A page number within the paginated result set.
         * @param {boolean} [page__live] 
         * @param {number} [page_size] Number of results to return per page.
         * @param {string} [readable_id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async programsListV2(contract_id?: number, id?: Array<number>, live?: boolean, org_id?: number, page?: number, page__live?: boolean, page_size?: number, readable_id?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedV2ProgramList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.programsListV2(contract_id, id, live, org_id, page, page__live, page_size, readable_id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProgramsApi.programsListV2']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * API view set for Programs - v1
         * @param {number} id A unique integer value identifying this program.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async programsRetrieveV1(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1Program>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.programsRetrieveV1(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProgramsApi.programsRetrieveV1']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * API view set for Programs - v2
         * @param {string} id A unique integer value (pk) or readable_id string identifying this program.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async programsRetrieveV2(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V2Program>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.programsRetrieveV2(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProgramsApi.programsRetrieveV2']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * ProgramsApi - factory interface
 * @export
 */
export const ProgramsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProgramsApiFp(configuration)
    return {
        /**
         * List Programs - v1
         * @param {ProgramsApiProgramsListV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        programsListV1(requestParameters: ProgramsApiProgramsListV1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedV1ProgramList> {
            return localVarFp.programsListV1(requestParameters.id, requestParameters.live, requestParameters.page, requestParameters.page_size, requestParameters.readable_id, options).then((request) => request(axios, basePath));
        },
        /**
         * List Programs - v2
         * @param {ProgramsApiProgramsListV2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        programsListV2(requestParameters: ProgramsApiProgramsListV2Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedV2ProgramList> {
            return localVarFp.programsListV2(requestParameters.contract_id, requestParameters.id, requestParameters.live, requestParameters.org_id, requestParameters.page, requestParameters.page__live, requestParameters.page_size, requestParameters.readable_id, options).then((request) => request(axios, basePath));
        },
        /**
         * API view set for Programs - v1
         * @param {ProgramsApiProgramsRetrieveV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        programsRetrieveV1(requestParameters: ProgramsApiProgramsRetrieveV1Request, options?: RawAxiosRequestConfig): AxiosPromise<V1Program> {
            return localVarFp.programsRetrieveV1(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * API view set for Programs - v2
         * @param {ProgramsApiProgramsRetrieveV2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        programsRetrieveV2(requestParameters: ProgramsApiProgramsRetrieveV2Request, options?: RawAxiosRequestConfig): AxiosPromise<V2Program> {
            return localVarFp.programsRetrieveV2(requestParameters.id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for programsListV1 operation in ProgramsApi.
 * @export
 * @interface ProgramsApiProgramsListV1Request
 */
export interface ProgramsApiProgramsListV1Request {
    /**
     * 
     * @type {number}
     * @memberof ProgramsApiProgramsListV1
     */
    readonly id?: number

    /**
     * 
     * @type {boolean}
     * @memberof ProgramsApiProgramsListV1
     */
    readonly live?: boolean

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof ProgramsApiProgramsListV1
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof ProgramsApiProgramsListV1
     */
    readonly page_size?: number

    /**
     * 
     * @type {string}
     * @memberof ProgramsApiProgramsListV1
     */
    readonly readable_id?: string
}

/**
 * Request parameters for programsListV2 operation in ProgramsApi.
 * @export
 * @interface ProgramsApiProgramsListV2Request
 */
export interface ProgramsApiProgramsListV2Request {
    /**
     * 
     * @type {number}
     * @memberof ProgramsApiProgramsListV2
     */
    readonly contract_id?: number

    /**
     * Multiple values may be separated by commas.
     * @type {Array<number>}
     * @memberof ProgramsApiProgramsListV2
     */
    readonly id?: Array<number>

    /**
     * 
     * @type {boolean}
     * @memberof ProgramsApiProgramsListV2
     */
    readonly live?: boolean

    /**
     * 
     * @type {number}
     * @memberof ProgramsApiProgramsListV2
     */
    readonly org_id?: number

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof ProgramsApiProgramsListV2
     */
    readonly page?: number

    /**
     * 
     * @type {boolean}
     * @memberof ProgramsApiProgramsListV2
     */
    readonly page__live?: boolean

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof ProgramsApiProgramsListV2
     */
    readonly page_size?: number

    /**
     * 
     * @type {string}
     * @memberof ProgramsApiProgramsListV2
     */
    readonly readable_id?: string
}

/**
 * Request parameters for programsRetrieveV1 operation in ProgramsApi.
 * @export
 * @interface ProgramsApiProgramsRetrieveV1Request
 */
export interface ProgramsApiProgramsRetrieveV1Request {
    /**
     * A unique integer value identifying this program.
     * @type {number}
     * @memberof ProgramsApiProgramsRetrieveV1
     */
    readonly id: number
}

/**
 * Request parameters for programsRetrieveV2 operation in ProgramsApi.
 * @export
 * @interface ProgramsApiProgramsRetrieveV2Request
 */
export interface ProgramsApiProgramsRetrieveV2Request {
    /**
     * A unique integer value (pk) or readable_id string identifying this program.
     * @type {string}
     * @memberof ProgramsApiProgramsRetrieveV2
     */
    readonly id: string
}

/**
 * ProgramsApi - object-oriented interface
 * @export
 * @class ProgramsApi
 * @extends {BaseAPI}
 */
export class ProgramsApi extends BaseAPI {
    /**
     * List Programs - v1
     * @param {ProgramsApiProgramsListV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramsApi
     */
    public programsListV1(requestParameters: ProgramsApiProgramsListV1Request = {}, options?: RawAxiosRequestConfig) {
        return ProgramsApiFp(this.configuration).programsListV1(requestParameters.id, requestParameters.live, requestParameters.page, requestParameters.page_size, requestParameters.readable_id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List Programs - v2
     * @param {ProgramsApiProgramsListV2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramsApi
     */
    public programsListV2(requestParameters: ProgramsApiProgramsListV2Request = {}, options?: RawAxiosRequestConfig) {
        return ProgramsApiFp(this.configuration).programsListV2(requestParameters.contract_id, requestParameters.id, requestParameters.live, requestParameters.org_id, requestParameters.page, requestParameters.page__live, requestParameters.page_size, requestParameters.readable_id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API view set for Programs - v1
     * @param {ProgramsApiProgramsRetrieveV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramsApi
     */
    public programsRetrieveV1(requestParameters: ProgramsApiProgramsRetrieveV1Request, options?: RawAxiosRequestConfig) {
        return ProgramsApiFp(this.configuration).programsRetrieveV1(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API view set for Programs - v2
     * @param {ProgramsApiProgramsRetrieveV2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramsApi
     */
    public programsRetrieveV2(requestParameters: ProgramsApiProgramsRetrieveV2Request, options?: RawAxiosRequestConfig) {
        return ProgramsApiFp(this.configuration).programsRetrieveV2(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserSearchApi - axios parameter creator
 * @export
 */
export const UserSearchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Provides an API for listing system users. This is for the staff dashboard.
         * @param {number} [l] Number of results to return per page.
         * @param {number} [o] The initial index from which to return the results.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSearchList: async (l?: number, o?: number, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v0/user_search/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (l !== undefined) {
                localVarQueryParameter['l'] = l;
            }

            if (o !== undefined) {
                localVarQueryParameter['o'] = o;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Provides an API for listing system users. This is for the staff dashboard.
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSearchRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userSearchRetrieve', 'id', id)
            const localVarPath = `/api/v0/user_search/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserSearchApi - functional programming interface
 * @export
 */
export const UserSearchApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserSearchApiAxiosParamCreator(configuration)
    return {
        /**
         * Provides an API for listing system users. This is for the staff dashboard.
         * @param {number} [l] Number of results to return per page.
         * @param {number} [o] The initial index from which to return the results.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userSearchList(l?: number, o?: number, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedStaffDashboardUserList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userSearchList(l, o, search, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserSearchApi.userSearchList']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Provides an API for listing system users. This is for the staff dashboard.
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userSearchRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StaffDashboardUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userSearchRetrieve(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserSearchApi.userSearchRetrieve']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * UserSearchApi - factory interface
 * @export
 */
export const UserSearchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserSearchApiFp(configuration)
    return {
        /**
         * Provides an API for listing system users. This is for the staff dashboard.
         * @param {UserSearchApiUserSearchListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSearchList(requestParameters: UserSearchApiUserSearchListRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedStaffDashboardUserList> {
            return localVarFp.userSearchList(requestParameters.l, requestParameters.o, requestParameters.search, options).then((request) => request(axios, basePath));
        },
        /**
         * Provides an API for listing system users. This is for the staff dashboard.
         * @param {UserSearchApiUserSearchRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSearchRetrieve(requestParameters: UserSearchApiUserSearchRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<StaffDashboardUser> {
            return localVarFp.userSearchRetrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for userSearchList operation in UserSearchApi.
 * @export
 * @interface UserSearchApiUserSearchListRequest
 */
export interface UserSearchApiUserSearchListRequest {
    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof UserSearchApiUserSearchList
     */
    readonly l?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof UserSearchApiUserSearchList
     */
    readonly o?: number

    /**
     * A search term.
     * @type {string}
     * @memberof UserSearchApiUserSearchList
     */
    readonly search?: string
}

/**
 * Request parameters for userSearchRetrieve operation in UserSearchApi.
 * @export
 * @interface UserSearchApiUserSearchRetrieveRequest
 */
export interface UserSearchApiUserSearchRetrieveRequest {
    /**
     * A unique integer value identifying this user.
     * @type {number}
     * @memberof UserSearchApiUserSearchRetrieve
     */
    readonly id: number
}

/**
 * UserSearchApi - object-oriented interface
 * @export
 * @class UserSearchApi
 * @extends {BaseAPI}
 */
export class UserSearchApi extends BaseAPI {
    /**
     * Provides an API for listing system users. This is for the staff dashboard.
     * @param {UserSearchApiUserSearchListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSearchApi
     */
    public userSearchList(requestParameters: UserSearchApiUserSearchListRequest = {}, options?: RawAxiosRequestConfig) {
        return UserSearchApiFp(this.configuration).userSearchList(requestParameters.l, requestParameters.o, requestParameters.search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Provides an API for listing system users. This is for the staff dashboard.
     * @param {UserSearchApiUserSearchRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSearchApi
     */
    public userSearchRetrieve(requestParameters: UserSearchApiUserSearchRetrieveRequest, options?: RawAxiosRequestConfig) {
        return UserSearchApiFp(this.configuration).userSearchRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserinfoApi - axios parameter creator
 * @export
 */
export const UserinfoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve the current user\'s info only if they have an edx_username, otherwise return 409  This is to prevent issues with Open edX OAuth client that expect an edx_username to be present
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userinfoRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v0/userinfo/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserinfoApi - functional programming interface
 * @export
 */
export const UserinfoApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserinfoApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve the current user\'s info only if they have an edx_username, otherwise return 409  This is to prevent issues with Open edX OAuth client that expect an edx_username to be present
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userinfoRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userinfoRetrieve(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserinfoApi.userinfoRetrieve']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * UserinfoApi - factory interface
 * @export
 */
export const UserinfoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserinfoApiFp(configuration)
    return {
        /**
         * Retrieve the current user\'s info only if they have an edx_username, otherwise return 409  This is to prevent issues with Open edX OAuth client that expect an edx_username to be present
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userinfoRetrieve(options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.userinfoRetrieve(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserinfoApi - object-oriented interface
 * @export
 * @class UserinfoApi
 * @extends {BaseAPI}
 */
export class UserinfoApi extends BaseAPI {
    /**
     * Retrieve the current user\'s info only if they have an edx_username, otherwise return 409  This is to prevent issues with Open edX OAuth client that expect an edx_username to be present
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserinfoApi
     */
    public userinfoRetrieve(options?: RawAxiosRequestConfig) {
        return UserinfoApiFp(this.configuration).userinfoRetrieve(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * User retrieve and update viewsets for the current user
         * @param {PatchedUserRequest} [PatchedUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersCurrentUserPartialUpdate: async (PatchedUserRequest?: PatchedUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v0/users/current_user/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(PatchedUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User retrieve and update viewsets for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersCurrentUserRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v0/users/current_user/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User retrieve and update viewsets for the current user
         * @param {PatchedUserRequest} [PatchedUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMePartialUpdate: async (PatchedUserRequest?: PatchedUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v0/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(PatchedUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User retrieve and update viewsets for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v0/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User retrieve viewsets
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersRetrieve', 'id', id)
            const localVarPath = `/api/v0/users/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * User retrieve and update viewsets for the current user
         * @param {PatchedUserRequest} [PatchedUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersCurrentUserPartialUpdate(PatchedUserRequest?: PatchedUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersCurrentUserPartialUpdate(PatchedUserRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.usersCurrentUserPartialUpdate']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * User retrieve and update viewsets for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersCurrentUserRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersCurrentUserRetrieve(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.usersCurrentUserRetrieve']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * User retrieve and update viewsets for the current user
         * @param {PatchedUserRequest} [PatchedUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersMePartialUpdate(PatchedUserRequest?: PatchedUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersMePartialUpdate(PatchedUserRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.usersMePartialUpdate']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * User retrieve and update viewsets for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersMeRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersMeRetrieve(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.usersMeRetrieve']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * User retrieve viewsets
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersRetrieve(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.usersRetrieve']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * User retrieve and update viewsets for the current user
         * @param {UsersApiUsersCurrentUserPartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersCurrentUserPartialUpdate(requestParameters: UsersApiUsersCurrentUserPartialUpdateRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.usersCurrentUserPartialUpdate(requestParameters.PatchedUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * User retrieve and update viewsets for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersCurrentUserRetrieve(options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.usersCurrentUserRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * User retrieve and update viewsets for the current user
         * @param {UsersApiUsersMePartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMePartialUpdate(requestParameters: UsersApiUsersMePartialUpdateRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.usersMePartialUpdate(requestParameters.PatchedUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * User retrieve and update viewsets for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeRetrieve(options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.usersMeRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * User retrieve viewsets
         * @param {UsersApiUsersRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersRetrieve(requestParameters: UsersApiUsersRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<PublicUser> {
            return localVarFp.usersRetrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for usersCurrentUserPartialUpdate operation in UsersApi.
 * @export
 * @interface UsersApiUsersCurrentUserPartialUpdateRequest
 */
export interface UsersApiUsersCurrentUserPartialUpdateRequest {
    /**
     * 
     * @type {PatchedUserRequest}
     * @memberof UsersApiUsersCurrentUserPartialUpdate
     */
    readonly PatchedUserRequest?: PatchedUserRequest
}

/**
 * Request parameters for usersMePartialUpdate operation in UsersApi.
 * @export
 * @interface UsersApiUsersMePartialUpdateRequest
 */
export interface UsersApiUsersMePartialUpdateRequest {
    /**
     * 
     * @type {PatchedUserRequest}
     * @memberof UsersApiUsersMePartialUpdate
     */
    readonly PatchedUserRequest?: PatchedUserRequest
}

/**
 * Request parameters for usersRetrieve operation in UsersApi.
 * @export
 * @interface UsersApiUsersRetrieveRequest
 */
export interface UsersApiUsersRetrieveRequest {
    /**
     * A unique integer value identifying this user.
     * @type {number}
     * @memberof UsersApiUsersRetrieve
     */
    readonly id: number
}

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * User retrieve and update viewsets for the current user
     * @param {UsersApiUsersCurrentUserPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersCurrentUserPartialUpdate(requestParameters: UsersApiUsersCurrentUserPartialUpdateRequest = {}, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersCurrentUserPartialUpdate(requestParameters.PatchedUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User retrieve and update viewsets for the current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersCurrentUserRetrieve(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersCurrentUserRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User retrieve and update viewsets for the current user
     * @param {UsersApiUsersMePartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersMePartialUpdate(requestParameters: UsersApiUsersMePartialUpdateRequest = {}, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersMePartialUpdate(requestParameters.PatchedUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User retrieve and update viewsets for the current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersMeRetrieve(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersMeRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User retrieve viewsets
     * @param {UsersApiUsersRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersRetrieve(requestParameters: UsersApiUsersRetrieveRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VerifiableCourseCredentialApi - axios parameter creator
 * @export
 */
export const VerifiableCourseCredentialApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the json for the verifiable credential with the given ID
         * @param {string} credential_id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifiableCourseCredentialDownloadList: async (credential_id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'credential_id' is not null or undefined
            assertParamExists('verifiableCourseCredentialDownloadList', 'credential_id', credential_id)
            const localVarPath = `/api/v2/verifiable_course_credential/{credential_id}/download/`
                .replace(`{${"credential_id"}}`, encodeURIComponent(String(credential_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VerifiableCourseCredentialApi - functional programming interface
 * @export
 */
export const VerifiableCourseCredentialApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VerifiableCourseCredentialApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the json for the verifiable credential with the given ID
         * @param {string} credential_id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifiableCourseCredentialDownloadList(credential_id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifiableCourseCredentialDownloadList(credential_id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['VerifiableCourseCredentialApi.verifiableCourseCredentialDownloadList']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * VerifiableCourseCredentialApi - factory interface
 * @export
 */
export const VerifiableCourseCredentialApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VerifiableCourseCredentialApiFp(configuration)
    return {
        /**
         * Returns the json for the verifiable credential with the given ID
         * @param {VerifiableCourseCredentialApiVerifiableCourseCredentialDownloadListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifiableCourseCredentialDownloadList(requestParameters: VerifiableCourseCredentialApiVerifiableCourseCredentialDownloadListRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.verifiableCourseCredentialDownloadList(requestParameters.credential_id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for verifiableCourseCredentialDownloadList operation in VerifiableCourseCredentialApi.
 * @export
 * @interface VerifiableCourseCredentialApiVerifiableCourseCredentialDownloadListRequest
 */
export interface VerifiableCourseCredentialApiVerifiableCourseCredentialDownloadListRequest {
    /**
     * 
     * @type {string}
     * @memberof VerifiableCourseCredentialApiVerifiableCourseCredentialDownloadList
     */
    readonly credential_id: string
}

/**
 * VerifiableCourseCredentialApi - object-oriented interface
 * @export
 * @class VerifiableCourseCredentialApi
 * @extends {BaseAPI}
 */
export class VerifiableCourseCredentialApi extends BaseAPI {
    /**
     * Returns the json for the verifiable credential with the given ID
     * @param {VerifiableCourseCredentialApiVerifiableCourseCredentialDownloadListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VerifiableCourseCredentialApi
     */
    public verifiableCourseCredentialDownloadList(requestParameters: VerifiableCourseCredentialApiVerifiableCourseCredentialDownloadListRequest, options?: RawAxiosRequestConfig) {
        return VerifiableCourseCredentialApiFp(this.configuration).verifiableCourseCredentialDownloadList(requestParameters.credential_id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VerifiableProgramCredentialApi - axios parameter creator
 * @export
 */
export const VerifiableProgramCredentialApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the json for the verifiable credential with the given ID
         * @param {string} credential_id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifiableProgramCredentialDownloadList: async (credential_id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'credential_id' is not null or undefined
            assertParamExists('verifiableProgramCredentialDownloadList', 'credential_id', credential_id)
            const localVarPath = `/api/v2/verifiable_program_credential/{credential_id}/download/`
                .replace(`{${"credential_id"}}`, encodeURIComponent(String(credential_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VerifiableProgramCredentialApi - functional programming interface
 * @export
 */
export const VerifiableProgramCredentialApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VerifiableProgramCredentialApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the json for the verifiable credential with the given ID
         * @param {string} credential_id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifiableProgramCredentialDownloadList(credential_id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifiableProgramCredentialDownloadList(credential_id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['VerifiableProgramCredentialApi.verifiableProgramCredentialDownloadList']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * VerifiableProgramCredentialApi - factory interface
 * @export
 */
export const VerifiableProgramCredentialApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VerifiableProgramCredentialApiFp(configuration)
    return {
        /**
         * Returns the json for the verifiable credential with the given ID
         * @param {VerifiableProgramCredentialApiVerifiableProgramCredentialDownloadListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifiableProgramCredentialDownloadList(requestParameters: VerifiableProgramCredentialApiVerifiableProgramCredentialDownloadListRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.verifiableProgramCredentialDownloadList(requestParameters.credential_id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for verifiableProgramCredentialDownloadList operation in VerifiableProgramCredentialApi.
 * @export
 * @interface VerifiableProgramCredentialApiVerifiableProgramCredentialDownloadListRequest
 */
export interface VerifiableProgramCredentialApiVerifiableProgramCredentialDownloadListRequest {
    /**
     * 
     * @type {string}
     * @memberof VerifiableProgramCredentialApiVerifiableProgramCredentialDownloadList
     */
    readonly credential_id: string
}

/**
 * VerifiableProgramCredentialApi - object-oriented interface
 * @export
 * @class VerifiableProgramCredentialApi
 * @extends {BaseAPI}
 */
export class VerifiableProgramCredentialApi extends BaseAPI {
    /**
     * Returns the json for the verifiable credential with the given ID
     * @param {VerifiableProgramCredentialApiVerifiableProgramCredentialDownloadListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VerifiableProgramCredentialApi
     */
    public verifiableProgramCredentialDownloadList(requestParameters: VerifiableProgramCredentialApiVerifiableProgramCredentialDownloadListRequest, options?: RawAxiosRequestConfig) {
        return VerifiableProgramCredentialApiFp(this.configuration).verifiableProgramCredentialDownloadList(requestParameters.credential_id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VerifiedProgramEnrollmentsApi - axios parameter creator
 * @export
 */
export const VerifiedProgramEnrollmentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a program-related course enrollment for the learner.  Some special handling is needed for program-related course run enrollments when the learner has an enrollment in the program. The learner should get a course run enrollment that matches their program enrollment at no additional charge. However, if the learner is enrolling in a course that\'s an elective, and they have already enrolled in enough electives to satisfy the program\'s requirements, they should then get an audit enrollment. (This won\'t preclude them from getting a certificate for the course itself but they\'ll have to buy the upgrade separately.)
         * @param {string} courserun_id Readable ID for the course run to enroll in.
         * @param {string} program_id Readable ID for the program.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifiedProgramEnrollmentsCreate: async (courserun_id: string, program_id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courserun_id' is not null or undefined
            assertParamExists('verifiedProgramEnrollmentsCreate', 'courserun_id', courserun_id)
            // verify required parameter 'program_id' is not null or undefined
            assertParamExists('verifiedProgramEnrollmentsCreate', 'program_id', program_id)
            const localVarPath = `/api/v2/verified_program_enrollments/{program_id}/{courserun_id}/`
                .replace(`{${"courserun_id"}}`, encodeURIComponent(String(courserun_id)))
                .replace(`{${"program_id"}}`, encodeURIComponent(String(program_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VerifiedProgramEnrollmentsApi - functional programming interface
 * @export
 */
export const VerifiedProgramEnrollmentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VerifiedProgramEnrollmentsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a program-related course enrollment for the learner.  Some special handling is needed for program-related course run enrollments when the learner has an enrollment in the program. The learner should get a course run enrollment that matches their program enrollment at no additional charge. However, if the learner is enrolling in a course that\'s an elective, and they have already enrolled in enough electives to satisfy the program\'s requirements, they should then get an audit enrollment. (This won\'t preclude them from getting a certificate for the course itself but they\'ll have to buy the upgrade separately.)
         * @param {string} courserun_id Readable ID for the course run to enroll in.
         * @param {string} program_id Readable ID for the program.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifiedProgramEnrollmentsCreate(courserun_id: string, program_id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseRunEnrollmentRequestV2>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifiedProgramEnrollmentsCreate(courserun_id, program_id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['VerifiedProgramEnrollmentsApi.verifiedProgramEnrollmentsCreate']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * VerifiedProgramEnrollmentsApi - factory interface
 * @export
 */
export const VerifiedProgramEnrollmentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VerifiedProgramEnrollmentsApiFp(configuration)
    return {
        /**
         * Create a program-related course enrollment for the learner.  Some special handling is needed for program-related course run enrollments when the learner has an enrollment in the program. The learner should get a course run enrollment that matches their program enrollment at no additional charge. However, if the learner is enrolling in a course that\'s an elective, and they have already enrolled in enough electives to satisfy the program\'s requirements, they should then get an audit enrollment. (This won\'t preclude them from getting a certificate for the course itself but they\'ll have to buy the upgrade separately.)
         * @param {VerifiedProgramEnrollmentsApiVerifiedProgramEnrollmentsCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifiedProgramEnrollmentsCreate(requestParameters: VerifiedProgramEnrollmentsApiVerifiedProgramEnrollmentsCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<CourseRunEnrollmentRequestV2> {
            return localVarFp.verifiedProgramEnrollmentsCreate(requestParameters.courserun_id, requestParameters.program_id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for verifiedProgramEnrollmentsCreate operation in VerifiedProgramEnrollmentsApi.
 * @export
 * @interface VerifiedProgramEnrollmentsApiVerifiedProgramEnrollmentsCreateRequest
 */
export interface VerifiedProgramEnrollmentsApiVerifiedProgramEnrollmentsCreateRequest {
    /**
     * Readable ID for the course run to enroll in.
     * @type {string}
     * @memberof VerifiedProgramEnrollmentsApiVerifiedProgramEnrollmentsCreate
     */
    readonly courserun_id: string

    /**
     * Readable ID for the program.
     * @type {string}
     * @memberof VerifiedProgramEnrollmentsApiVerifiedProgramEnrollmentsCreate
     */
    readonly program_id: string
}

/**
 * VerifiedProgramEnrollmentsApi - object-oriented interface
 * @export
 * @class VerifiedProgramEnrollmentsApi
 * @extends {BaseAPI}
 */
export class VerifiedProgramEnrollmentsApi extends BaseAPI {
    /**
     * Create a program-related course enrollment for the learner.  Some special handling is needed for program-related course run enrollments when the learner has an enrollment in the program. The learner should get a course run enrollment that matches their program enrollment at no additional charge. However, if the learner is enrolling in a course that\'s an elective, and they have already enrolled in enough electives to satisfy the program\'s requirements, they should then get an audit enrollment. (This won\'t preclude them from getting a certificate for the course itself but they\'ll have to buy the upgrade separately.)
     * @param {VerifiedProgramEnrollmentsApiVerifiedProgramEnrollmentsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VerifiedProgramEnrollmentsApi
     */
    public verifiedProgramEnrollmentsCreate(requestParameters: VerifiedProgramEnrollmentsApiVerifiedProgramEnrollmentsCreateRequest, options?: RawAxiosRequestConfig) {
        return VerifiedProgramEnrollmentsApiFp(this.configuration).verifiedProgramEnrollmentsCreate(requestParameters.courserun_id, requestParameters.program_id, options).then((request) => request(this.axios, this.basePath));
    }
}



